/*
Deployment script for TigerWrapDb (v0.9.0)

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "TigerWrapDb"
:setvar DefaultFilePrefix "TigerWrapDb"
:setvar DefaultDataPath "C:\MsSQL\Data\"
:setvar DefaultLogPath "C:\MsSQL\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- note: uncomment below line only for generating upgrade script (and make sure the versions in the script below and in the version script are set up correctly
-- :r .\Script.PreUpgradeVersionCheck.sql
GO

GO
PRINT N'Creating Schema [DbInfo]...';


GO
CREATE SCHEMA [DbInfo]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Enum]...';


GO
CREATE SCHEMA [Enum]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Flag]...';


GO
CREATE SCHEMA [Flag]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Internal]...';


GO
CREATE SCHEMA [Internal]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Parser]...';


GO
CREATE SCHEMA [Parser]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [ParserEnum]...';


GO
CREATE SCHEMA [ParserEnum]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Project]...';


GO
CREATE SCHEMA [Project]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Static]...';


GO
CREATE SCHEMA [Static]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Toolkit]...';


GO
CREATE SCHEMA [Toolkit]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [View]...';


GO
CREATE SCHEMA [View]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating User-Defined Table Type [Internal].[Enum]...';


GO
CREATE TYPE [Internal].[Enum] AS TABLE (
    [Id]          INT            IDENTITY (1, 1) NOT NULL,
    [Schema]      NVARCHAR (128) NOT NULL,
    [Table]       NVARCHAR (128) NOT NULL,
    [EnumName]    NVARCHAR (256) NOT NULL,
    [NameColumn]  NVARCHAR (128) NOT NULL,
    [ValueColumn] NVARCHAR (128) NOT NULL,
    UNIQUE NONCLUSTERED ([Schema] ASC, [Table] ASC),
    UNIQUE NONCLUSTERED ([EnumName] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating User-Defined Table Type [Internal].[EnumValue]...';


GO
CREATE TYPE [Internal].[EnumValue] AS TABLE (
    [Id]     INT            IDENTITY (1, 1) NOT NULL,
    [EnumId] INT            NOT NULL,
    [Name]   NVARCHAR (128) NOT NULL,
    [Value]  BIGINT         NOT NULL,
    UNIQUE NONCLUSTERED ([EnumId] ASC, [Value] ASC),
    UNIQUE NONCLUSTERED ([EnumId] ASC, [Name] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating User-Defined Table Type [Internal].[Variable]...';


GO
CREATE TYPE [Internal].[Variable] AS TABLE (
    [Id]    INT             IDENTITY (1, 1) NOT NULL,
    [Name]  NVARCHAR (128)  NOT NULL,
    [Value] NVARCHAR (4000) NULL,
    UNIQUE NONCLUSTERED ([Name] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating Table [Enum].[ParamEnumMapping]...';


GO
CREATE TABLE [Enum].[ParamEnumMapping] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (100) NOT NULL,
    CONSTRAINT [PK_Enum_ParamEnumMapping] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[ParamEnumMapping].[UX_Enum_ParamEnumMapping_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_ParamEnumMapping_Name]
    ON [Enum].[ParamEnumMapping]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[Casing]...';


GO
CREATE TABLE [Enum].[Casing] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_Casing] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[Casing].[UX_Enum_Casing_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_Casing_Name]
    ON [Enum].[Casing]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[ClassAccess]...';


GO
CREATE TABLE [Enum].[ClassAccess] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_ClassAccess] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[ClassAccess].[UX_Enum_ClassAccess_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_ClassAccess_Name]
    ON [Enum].[ClassAccess]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[Language]...';


GO
CREATE TABLE [Enum].[Language] (
    [Id]       TINYINT       NOT NULL,
    [Name]     VARCHAR (200) NOT NULL,
    [Code]     VARCHAR (50)  NOT NULL,
    [StatusId] TINYINT       NOT NULL,
    CONSTRAINT [PK_Enum_Language] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[Language].[UX_Enum_Language_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_Language_Name]
    ON [Enum].[Language]([Name] ASC);


GO
PRINT N'Creating Index [Enum].[Language].[UX_Enum_Language_Code]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_Language_Code]
    ON [Enum].[Language]([Code] ASC);


GO
PRINT N'Creating Table [Enum].[TemplateType]...';


GO
CREATE TABLE [Enum].[TemplateType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_Enum_TemplateType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[TemplateType].[UX_Enum_TemplateType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_TemplateType_Name]
    ON [Enum].[TemplateType]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[NameType]...';


GO
CREATE TABLE [Enum].[NameType] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_NameType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[NameType].[UX_Enum_NameType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_NameType_Name]
    ON [Enum].[NameType]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[CodePart]...';


GO
CREATE TABLE [Enum].[CodePart] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    [Code] CHAR (1)     NOT NULL,
    CONSTRAINT [PK_CodePart] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_CodePart_Code] UNIQUE NONCLUSTERED ([Code] ASC),
    CONSTRAINT [UQ_CodePart_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating Table [Enum].[LoggingLevel]...';


GO
CREATE TABLE [Enum].[LoggingLevel] (
    [Id]   TINYINT      NOT NULL,
    [Code] CHAR (1)     NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_Enum_LoggingLevel] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_Enum_LoggingLevel_Code] UNIQUE NONCLUSTERED ([Code] ASC),
    CONSTRAINT [UQ_Enum_LoggingLevel_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating Table [Enum].[Status]...';


GO
CREATE TABLE [Enum].[Status] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_Enum_Status] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_Enum_Status_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating Table [Enum].[ToolkitResponseCode]...';


GO
CREATE TABLE [Enum].[ToolkitResponseCode] (
    [Id]          INT            NOT NULL,
    [Name]        VARCHAR (100)  NOT NULL,
    [Description] NVARCHAR (255) NULL,
    [IsSuccess]   BIT            NOT NULL,
    CONSTRAINT [PK_ToolkitResponseCode] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_ToolkitResponseCode_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating Table [Enum].[NamePartType]...';


GO
CREATE TABLE [Enum].[NamePartType] (
    [Id]           TINYINT      NOT NULL,
    [Name]         VARCHAR (50) NOT NULL,
    [NameSourceId] TINYINT      NULL,
    [IsPrefix]     BIT          NOT NULL,
    [IsSuffix]     BIT          NOT NULL,
    CONSTRAINT [PK_NamePartType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[NamePartType].[UX_NamePartType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_NamePartType_Name]
    ON [Enum].[NamePartType]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[NameSource]...';


GO
CREATE TABLE [Enum].[NameSource] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_NameSource] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[NameSource].[UX_NameSource_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_NameSource_Name]
    ON [Enum].[NameSource]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[NameMatch]...';


GO
CREATE TABLE [Enum].[NameMatch] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_NameMatch] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[NameMatch].[UX_NameMatch_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_NameMatch_Name]
    ON [Enum].[NameMatch]([Name] ASC);


GO
PRINT N'Creating Table [Parser].[Operator]...';


GO
CREATE TABLE [Parser].[Operator] (
    [Id]       TINYINT       NOT NULL,
    [Name]     VARCHAR (50)  NOT NULL,
    [Operator] NVARCHAR (10) NOT NULL,
    [Unary]    BIT           NOT NULL,
    [Binary]   BIT           NOT NULL,
    CONSTRAINT [PK_Parser_Operator] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Parser].[Operator].[UX_Parser_Operator_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Parser_Operator_Name]
    ON [Parser].[Operator]([Name] ASC);


GO
PRINT N'Creating Index [Parser].[Operator].[UX_Parser_Operator_Operator]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Parser_Operator_Operator]
    ON [Parser].[Operator]([Operator] ASC);


GO
PRINT N'Creating Table [Parser].[TSqlSequence]...';


GO
CREATE TABLE [Parser].[TSqlSequence] (
    [Id]              SMALLINT     IDENTITY (1, 1) NOT NULL,
    [Name]            VARCHAR (50) NOT NULL,
    [SequenceTypeId]  TINYINT      NOT NULL,
    [StatementTypeId] SMALLINT     NULL,
    [Precedence]      SMALLINT     NOT NULL,
    CONSTRAINT [PK_Parser_TSqlSequence] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Parser].[TSqlSequence].[UX_Parser_TSqlSequence_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Parser_TSqlSequence_Name]
    ON [Parser].[TSqlSequence]([Name] ASC);


GO
PRINT N'Creating Table [Parser].[CharTypeMap]...';


GO
CREATE TABLE [Parser].[CharTypeMap] (
    [Id]     INT       IDENTITY (1, 1) NOT NULL,
    [Char]   NCHAR (1) COLLATE Latin1_General_BIN NOT NULL,
    [TypeId] TINYINT   NOT NULL,
    CONSTRAINT [PK_Parser_CharTypeMap] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Parser].[CharTypeMap].[UX_Parser_CharTypeMap_TypeId_Char]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Parser_CharTypeMap_TypeId_Char]
    ON [Parser].[CharTypeMap]([TypeId] ASC, [Char] ASC);


GO
PRINT N'Creating Index [Parser].[CharTypeMap].[UX_Parser_CharTypeMap_Char]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Parser_CharTypeMap_Char]
    ON [Parser].[CharTypeMap]([Char] ASC);


GO
PRINT N'Creating Table [Parser].[TSqlSeqElement]...';


GO
CREATE TABLE [Parser].[TSqlSeqElement] (
    [Id]              INT            NOT NULL,
    [TypeId]          TINYINT        NOT NULL,
    [SequenceId]      SMALLINT       NOT NULL,
    [IsStartElement]  BIT            NOT NULL,
    [NextElementId]   INT            NULL,
    [AltElementId]    INT            NULL,
    [KeywordId]       SMALLINT       NULL,
    [OperatorId]      TINYINT        NULL,
    [SequenceTypeId]  TINYINT        NULL,
    [StatementPartId] TINYINT        NULL,
    [TokenTypeId]     TINYINT        NULL,
    [TokenSubtypeId]  TINYINT        NULL,
    [StatementTypeId] SMALLINT       NULL,
    [StringValue]     NVARCHAR (200) NULL,
    [IntValue]        BIGINT         NULL,
    CONSTRAINT [PK_Parser_TSqlSeqElement] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Parser].[TSqlSeqElement].[IX_Parser_TSqlSeqElement_SequenceId_IsStartElement]...';


GO
CREATE NONCLUSTERED INDEX [IX_Parser_TSqlSeqElement_SequenceId_IsStartElement]
    ON [Parser].[TSqlSeqElement]([SequenceId] ASC, [IsStartElement] ASC);


GO
PRINT N'Creating Table [ParserEnum].[CharType]...';


GO
CREATE TABLE [ParserEnum].[CharType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_CharType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[CharType].[UX_ParserEnum_CharType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_CharType_Name]
    ON [ParserEnum].[CharType]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TokenSubtype]...';


GO
CREATE TABLE [ParserEnum].[TokenSubtype] (
    [Id]     TINYINT      NOT NULL,
    [TypeId] TINYINT      NOT NULL,
    [Name]   VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TokenSubtype] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TokenSubtype].[UX_ParserEnum_TokenSubtype_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TokenSubtype_Name]
    ON [ParserEnum].[TokenSubtype]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TokenType]...';


GO
CREATE TABLE [ParserEnum].[TokenType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TokenType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TokenType].[UX_ParserEnum_TokenType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TokenType_Name]
    ON [ParserEnum].[TokenType]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlBlockType]...';


GO
CREATE TABLE [ParserEnum].[TSqlBlockType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlBlockType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlBlockType].[UX_ParserEnum_TSqlBlockType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TSqlBlockType_Name]
    ON [ParserEnum].[TSqlBlockType]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlKeyword]...';


GO
CREATE TABLE [ParserEnum].[TSqlKeyword] (
    [Id]   SMALLINT     NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlKeyword] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlKeyword].[UX_ParserEnum_TSqlKeyword_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TSqlKeyword_Name]
    ON [ParserEnum].[TSqlKeyword]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlSeqElementType]...';


GO
CREATE TABLE [ParserEnum].[TSqlSeqElementType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlSeqElementType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlSeqElementType].[UX_ParserEnum_TSqlSeqElementType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TSqlSeqElementType_Name]
    ON [ParserEnum].[TSqlSeqElementType]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlSequenceType]...';


GO
CREATE TABLE [ParserEnum].[TSqlSequenceType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlSequenceType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlSequenceType].[UX_ParserEnum_TSqlSequenceType_Name]...';


GO
CREATE NONCLUSTERED INDEX [UX_ParserEnum_TSqlSequenceType_Name]
    ON [ParserEnum].[TSqlSequenceType]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlStatementPart]...';


GO
CREATE TABLE [ParserEnum].[TSqlStatementPart] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlStatementPart] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlStatementPart].[UX_ParserEnum_TSqlStatementPart_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TSqlStatementPart_Name]
    ON [ParserEnum].[TSqlStatementPart]([Name] ASC);


GO
PRINT N'Creating Table [ParserEnum].[TSqlStatementType]...';


GO
CREATE TABLE [ParserEnum].[TSqlStatementType] (
    [Id]                          SMALLINT     NOT NULL,
    [Name]                        VARCHAR (50) NOT NULL,
    [StartKeywordId]              SMALLINT     NOT NULL,
    [AlwaysStartWithStartKeyword] BIT          NOT NULL,
    [IsSingleKeywordStatement]    BIT          NOT NULL,
    [CannotStopPreviousStatement] BIT          NOT NULL,
    CONSTRAINT [PK_ParserEnum_TSqlStatementType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [ParserEnum].[TSqlStatementType].[UX_ParserEnum_TSqlStatementType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ParserEnum_TSqlStatementType_Name]
    ON [ParserEnum].[TSqlStatementType]([Name] ASC);


GO
PRINT N'Creating Table [Static].[LanguageNameCasing]...';


GO
CREATE TABLE [Static].[LanguageNameCasing] (
    [Id]         SMALLINT IDENTITY (1, 1) NOT NULL,
    [LanguageId] TINYINT  NOT NULL,
    [NameTypeId] TINYINT  NOT NULL,
    [CasingId]   TINYINT  NOT NULL,
    CONSTRAINT [PK_LanguageNameCasing] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Static].[LanguageNameCasing].[UX_LanguageNameCasing_LanguageId_NameTypeId]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_LanguageNameCasing_LanguageId_NameTypeId]
    ON [Static].[LanguageNameCasing]([LanguageId] ASC, [NameTypeId] ASC);


GO
PRINT N'Creating Table [Static].[DataTypeMap]...';


GO
CREATE TABLE [Static].[DataTypeMap] (
    [Id]              SMALLINT       IDENTITY (1, 1) NOT NULL,
    [LanguageId]      TINYINT        NOT NULL,
    [SqlType]         NVARCHAR (128) NOT NULL,
    [NativeType]      VARCHAR (200)  NOT NULL,
    [SqlDbType]       VARCHAR (200)  NULL,
    [DbType]          VARCHAR (200)  NULL,
    [IsNullable]      BIT            NOT NULL,
    [SizeNeeded]      BIT            NOT NULL,
    [PrecisionNeeded] BIT            NOT NULL,
    [ScaleNeeded]     BIT            NOT NULL,
    CONSTRAINT [PK_DataTypeMap] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Static].[DataTypeMap].[UX_DataTypeMap_LanguageId_SqlType]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_DataTypeMap_LanguageId_SqlType]
    ON [Static].[DataTypeMap]([LanguageId] ASC, [SqlType] ASC);


GO
PRINT N'Creating Table [Static].[LanguageOption]...';


GO
CREATE TABLE [Static].[LanguageOption] (
    [Id]                         SMALLINT     IDENTITY (1, 1) NOT NULL,
    [LanguageId]                 TINYINT      NULL,
    [Name]                       VARCHAR (50) NOT NULL,
    [Value]                      BIGINT       NOT NULL,
    [IsPrimary]                  BIT          NOT NULL,
    [IsOverridablePerStoredProc] BIT          NOT NULL,
    CONSTRAINT [PK_LanguageOption] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Static].[LanguageOption].[UX_LanguageOption_LanguageId_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_LanguageOption_LanguageId_Name]
    ON [Static].[LanguageOption]([LanguageId] ASC, [Name] ASC);


GO
PRINT N'Creating Index [Static].[LanguageOption].[IX_LanguageOption_IsPrimary_Name]...';


GO
CREATE NONCLUSTERED INDEX [IX_LanguageOption_IsPrimary_Name]
    ON [Static].[LanguageOption]([IsPrimary] ASC, [Name] ASC)
    INCLUDE([LanguageId], [Value]);


GO
PRINT N'Creating Index [Static].[LanguageOption].[FU_LanguageOption_LanguageId_IsPrimary_Value]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [FU_LanguageOption_LanguageId_IsPrimary_Value]
    ON [Static].[LanguageOption]([LanguageId] ASC, [IsPrimary] ASC, [Value] ASC) WHERE ([IsPrimary]=(1));


GO
PRINT N'Creating Table [Static].[Template]...';


GO
CREATE TABLE [Static].[Template] (
    [Id]              SMALLINT        IDENTITY (1, 1) NOT NULL,
    [LanguageId]      TINYINT         NOT NULL,
    [TypeId]          TINYINT         NOT NULL,
    [LanguageOptions] BIGINT          NOT NULL,
    [Template]        NVARCHAR (4000) NOT NULL,
    CONSTRAINT [PK_Template] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Static].[Template].[UX_Template_LanguageId_TypeId_LanguageOptions]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Template_LanguageId_TypeId_LanguageOptions]
    ON [Static].[Template]([LanguageId] ASC, [TypeId] ASC, [LanguageOptions] ASC);


GO
PRINT N'Creating Table [Static].[Number]...';


GO
CREATE TABLE [Static].[Number] (
    [N] INT NOT NULL,
    CONSTRAINT [PK_Number] PRIMARY KEY CLUSTERED ([N] ASC)
);


GO
PRINT N'Creating Table [dbo].[ErrorLog]...';


GO
CREATE TABLE [dbo].[ErrorLog] (
    [Id]             INT             IDENTITY (1, 1) NOT NULL,
    [ErrorTime]      DATETIME2 (2)   NOT NULL,
    [UserName]       [sysname]       NOT NULL,
    [ErrorNumber]    INT             NOT NULL,
    [ErrorSeverity]  INT             NULL,
    [ErrorState]     INT             NULL,
    [ErrorProcedure] NVARCHAR (126)  NULL,
    [ErrorLine]      INT             NULL,
    [ErrorMessage]   NVARCHAR (4000) NOT NULL,
    CONSTRAINT [PK_ErrorLog_ErrorLogID] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Table [dbo].[Project]...';


GO
CREATE TABLE [dbo].[Project] (
    [Id]                 SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Name]               NVARCHAR (200) NOT NULL,
    [NamespaceName]      VARCHAR (100)  NOT NULL,
    [ClassName]          VARCHAR (100)  NOT NULL,
    [ClassAccessId]      TINYINT        NOT NULL,
    [LanguageId]         TINYINT        NOT NULL,
    [LanguageOptions]    BIGINT         NOT NULL,
    [ParamEnumMappingId] TINYINT        NOT NULL,
    [MapResultSetEnums]  BIT            NOT NULL,
    [DefaultDatabase]    NVARCHAR (128) NULL,
    CONSTRAINT [PK_Project] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[Project].[UX_Project_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Project_Name]
    ON [dbo].[Project]([Name] ASC);


GO
PRINT N'Creating Table [dbo].[ProjectEnum]...';


GO
CREATE TABLE [dbo].[ProjectEnum] (
    [Id]           INT            IDENTITY (1, 1) NOT NULL,
    [ProjectId]    SMALLINT       NOT NULL,
    [Schema]       NVARCHAR (128) NOT NULL,
    [NameMatchId]  TINYINT        NOT NULL,
    [NamePattern]  NVARCHAR (200) NULL,
    [EscChar]      NCHAR (1)      NULL,
    [IsSetOfFlags] BIT            NOT NULL,
    [NameColumn]   NVARCHAR (128) NULL,
    CONSTRAINT [PK_ProjectEnum] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[ProjectEnum].[UX_ProjectEnum_ProjectId_Schema_NameMatchId_NamePattern]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ProjectEnum_ProjectId_Schema_NameMatchId_NamePattern]
    ON [dbo].[ProjectEnum]([ProjectId] ASC, [Schema] ASC, [NameMatchId] ASC, [NamePattern] ASC);


GO
PRINT N'Creating Table [dbo].[ProjectNameNormalization]...';


GO
CREATE TABLE [dbo].[ProjectNameNormalization] (
    [Id]             INT            IDENTITY (1, 1) NOT NULL,
    [ProjectId]      SMALLINT       NOT NULL,
    [NamePart]       NVARCHAR (128) NOT NULL,
    [NamePartTypeId] TINYINT        NOT NULL,
    CONSTRAINT [PK_ProjectNameNormalization] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[ProjectNameNormalization].[UX_ProjectNameNormalization_ProjectId_NamePartTypeId_NamePart]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ProjectNameNormalization_ProjectId_NamePartTypeId_NamePart]
    ON [dbo].[ProjectNameNormalization]([ProjectId] ASC, [NamePartTypeId] ASC, [NamePart] ASC);


GO
PRINT N'Creating Table [dbo].[ProjectStoredProc]...';


GO
CREATE TABLE [dbo].[ProjectStoredProc] (
    [Id]                   INT            IDENTITY (1, 1) NOT NULL,
    [ProjectId]            SMALLINT       NOT NULL,
    [Schema]               NVARCHAR (128) NOT NULL,
    [NameMatchId]          TINYINT        NOT NULL,
    [NamePattern]          NVARCHAR (200) NULL,
    [EscChar]              NCHAR (1)      NULL,
    [LanguageOptionsReset] BIGINT         NULL,
    [LanguageOptionsSet]   BIGINT         NULL,
    CONSTRAINT [PK_ProjectStoredProc] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[ProjectStoredProc].[UX_ProjectStoredProc_ProjectId_Schema_NameMatchId_NamePattern]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_ProjectStoredProc_ProjectId_Schema_NameMatchId_NamePattern]
    ON [dbo].[ProjectStoredProc]([ProjectId] ASC, [Schema] ASC, [NameMatchId] ASC, [NamePattern] ASC);


GO
PRINT N'Creating Table [dbo].[SchemaVersion]...';


GO
CREATE TABLE [dbo].[SchemaVersion] (
    [Id]          SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Version]     VARCHAR (50)   NOT NULL,
    [Description] NVARCHAR (500) NOT NULL,
    [AppliedOn]   DATETIME2 (2)  NOT NULL,
    [AppliedBy]   NVARCHAR (128) NOT NULL,
    [ApiLevel]    SMALLINT       NOT NULL,
    [MinApiLevel] TINYINT        NOT NULL,
    CONSTRAINT [PK_SchemaVersion] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[SchemaVersion].[UQ_SchemaVersion_Version]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UQ_SchemaVersion_Version]
    ON [dbo].[SchemaVersion]([Version] ASC);


GO
PRINT N'Creating Default Constraint [Enum].[DF_Language_StatusId]...';


GO
ALTER TABLE [Enum].[Language]
    ADD CONSTRAINT [DF_Language_StatusId] DEFAULT ((1)) FOR [StatusId];


GO
PRINT N'Creating Default Constraint [Enum].[DF_ToolkitResponseCode_IsSuccess]...';


GO
ALTER TABLE [Enum].[ToolkitResponseCode]
    ADD CONSTRAINT [DF_ToolkitResponseCode_IsSuccess] DEFAULT ((0)) FOR [IsSuccess];


GO
PRINT N'Creating Default Constraint [Enum].[DF_NamePartType_IsPreffix]...';


GO
ALTER TABLE [Enum].[NamePartType]
    ADD CONSTRAINT [DF_NamePartType_IsPreffix] DEFAULT ((0)) FOR [IsPrefix];


GO
PRINT N'Creating Default Constraint [Enum].[DF_NamePartType_IsSuffix]...';


GO
ALTER TABLE [Enum].[NamePartType]
    ADD CONSTRAINT [DF_NamePartType_IsSuffix] DEFAULT ((0)) FOR [IsSuffix];


GO
PRINT N'Creating Default Constraint [Parser].[DF_Operator_Unary]...';


GO
ALTER TABLE [Parser].[Operator]
    ADD CONSTRAINT [DF_Operator_Unary] DEFAULT ((0)) FOR [Unary];


GO
PRINT N'Creating Default Constraint [Parser].[DF_Operator_Binary]...';


GO
ALTER TABLE [Parser].[Operator]
    ADD CONSTRAINT [DF_Operator_Binary] DEFAULT ((0)) FOR [Binary];


GO
PRINT N'Creating Default Constraint [Parser].[DF_Parser_TSqlSequence_SequenceTypeId]...';


GO
ALTER TABLE [Parser].[TSqlSequence]
    ADD CONSTRAINT [DF_Parser_TSqlSequence_SequenceTypeId] DEFAULT ((1)) FOR [SequenceTypeId];


GO
PRINT N'Creating Default Constraint [Parser].[DF_Parser_TSqlSequence_Priority]...';


GO
ALTER TABLE [Parser].[TSqlSequence]
    ADD CONSTRAINT [DF_Parser_TSqlSequence_Priority] DEFAULT ((1)) FOR [Precedence];


GO
PRINT N'Creating Default Constraint [Parser].[DF_Parser_TSqlSeqElement_IsStartElement]...';


GO
ALTER TABLE [Parser].[TSqlSeqElement]
    ADD CONSTRAINT [DF_Parser_TSqlSeqElement_IsStartElement] DEFAULT ((0)) FOR [IsStartElement];


GO
PRINT N'Creating Default Constraint [ParserEnum].[DF_ParserEnum_TSqlStatementType_AlwaysStartWithStartKeyword]...';


GO
ALTER TABLE [ParserEnum].[TSqlStatementType]
    ADD CONSTRAINT [DF_ParserEnum_TSqlStatementType_AlwaysStartWithStartKeyword] DEFAULT ((0)) FOR [AlwaysStartWithStartKeyword];


GO
PRINT N'Creating Default Constraint [ParserEnum].[DF_ParserEnum_TSqlStatementType_IsSingleKeywordStatement]...';


GO
ALTER TABLE [ParserEnum].[TSqlStatementType]
    ADD CONSTRAINT [DF_ParserEnum_TSqlStatementType_IsSingleKeywordStatement] DEFAULT ((0)) FOR [IsSingleKeywordStatement];


GO
PRINT N'Creating Default Constraint [ParserEnum].[DF_ParserEnum_TSqlStatementType_CannotStopPreviousStatement]...';


GO
ALTER TABLE [ParserEnum].[TSqlStatementType]
    ADD CONSTRAINT [DF_ParserEnum_TSqlStatementType_CannotStopPreviousStatement] DEFAULT ((0)) FOR [CannotStopPreviousStatement];


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_IsNullable]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_IsNullable] DEFAULT ((1)) FOR [IsNullable];


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_SizeNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_SizeNeeded] DEFAULT ((0)) FOR [SizeNeeded];


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_PrecisionNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_PrecisionNeeded] DEFAULT ((0)) FOR [PrecisionNeeded];


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_ScaleNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_ScaleNeeded] DEFAULT ((0)) FOR [ScaleNeeded];


GO
PRINT N'Creating Default Constraint [Static].[DF_LanguageOption_IsPrimary]...';


GO
ALTER TABLE [Static].[LanguageOption]
    ADD CONSTRAINT [DF_LanguageOption_IsPrimary] DEFAULT ((1)) FOR [IsPrimary];


GO
PRINT N'Creating Default Constraint [Static].[DF_LanguageOption_IsOverridablePerStoredProc]...';


GO
ALTER TABLE [Static].[LanguageOption]
    ADD CONSTRAINT [DF_LanguageOption_IsOverridablePerStoredProc] DEFAULT ((1)) FOR [IsOverridablePerStoredProc];


GO
PRINT N'Creating Default Constraint [Static].[DF_Template_LanguageOptions]...';


GO
ALTER TABLE [Static].[Template]
    ADD CONSTRAINT [DF_Template_LanguageOptions] DEFAULT ((0)) FOR [LanguageOptions];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ErrorLog_ErrorTime]...';


GO
ALTER TABLE [dbo].[ErrorLog]
    ADD CONSTRAINT [DF_ErrorLog_ErrorTime] DEFAULT (sysutcdatetime()) FOR [ErrorTime];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_LanguageOptions]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_LanguageOptions] DEFAULT ((0)) FOR [LanguageOptions];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_ParamEnumMapping]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_ParamEnumMapping] DEFAULT ((1)) FOR [ParamEnumMappingId];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_MapResultSetEnums]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_MapResultSetEnums] DEFAULT ((0)) FOR [MapResultSetEnums];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ProjectEnum_IsSetOfFlags]...';


GO
ALTER TABLE [dbo].[ProjectEnum]
    ADD CONSTRAINT [DF_ProjectEnum_IsSetOfFlags] DEFAULT ((0)) FOR [IsSetOfFlags];


GO
PRINT N'Creating Default Constraint [dbo].[DF_SchemaVersion_AppliedOn]...';


GO
ALTER TABLE [dbo].[SchemaVersion]
    ADD CONSTRAINT [DF_SchemaVersion_AppliedOn] DEFAULT (sysutcdatetime()) FOR [AppliedOn];


GO
PRINT N'Creating Default Constraint [dbo].[DF_SchemaVersion_AppliedBy]...';


GO
ALTER TABLE [dbo].[SchemaVersion]
    ADD CONSTRAINT [DF_SchemaVersion_AppliedBy] DEFAULT (original_login()) FOR [AppliedBy];


GO
PRINT N'Creating Default Constraint [dbo].[DF_SchemaVersion_ApiLevel]...';


GO
ALTER TABLE [dbo].[SchemaVersion]
    ADD CONSTRAINT [DF_SchemaVersion_ApiLevel] DEFAULT ((0)) FOR [ApiLevel];


GO
PRINT N'Creating Default Constraint [dbo].[DF_SchemaVersion_MinApiLevel]...';


GO
ALTER TABLE [dbo].[SchemaVersion]
    ADD CONSTRAINT [DF_SchemaVersion_MinApiLevel] DEFAULT ((1)) FOR [MinApiLevel];


GO
PRINT N'Creating Sequence [Parser].[TSqlSeqEl]...';


GO
CREATE SEQUENCE [Parser].[TSqlSeqEl]
    AS INT
    START WITH 1
    INCREMENT BY 1
    NO CACHE;


GO
PRINT N'Creating Foreign Key [Enum].[FK_Language_Status]...';


GO
ALTER TABLE [Enum].[Language] WITH NOCHECK
    ADD CONSTRAINT [FK_Language_Status] FOREIGN KEY ([StatusId]) REFERENCES [Enum].[Status] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSequence_TSqlSequenceType]...';


GO
ALTER TABLE [Parser].[TSqlSequence] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSequence_TSqlSequenceType] FOREIGN KEY ([SequenceTypeId]) REFERENCES [ParserEnum].[TSqlSequenceType] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSequence_TsqlStatementType]...';


GO
ALTER TABLE [Parser].[TSqlSequence] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSequence_TsqlStatementType] FOREIGN KEY ([StatementTypeId]) REFERENCES [ParserEnum].[TSqlStatementType] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_CharTypeMap_CharType]...';


GO
ALTER TABLE [Parser].[CharTypeMap] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_CharTypeMap_CharType] FOREIGN KEY ([TypeId]) REFERENCES [ParserEnum].[CharType] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSeqElement_Operator]...';


GO
ALTER TABLE [Parser].[TSqlSeqElement] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSeqElement_Operator] FOREIGN KEY ([OperatorId]) REFERENCES [Parser].[Operator] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSeqElement_TSqlKeyword]...';


GO
ALTER TABLE [Parser].[TSqlSeqElement] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlKeyword] FOREIGN KEY ([KeywordId]) REFERENCES [ParserEnum].[TSqlKeyword] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSeqElement_TSqlSeqElementType]...';


GO
ALTER TABLE [Parser].[TSqlSeqElement] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlSeqElementType] FOREIGN KEY ([TypeId]) REFERENCES [ParserEnum].[TSqlSeqElementType] ([Id]);


GO
PRINT N'Creating Foreign Key [Parser].[FK_Parser_TSqlSeqElement_TSqlSequence]...';


GO
ALTER TABLE [Parser].[TSqlSeqElement] WITH NOCHECK
    ADD CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlSequence] FOREIGN KEY ([SequenceId]) REFERENCES [Parser].[TSqlSequence] ([Id]);


GO
PRINT N'Creating Foreign Key [ParserEnum].[FK_ParserEnum_TokenSubtype_TokenType]...';


GO
ALTER TABLE [ParserEnum].[TokenSubtype] WITH NOCHECK
    ADD CONSTRAINT [FK_ParserEnum_TokenSubtype_TokenType] FOREIGN KEY ([TypeId]) REFERENCES [ParserEnum].[TokenType] ([Id]);


GO
PRINT N'Creating Foreign Key [ParserEnum].[FK_ParserEnum_TSqlStatementType_TSqlKeyword]...';


GO
ALTER TABLE [ParserEnum].[TSqlStatementType] WITH NOCHECK
    ADD CONSTRAINT [FK_ParserEnum_TSqlStatementType_TSqlKeyword] FOREIGN KEY ([StartKeywordId]) REFERENCES [ParserEnum].[TSqlKeyword] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_Casing]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_Casing] FOREIGN KEY ([CasingId]) REFERENCES [Enum].[Casing] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_Language]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_NameType]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_NameType] FOREIGN KEY ([NameTypeId]) REFERENCES [Enum].[NameType] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_DataTypeMap_Language]...';


GO
ALTER TABLE [Static].[DataTypeMap] WITH NOCHECK
    ADD CONSTRAINT [FK_DataTypeMap_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageOption_Language]...';


GO
ALTER TABLE [Static].[LanguageOption] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageOption_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_Template_Language]...';


GO
ALTER TABLE [Static].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [Static].[FK_Template_TemplateType]...';


GO
ALTER TABLE [Static].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_TemplateType] FOREIGN KEY ([TypeId]) REFERENCES [Enum].[TemplateType] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Project_ClassAccess]...';


GO
ALTER TABLE [dbo].[Project] WITH NOCHECK
    ADD CONSTRAINT [FK_Project_ClassAccess] FOREIGN KEY ([ClassAccessId]) REFERENCES [Enum].[ClassAccess] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Project_Language]...';


GO
ALTER TABLE [dbo].[Project] WITH NOCHECK
    ADD CONSTRAINT [FK_Project_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Project_ParamEnumMapping]...';


GO
ALTER TABLE [dbo].[Project] WITH NOCHECK
    ADD CONSTRAINT [FK_Project_ParamEnumMapping] FOREIGN KEY ([ParamEnumMappingId]) REFERENCES [Enum].[ParamEnumMapping] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectEnum_NameMatch]...';


GO
ALTER TABLE [dbo].[ProjectEnum] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectEnum_NameMatch] FOREIGN KEY ([NameMatchId]) REFERENCES [Enum].[NameMatch] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectEnum_Project]...';


GO
ALTER TABLE [dbo].[ProjectEnum] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectEnum_Project] FOREIGN KEY ([ProjectId]) REFERENCES [dbo].[Project] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectNameNormalization_NamePartType]...';


GO
ALTER TABLE [dbo].[ProjectNameNormalization] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectNameNormalization_NamePartType] FOREIGN KEY ([NamePartTypeId]) REFERENCES [Enum].[NamePartType] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectNameNormalization_Project]...';


GO
ALTER TABLE [dbo].[ProjectNameNormalization] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectNameNormalization_Project] FOREIGN KEY ([ProjectId]) REFERENCES [dbo].[Project] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectStoredProc_NameMatch]...';


GO
ALTER TABLE [dbo].[ProjectStoredProc] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectStoredProc_NameMatch] FOREIGN KEY ([NameMatchId]) REFERENCES [Enum].[NameMatch] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_ProjectStoredProc_Project]...';


GO
ALTER TABLE [dbo].[ProjectStoredProc] WITH NOCHECK
    ADD CONSTRAINT [FK_ProjectStoredProc_Project] FOREIGN KEY ([ProjectId]) REFERENCES [dbo].[Project] ([Id]);


GO
PRINT N'Creating Function [DbInfo].[GetCurrentVersion]...';


GO

CREATE FUNCTION [DbInfo].[GetCurrentVersion]
(	
)
RETURNS VARCHAR(50)
AS
BEGIN
	DECLARE @ver VARCHAR(50);

	SELECT TOP(1) @ver=[Version] FROM [dbo].[SchemaVersion] ORDER BY [Id] DESC;

	RETURN @ver;
END
GO
PRINT N'Creating Function [DbInfo].[GetName]...';


GO



CREATE FUNCTION [DbInfo].[GetName]
(	
)
RETURNS VARCHAR(50)
AS
BEGIN
	DECLARE @name VARCHAR(50) = 'TigerWrapDb';	

	RETURN @name;
END
GO
PRINT N'Creating Function [Internal].[RemoveFromStart]...';


GO

CREATE FUNCTION [Internal].[RemoveFromStart]
(		
	@text NVARCHAR(500),
	@start NVARCHAR(128)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = @text;
	
	DECLARE @tl INT = LEN(@text);
	DECLARE @sl INT = LEN(@start);

	IF (@sl > 0 AND @tl >= @sl AND LEFT(@text, @sl)=@start)
	BEGIN
		SET @result = RIGHT(@text, @tl - @sl);
	END
	

	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[RemoveFromEnd]...';


GO

CREATE FUNCTION [Internal].[RemoveFromEnd]
(		
	@text NVARCHAR(500),
	@end NVARCHAR(128)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = @text;
	
	DECLARE @tl INT = LEN(@text);
	DECLARE @el INT = LEN(@end);

	IF (@el > 0 AND @tl >= @el AND RIGHT(@text, @el)=@end)
	BEGIN
		SET @result = LEFT(@text, @tl - @el);
	END
	

	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[EscapeString]...';


GO

CREATE FUNCTION [Internal].[EscapeString]
(	
	@languageId TINYINT,	
	@value NVARCHAR(2000)
)
RETURNS NVARCHAR(2000)
AS
BEGIN
	-- only c# is currently supported, so @languageId is not required, but in the future this function would need to escape the string in a proper way for different languages
	DECLARE @result NVARCHAR(2000) = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@value, '\', '\\'), '"', '\"'), CHAR(9), '\t'), CHAR(13), '\r'), CHAR(10), '\n');

	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[IsNameMatch]...';


GO

CREATE FUNCTION [Internal].[IsNameMatch]
(
	@name NVARCHAR(128),
    @matchType TINYINT,
    @pattern NVARCHAR(200),
    @escChar NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	
	DECLARE @result BIT = 0;

    DECLARE @NM_EXACT_MATCH TINYINT = 1;
    DECLARE @NM_PREFIX TINYINT = 2;
    DECLARE @NM_SUFFIX TINYINT = 3;
    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;

    DECLARE @patternLen INT = LEN(@pattern);

    IF @matchType=@NM_EXACT_MATCH AND NULLIF(LTRIM(@pattern), N'') IS NOT NULL
    BEGIN
        SET @result = CASE WHEN @name=@pattern THEN 1 ELSE 0 END;
    END
    ELSE IF @matchType=@NM_PREFIX AND NULLIF(LTRIM(@pattern), N'') IS NOT NULL
    BEGIN
        SET @result = CASE WHEN LEFT(@name, @patternLen)=@pattern THEN 1 ELSE 0 END;
    END
    ELSE IF @matchType=@NM_SUFFIX AND NULLIF(LTRIM(@pattern), N'') IS NOT NULL
    BEGIN
        SET @result = CASE WHEN RIGHT(@name, @patternLen)=@pattern THEN 1 ELSE 0 END;
    END
    ELSE IF @matchType=@NM_LIKE AND NULLIF(LTRIM(@pattern), N'') IS NOT NULL
    BEGIN
        IF @escChar IS NOT NULL
        BEGIN
            SET @result = CASE WHEN @name LIKE @pattern ESCAPE @escChar THEN 1 ELSE 0 END;
        END
        ELSE
        BEGIN
            SET @result = CASE WHEN @name LIKE @pattern THEN 1 ELSE 0 END;
        END
    END
    ELSE IF @matchType=@NM_ANY
    BEGIN
        SET @result = 1;
    END
	
	RETURN @result;

END
GO
PRINT N'Creating Function [Internal].[GetTemplate]...';


GO
CREATE FUNCTION [Internal].[GetTemplate]
(
	@languageId TINYINT,
	@languageOptions BIGINT,
	@typeId TINYINT
)
RETURNS SMALLINT
AS
BEGIN
	DECLARE @result SMALLINT;

	SELECT TOP(1) @result=t.[Id]
	FROM [Static].[Template] t
	WHERE t.[LanguageId]=@languageId AND t.TypeId=@typeId AND ((t.[LanguageOptions] & @languageOptions) = t.[LanguageOptions])
	ORDER BY t.[LanguageOptions] DESC;
		
	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[GetLanguageOptionsString]...';


GO


CREATE FUNCTION [Internal].[GetLanguageOptionsString]
(
	@languageId TINYINT,
	@options BIGINT
)
RETURNS VARCHAR(1000)
AS
BEGIN
	DECLARE @result VARCHAR(1000) = NULL;

    SELECT @result=STRING_AGG(lo.[Name], ',') WITHIN GROUP (ORDER BY lo.[Value])
    FROM [Static].[LanguageOption] lo
    WHERE lo.[IsPrimary]=1 AND ((lo.[Value] & @options)=lo.[Value]);
    
    RETURN @result;
END
GO
PRINT N'Creating Function [Parser].[FindEndDelimiter]...';


GO

CREATE FUNCTION [Parser].[FindEndDelimiter]
(
	@text NVARCHAR(MAX),
    @startPos INT,
    @delimiter NCHAR(1),
    @escaped NCHAR(2)
)
RETURNS INT
AS
BEGIN
	DECLARE @dPos INT = CHARINDEX(@delimiter, @text, @startPos);
    DECLARE @escPos INT = CHARINDEX(@escaped, @text, @startPos);
    WHILE @dPos > 0 AND @escPos > 0 AND @dPos = @escPos
    BEGIN
        SET @startPos = @escPos + 2;
        SET @dPos = CHARINDEX(@delimiter, @text, @startPos);
        SET @escPos = CHARINDEX(@escaped, @text, @startPos);
    END
    
	RETURN @dPos;
END
GO
PRINT N'Creating Function [Parser].[GetFullText]...';


GO
CREATE FUNCTION [Parser].[GetFullText]
(
	@text NVARCHAR(MAX), 
    @subtype TINYINT
)
RETURNS NVARCHAR(MAX)
AS
BEGIN
	DECLARE @result NVARCHAR(MAX) = '';

	DECLARE @ST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @ST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @ST_STRING TINYINT = 6;
    DECLARE @ST_UNICODE_STRING TINYINT = 7;

    IF @subtype IN (@ST_IDENTIFIER_IN_BRACKETS, @ST_IDENTIFIER_IN_DOUBLE_QUOTES, @ST_STRING, @ST_UNICODE_STRING)
    BEGIN
        IF @subtype=@ST_UNICODE_STRING
        BEGIN
            SET @result=N'N'
        END
        DECLARE @end NCHAR(1);
        DECLARE @esc NCHAR(2);
        IF @subtype = @ST_IDENTIFIER_IN_BRACKETS
        BEGIN
            SET @result += N'['
            SET @end = N']';
        END
        ELSE IF @subtype = @ST_IDENTIFIER_IN_DOUBLE_QUOTES
        BEGIN
            SET @result += N'"'
            SET @end = N'"';
        END
        ELSE
        BEGIN
            SET @result += N''''
            SET @end = N'''';
        END
        SET @esc=@end + @end;
        SET @result += REPLACE(@text, @end, @esc) + @end;
    END
    ELSE
    BEGIN
        SET @result = @text;
    END

	RETURN @result
END
GO
PRINT N'Creating Function [Parser].[GetSequenceLength]...';


GO


CREATE FUNCTION [Parser].[GetSequenceLength]
(
	@text NVARCHAR(MAX),
    @startPos INT,
    @len INT,
    @charType1 TINYINT,
    @charType2 TINYINT = NULL,
    @charType3 TINYINT = NULL,
    @charType4 TINYINT = NULL
)
RETURNS INT
AS
BEGIN
	DECLARE @seqLen INT = 0
    IF @startPos <= @len
    BEGIN
        DECLARE @c NCHAR(1) = SUBSTRING(@text, @startPos, 1);
        DECLARE @ct TINYINT = (SELECT m.[TypeId] FROM [Parser].[CharTypeMap] m WHERE [Char]=@c);
        WHILE @ct IS NOT NULL AND @ct IN (@charType1, ISNULL(@charType2, 255), ISNULL(@charType3, 255), ISNULL(@charType4, 255))
        BEGIN
            SET @seqLen += 1;
            SET @ct = NULL;
            SET @startPos += 1;
            IF @startPos <= @len
            BEGIN
                SET @c = SUBSTRING(@text, @startPos, 1);
                SET @ct = (SELECT m.[TypeId] FROM [Parser].[CharTypeMap] m WHERE [Char]=@c);
            END            
        END
    END
    
	RETURN @seqLen;
END
GO
PRINT N'Creating Function [Parser].[IsDelimiter]...';


GO
CREATE FUNCTION [Parser].[IsDelimiter]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;
    SELECT @result = CASE WHEN @c LIKE '[''"()[^]]' ESCAPE '^' THEN 1 ELSE 0 END
    RETURN @result;
END
GO
PRINT N'Creating Function [Parser].[IsDigit]...';


GO
CREATE FUNCTION [Parser].[IsDigit]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;

	
	SELECT @result = CASE WHEN @c LIKE '[0-9]' THEN 1 ELSE 0 END

	
	RETURN @result;

END
GO
PRINT N'Creating Function [Parser].[IsLetter]...';


GO
CREATE FUNCTION [Parser].[IsLetter]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;

	
	SELECT @result = CASE WHEN @c LIKE '[A-Za-z]' THEN 1 ELSE 0 END

	
	RETURN @result;

END
GO
PRINT N'Creating Function [Parser].[IsOperator]...';


GO
CREATE FUNCTION [Parser].[IsOperator]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;

	SELECT @result = CASE WHEN @c LIKE '[!%&*/:|~+<=>^-]' THEN 1 ELSE 0 END
    RETURN @result;
END
GO
PRINT N'Creating Function [Parser].[IsSeparator]...';


GO
CREATE FUNCTION [Parser].[IsSeparator]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;
    SELECT @result = CASE WHEN @c LIKE '[.,;]' THEN 1 ELSE 0 END
    RETURN @result;
END
GO
PRINT N'Creating Function [Parser].[IsSpecial]...';


GO

CREATE FUNCTION [Parser].[IsSpecial]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;
    SELECT @result = CASE WHEN @c LIKE '[#@_$]' THEN 1 ELSE 0 END
    RETURN @result;
END
GO
PRINT N'Creating Function [Parser].[IsWhitespace]...';


GO

CREATE FUNCTION [Parser].[IsWhitespace]
(
	@c NCHAR(1)
)
RETURNS BIT
AS
BEGIN
	DECLARE @result BIT;

	SELECT @result = CASE WHEN @c IN (' ', CHAR(9), CHAR(10), CHAR(13)) THEN 1 ELSE 0 END

	RETURN @result;

END
GO
PRINT N'Creating View [View].[Project]...';


GO



CREATE VIEW [View].[Project]
AS
SELECT p.[Id], p.[Name], p.[NamespaceName], p.[ClassName], p.[ClassAccessId], ca.[Name] [ClassAccess], p.[LanguageId], l.[Name] AS [Language], 
    p.[LanguageOptions], [Internal].[GetLanguageOptionsString](p.[LanguageId], p.[LanguageOptions]) [LanguageOptionList], p.[ParamEnumMappingId], 
    m.[Name] [ParamEnumMapping], p.[MapResultSetEnums], p.[DefaultDatabase]
FROM [dbo].[Project] p
INNER JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId] = ca.[Id]
INNER JOIN [Enum].[Language] l ON p.[LanguageId] = l.Id 
INNER JOIN [Enum].[ParamEnumMapping] m ON p.[ParamEnumMappingId] = m.[Id];
GO
PRINT N'Creating Function [Parser].[GetCharType]...';


GO

CREATE FUNCTION [Parser].[GetCharType]
(
	@c NCHAR(1)
)
RETURNS TINYINT
AS
BEGIN
	DECLARE @result TINYINT;

    DECLARE @CT_UNKNOWN TINYINT = 0;
    DECLARE @CT_LETTER TINYINT = 1;
    DECLARE @CT_UNICODE_LETTER TINYINT = 2;
    DECLARE @CT_DIGIT TINYINT = 3;
    DECLARE @CT_UNICODE_DIGIT TINYINT = 4;
    DECLARE @CT_OPERATOR TINYINT = 5;
    DECLARE @CT_SEPARATOR TINYINT = 6;
    DECLARE @CT_DELIMITER TINYINT = 7;
    DECLARE @CT_SPECIAL TINYINT = 8;
    DECLARE @CT_WHITESPACE TINYINT = 9;

    IF [Parser].[IsLetter](@c)=1 
    BEGIN
        SET @result = @CT_LETTER;
    END
    ELSE IF [Parser].[IsDigit](@c)=1
    BEGIN
        SET @result = @CT_DIGIT;
    END
    ELSE IF [Parser].[IsWhitespace](@c)=1
    BEGIN
        SET @result = @CT_WHITESPACE;
    END
    ELSE IF [Parser].[IsOperator](@c)=1
    BEGIN
        SET @result = @CT_OPERATOR;
    END
    ELSE IF [Parser].[IsSeparator](@c)=1
    BEGIN
        SET @result = @CT_SEPARATOR;
    END
    ELSE IF [Parser].[IsDelimiter](@c)=1
    BEGIN
        SET @result = @CT_DELIMITER;
    END
    ELSE IF [Parser].[IsSpecial](@c)=1
    BEGIN
        SET @result = @CT_SPECIAL;
    END
    ELSE
    BEGIN
        SET @result = @CT_UNKNOWN;
    END
    
    RETURN @result;
END
GO
PRINT N'Creating Function [dbo].[DelimitedSplitN4K]...';


GO
 CREATE FUNCTION [dbo].[DelimitedSplitN4K]
/**********************************************************************************************************************
 Purpose:
 Split a given string at a given delimiter and return a list of the split elements (items).

 Notes:
 1.  Leading a trailing delimiters are treated as if an empty string element were present.
 2.  Consecutive delimiters are treated as if an empty string element were present between them.
 3.  Except when spaces are used as a delimiter, all spaces present in each element are preserved.

 Returns:
 iTVF containing the following:
 ItemNumber = Element position of Item as a BIGINT (not converted to INT to eliminate a CAST)
 Item       = Element value as a NVARCHAR(4000)

 CROSS APPLY Usage Examples and Tests:
--=====================================================================================================================
-- TEST 1:
-- This tests for various possible conditions in a string using a comma as the delimiter.  The expected results are
-- laid out in the comments
--=====================================================================================================================
--===== Conditionally drop the test tables to make reruns easier for testing.
     -- (this is NOT a part of the solution)
     IF OBJECT_ID('tempdb..#JBMTest') IS NOT NULL DROP TABLE #JBMTest
;
--===== Create and populate a test table on the fly (this is NOT a part of the solution).
     -- In the following comments, "b" is a blank and "E" is an element in the left to right order.
     -- Double Quotes are used to encapsulate the output of "Item" so that you can see that all blanks
     -- are preserved no matter where they may appear.
 SELECT *
   INTO #JBMTest
   FROM (                                               --# & type of Return Row(s)
         SELECT  0, NULL                       UNION ALL --1 NULL
         SELECT  1, SPACE(0)                   UNION ALL --1 b (Empty String)
         SELECT  2, SPACE(1)                   UNION ALL --1 b (1 space)
         SELECT  3, SPACE(5)                   UNION ALL --1 b (5 spaces)
         SELECT  4, N','                       UNION ALL --2 b b (both are empty strings)
         SELECT  5, N'55555'                   UNION ALL --1 E
         SELECT  6, N',55555'                  UNION ALL --2 b E
         SELECT  7, N',55555,'                 UNION ALL --3 b E b
         SELECT  8, N'55555,'                  UNION ALL --2 b B
         SELECT  9, N'55555,1'                 UNION ALL --2 E E
         SELECT 10, N'1,55555'                 UNION ALL --2 E E
         SELECT 11, N'55555,4444,333,22,1'     UNION ALL --5 E E E E E 
         SELECT 12, N'55555,4444,,333,22,1'    UNION ALL --6 E E b E E E
         SELECT 13, N',55555,4444,,333,22,1,'  UNION ALL --8 b E E b E E E b
         SELECT 14, N',55555,4444,,,333,22,1,' UNION ALL --9 b E E b b E E E b
         SELECT 15, N' 4444,55555 '            UNION ALL --2 E (w/Leading Space) E (w/Trailing Space)
         SELECT 16, N'This,is,a,test.'                   --E E E E
        ) d (SomeID, SomeValue)
;
--===== Split the CSV column for the whole table using CROSS APPLY (this is the solution)
 SELECT test.SomeID, test.SomeValue, split.ItemNumber, Item = QUOTENAME(split.Item,'"')
   FROM #JBMTest test
  CROSS APPLY dbo.DelimitedSplitN4K(test.SomeValue,',') split
;
--=====================================================================================================================
-- TEST 2:
-- This tests for various "alpha" splits and COLLATION using all ASCII characters from 0 to 255 as a delimiter against
-- a given string.  Note that not all of the delimiters will be visible and some will show up as tiny squares because
-- they are "control" characters.  More specifically, this test will show you what happens to various non-accented 
-- letters for your given collation depending on the delimiter you chose.
--=====================================================================================================================
WITH 
cteBuildAllCharacters (String,Delimiter) AS 
(
 SELECT TOP 256 
        N'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
        NCHAR(ROW_NUMBER() OVER (ORDER BY (SELECT NULL))-1)
   FROM master.sys.all_columns
)
 SELECT ASCII_Value = ASCII(c.Delimiter), c.Delimiter, split.ItemNumber, Item = QUOTENAME(split.Item,'"')
   FROM cteBuildAllCharacters c
  CROSS APPLY dbo.DelimitedSplitN4K(c.String,c.Delimiter) split
  ORDER BY ASCII_Value, split.ItemNumber
;
-----------------------------------------------------------------------------------------------------------------------
 Other Notes:
 1. Optimized for NVARCHAR(4000) or less.  No testing or error reporting for truncation at 8000 characters is done.
 2. Optimized for single character delimiter.  Multi-character delimiters should be resolvedexternally from this 
    function.
 3. Optimized for use with CROSS APPLY.
 4. Does not "trim" elements just in case leading or trailing blanks are intended.
 5. If you don't know how a Tally table can be used to replace loops, please see the following...
    http://www.sqlservercentral.com/articles/T-SQL/62867/
 6. Changing this function to use NVARCHAR(MAX) will cause it to run twice as slow.  It's just the nature of 
    VARCHAR(MAX) whether it fits in-row or not.
 7. Multi-machine testing for the method of using UNPIVOT instead of 10 SELECT/UNION ALLs shows that the UNPIVOT method
    is quite machine dependent and can slow things down quite a bit.
-----------------------------------------------------------------------------------------------------------------------
 Credits:
 This code is the product of many people's efforts including but not limited to the following:
 cteTally concept originally by Iztek Ben Gan and "decimalized" by Lynn Pettis (and others) for a bit of extra speed
 and finally redacted by Jeff Moden for a different slant on readability and compactness. Hat's off to Paul White for
 his simple explanations of CROSS APPLY and for his detailed testing efforts. Last but not least, thanks to
 Ron "BitBucket" McCullough and Wayne Sheffield for their extreme performance testing across multiple machines and
 versions of SQL Server.  The latest improvement brought an additional 15-20% improvement over Rev 05.  Special thanks
 to "Nadrek" and "peter-757102" (aka Peter de Heer) for bringing such improvements to light.  Nadrek's original
 improvement brought about a 10% performance gain and Peter followed that up with the content of Rev 07.  

 I also thank whoever wrote the first article I ever saw on "numbers tables" which is located at the following URL
 and to Adam Machanic for leading me to it many years ago.
 http://sqlserver2000.databases.aspfaq.com/why-should-i-consider-using-an-auxiliary-numbers-table.html
-----------------------------------------------------------------------------------------------------------------------
 Revision History:
 Rev 00 - 20 Jan 2010 - Concept for inline cteTally: Lynn Pettis and others.
                        Redaction/Implementation: Jeff Moden 
        - Base 10 redaction and reduction for CTE.  (Total rewrite)

 Rev 01 - 13 Mar 2010 - Jeff Moden
        - Removed one additional concatenation and one subtraction from the SUBSTRING in the SELECT List for that tiny
          bit of extra speed.

 Rev 02 - 14 Apr 2010 - Jeff Moden
        - No code changes.  Added CROSS APPLY usage example to the header, some additional credits, and extra 
          documentation.

 Rev 03 - 18 Apr 2010 - Jeff Moden
        - No code changes.  Added notes 7, 8, and 9 about certain "optimizations" that don't actually work for this
          type of function.

 Rev 04 - 29 Jun 2010 - Jeff Moden
        - Added WITH SCHEMABINDING thanks to a note by Paul White.  This prevents an unnecessary "Table Spool" when the
          function is used in an UPDATE statement even though the function makes no external references.

 Rev 05 - 02 Apr 2011 - Jeff Moden
        - Rewritten for extreme performance improvement especially for larger strings approaching the 8K boundary and
          for strings that have wider elements.  The redaction of this code involved removing ALL concatenation of 
          delimiters, optimization of the maximum "N" value by using TOP instead of including it in the WHERE clause,
          and the reduction of all previous calculations (thanks to the switch to a "zero based" cteTally) to just one 
          instance of one add and one instance of a subtract. The length calculation for the final element (not 
          followed by a delimiter) in the string to be split has been greatly simplified by using the ISNULL/NULLIF 
          combination to determine when the CHARINDEX returned a 0 which indicates there are no more delimiters to be
          had or to start with. Depending on the width of the elements, this code is between 4 and 8 times faster on a
          single CPU box than the original code especially near the 8K boundary.
        - Modified comments to include more sanity checks on the usage example, etc.
        - Removed "other" notes 8 and 9 as they were no longer applicable.

 Rev 06 - 12 Apr 2011 - Jeff Moden
        - Based on a suggestion by Ron "Bitbucket" McCullough, additional test rows were added to the sample code and
          the code was changed to encapsulate the output in pipes so that spaces and empty strings could be perceived 
          in the output.  The first "Notes" section was added.  Finally, an extra test was added to the comments above.

 Rev 07 - 06 May 2011 - Peter de Heer, a further 15-20% performance enhancement has been discovered and incorporated 
          into this code which also eliminated the need for a "zero" position in the cteTally table. 
**********************************************************************************************************************/
--===== Define I/O parameters
        (@pString NVARCHAR(4000), @pDelimiter NCHAR(1))
RETURNS TABLE WITH SCHEMABINDING AS
 RETURN
--===== "Inline" CTE Driven "Tally Table" produces values from 0 up to 10,000...
     -- enough to cover NVARCHAR(4000)
  WITH E1(N) AS (
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1
                ),                          --10E+1 or 10 rows
       E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows
       E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max
 cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front
                     -- for both a performance gain and prevention of accidental "overruns"
                 SELECT TOP (ISNULL(DATALENGTH(@pString)/2,0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4
                ),
cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter)
                 SELECT 1 UNION ALL 
                 SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter
                ),
cteLen(N1,L1) AS(--==== Return start and length (for use in substring)
                 SELECT s.N1,
                        ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,4000)
                   FROM cteStart s
                )
--===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.
 SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1),
        Item       = SUBSTRING(@pString, l.N1, l.L1)
   FROM cteLen l
;
GO
PRINT N'Creating Function [Internal].[GetLanguageOptions]...';


GO

CREATE FUNCTION [Internal].[GetLanguageOptions]
(
	@languageId TINYINT,
	@options VARCHAR(1000)
)
RETURNS BIGINT
AS
BEGIN
	DECLARE @result BIGINT = NULL;

	SELECT @result=SUM(DISTINCT(lo.[Value]))
	FROM [dbo].[DelimitedSplitN4K](@options, ',') o
	JOIN [Static].[LanguageOption] lo ON ISNULL(lo.[LanguageId], @languageId)=@languageId AND lo.[IsPrimary]=1 AND lo.[Name]=LTRIM(RTRIM(o.[Item]));

	RETURN ISNULL(@result, 0);
END
GO
PRINT N'Creating Function [Internal].[SplitName]...';


GO
CREATE FUNCTION [Internal].[SplitName]
(
	@name NVARCHAR(4000)
)
RETURNS 
@result TABLE 
(
	[ItemNumber] SMALLINT,
	[Item] NVARCHAR(4000)
)
AS
BEGIN
	DECLARE @l INT = LEN(@name);

	DECLARE @CT_START TINYINT = 0;
	DECLARE @CT_SEPARATOR TINYINT = 1;
	DECLARE @CT_DIGIT TINYINT = 2;
	DECLARE @CT_LOWER_LETTER TINYINT = 3;
	DECLARE @CT_UPPER_LETTER TINYINT = 4;

	DECLARE @IT_NONE TINYINT = 0;
	DECLARE @IT_UPPER TINYINT = 1;
	DECLARE @IT_LOWER TINYINT = 2;
	DECLARE @IT_PASCAL TINYINT = 3;
	DECLARE @IT_UPPER_DIGIT TINYINT = 4;
	
	DECLARE @item NVARCHAR(4000) = NULL;
	DECLARE @itemNo SMALLINT = 1;
	DECLARE @i INT = 0;
	DECLARE @pc CHAR(1) = NULL;
	DECLARE @c CHAR(1) = NULL;
	DECLARE @pct TINYINT = @CT_START;
	DECLARE @ct TINYINT;
	DECLARE @il INT = 0;
	DECLARE @it TINYINT = @IT_NONE;

	WHILE @i < @l
	BEGIN
		SET @i += 1;
		SET @c = SUBSTRING(@name, @i, 1);
		IF @c LIKE '[A-Z]' COLLATE Latin1_General_100_BIN2
		BEGIN
			SET @ct = @CT_UPPER_LETTER;
		END
		ELSE IF @c LIKE '[a-z]' COLLATE Latin1_General_100_BIN2
		BEGIN
			SET @ct = @CT_LOWER_LETTER;
		END
		ELSE IF @c LIKE '[0-9]'
		BEGIN
			SET @ct = @CT_DIGIT;
		END
		ELSE
		BEGIN
			SET @ct = @CT_SEPARATOR;
		END

		IF @ct = @CT_SEPARATOR
		BEGIN
			IF @il > 0
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = NULL;
				SET @il = 0;
				SET @it = @IT_NONE;
			END
		END
		ELSE IF @ct = @CT_DIGIT
		BEGIN
			IF @it <> @IT_NONE
			BEGIN
				IF @it = @IT_UPPER
				BEGIN
					SET @it = @IT_UPPER_DIGIT
				END
				SET @item += @c;
				SET @il += 1;
			END
		END
		ELSE IF @ct = @CT_UPPER_LETTER
		BEGIN
			IF @it = @IT_NONE
			BEGIN
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_UPPER;
			END
			ELSE IF @it = @IT_UPPER
			BEGIN
				SET @item += @c;
				SET @il += 1;
			END
			ELSE -- @IT_LOWER, @IT_PASCAL, @IT_UPPER_DIGIT
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_UPPER;
			END 
		END
		ELSE IF @ct = @CT_LOWER_LETTER
		BEGIN
			IF @it = @IT_NONE
			BEGIN
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_LOWER;
			END
			ELSE IF @it = @IT_UPPER
			BEGIN
				IF @il > 1
				BEGIN
					INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, LEFT(@item, @il - 1));
					SET @itemNo += 1;
					SET @item = RIGHT(@item, 1);
					SET @il = 1;
				END
				
				SET @item += @c;
				SET @il += 1;
				SET @it = @IT_PASCAL;
			END
			ELSE IF @it = @IT_UPPER_DIGIT
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_LOWER;
			END
			ELSE -- @IT_LOWER, @IT_PASCAL
			BEGIN				
				SET @item += @c;
				SET @il += 1;				
			END
		END
	END;
	IF @item IS NOT NULL
	BEGIN
		INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
	END
	RETURN;
END
GO
PRINT N'Creating Function [Internal].[ProcessTemplate]...';


GO

CREATE FUNCTION [Internal].[ProcessTemplate]
(
	@template NVARCHAR(4000),
	@vars [Internal].[Variable] READONLY	
)
RETURNS 
@result TABLE 
(
	[Id] INT NOT NULL IDENTITY(1,1) PRIMARY KEY,
	[Text] NVARCHAR(4000)
)
AS
BEGIN
	DECLARE @id INT = (SELECT MIN([Id]) FROM @vars);
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @template = REPLACE(@template, N'@{' + [Name] + N'}', ISNULL([Value], N''))
		FROM @vars
		WHERE [Id]=@id;
		SELECT @id=MIN([Id]) FROM @vars
		WHERE [Id]>@id;
	END
	INSERT INTO @result ([Text])
	SELECT d.[Item]
	FROM [dbo].[DelimitedSplitN4K](@template, CHAR(10)) d
	ORDER BY d.[ItemNumber];
	UPDATE @result
	SET [Text]=REPLACE([Text], CHAR(13), '');
	RETURN 
END
GO
PRINT N'Creating Function [Internal].[GetCaseName]...';


GO

CREATE FUNCTION [Internal].[GetCaseName]
(	
	@caseId TINYINT,
	@name NVARCHAR(200),
	@schema NVARCHAR(200)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = '';

	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

	IF LTRIM(ISNULL(@schema, '')) NOT IN (N'dbo', N'sys', N'')
	BEGIN
		SET @name = @schema + N'.' + @name;
	END

	DECLARE @pfx NVARCHAR(1) = CASE WHEN @caseId=@C_UNDERSCORE_CAMEL_CASE THEN N'_' ELSE N'' END;
	DECLARE @sep NVARCHAR(1) = CASE WHEN @caseId IN (@C_SNAKE_CASE, @C_UPPER_SNAKE_CASE) THEN N'_' ELSE N'' END;

	SELECT @result=@pfx+STRING_AGG(
		CASE 
		WHEN @caseId=@C_PASCAL_CASE OR ([ItemNumber]>1 AND @caseId IN (@C_CAMEL_CASE, @C_UNDERSCORE_CAMEL_CASE)) 
			THEN UPPER(LEFT([Item], 1)) + LOWER(RIGHT([Item], LEN([Item]) - 1)) 
		WHEN @caseId IN (@C_SNAKE_CASE, @C_CAMEL_CASE, @C_UNDERSCORE_CAMEL_CASE) THEN LOWER([Item])
		ELSE Upper([Item])
		END
		, @sep
	) WITHIN GROUP (ORDER BY [ItemNumber] ASC)	
	FROM [Internal].[SplitName](@name);
	
	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[GetName]...';


GO
CREATE FUNCTION [Internal].[GetName]
(	
	@projectId TINYINT,
	@typeId TINYINT,
	@name NVARCHAR(128),
	@schema NVARCHAR(128)
)
RETURNS NVARCHAR(200)
AS
BEGIN
	DECLARE @result NVARCHAR(200) = '';
	DECLARE @casingId TINYINT;
	
	SELECT @casingId=lnc.[CasingId]
	FROM [dbo].[Project] p
	JOIN [Static].[LanguageNameCasing] lnc ON lnc.[LanguageId]=p.[LanguageId] AND lnc.[NameTypeId]=@typeId
	WHERE p.[Id]=@projectId;

	SELECT @result=[Internal].[GetCaseName](@casingId, @name, NULL);
	
	RETURN ISNULL(NULLIF(@result, ''), [Internal].[GetCaseName](@casingId, 'x', NULL));
END
GO
PRINT N'Creating Function [Internal].[GetNameEx]...';


GO

CREATE FUNCTION [Internal].[GetNameEx]
(	
	@projectId TINYINT,
	@typeId TINYINT,
	@sourceId TINYINT,
	@name NVARCHAR(128),
	@schema NVARCHAR(128)
)
RETURNS NVARCHAR(200)
AS
BEGIN
	DECLARE @prefix NVARCHAR(128), @suffix NVARCHAR(128);
	SELECT TOP (1) @prefix = nn.[NamePart] 
	FROM [dbo].[ProjectNameNormalization] nn
	JOIN [Enum].[NamePartType] t ON nn.[NamePartTypeId]=t.[Id]
	WHERE t.[NameSourceId]=@sourceId AND nn.[ProjectId]=@projectId AND t.[IsPrefix]=1
	AND LEFT(@name, LEN(nn.[NamePart]))=nn.[NamePart]
	ORDER BY LEN(nn.[NamePart]) DESC;

	IF @prefix IS NOT NULL
	BEGIN
		SET @name = [Internal].[RemoveFromStart](@name, @prefix);
	END

	SELECT TOP (1) @suffix = nn.[NamePart] 
	FROM [dbo].[ProjectNameNormalization] nn
	JOIN [Enum].[NamePartType] t ON nn.[NamePartTypeId]=t.[Id]
	WHERE t.[NameSourceId]=@sourceId AND nn.[ProjectId]=@projectId AND t.[IsSuffix]=1
	AND RIGHT(@name, LEN(nn.[NamePart]))=nn.[NamePart]
	ORDER BY LEN(nn.[NamePart]) DESC;

	IF @suffix IS NOT NULL
	BEGIN
		SET @name = [Internal].[RemoveFromEnd](@name, @suffix);
	END

	DECLARE @result NVARCHAR(200) = [Internal].[GetName](@projectId, @typeId, @name, @schema);
	RETURN @result;
END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcedures]...';


GO

CREATE PROCEDURE [Internal].[GetStoredProcedures]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @NM_EXACT_MATCH TINYINT = 1;
    DECLARE @NM_PREFIX TINYINT = 2;
    DECLARE @NM_SUFFIX TINYINT = 3;
    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;

	IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id]=@projectId)
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @spSchemas NVARCHAR(4000);
    SELECT @spSchemas=STRING_AGG(QUOTENAME(sp.[Schema], N''''), ',') FROM (SELECT DISTINCT [Schema] FROM [dbo].[ProjectStoredProc] WHERE [ProjectId]=@projectId) sp;

    IF NULLIF(LTRIM(@spSchemas), '') IS NULL
    BEGIN
        SELECT @rc = @RC_OK;
		RETURN @rc;
    END

    DECLARE @query NVARCHAR(4000);

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT SCHEMA_NAME(p.schema_id) [Schema], p.[name] [Name] '
	SET @query += N'FROM sys.procedures p '	
	SET @query += N'WHERE p.[Type]=''P''  '
	SET @query += N'AND SCHEMA_NAME(p.schema_id) IN (' + @spSchemas + N') '
	SET @query += N';
	';
	--PRINT(@query);


    DROP TABLE IF EXISTS #EveryStoredProc;
    CREATE TABLE #EveryStoredProc 
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [Schema] NVARCHAR(128) NOT NULL, 
        [Name] NVARCHAR(128) NOT NULL,
        [WrapperName] NVARCHAR(200) NULL,
        [HasResultSet] BIT NOT NULL DEFAULT (0),
        [HasUnknownResultSet] BIT NOT NULL DEFAULT (0),
        [ResultType] NVARCHAR(200) NOT NULL DEFAULT(N'int'),
        [LanguageOptionsReset] BIGINT NULL,
        [LanguageOptionsSet] BIGINT NULL,
        [ProjectStoredProcId] INT NULL,
        UNIQUE ([Schema], [Name])
    );
	
	INSERT INTO #EveryStoredProc ([Schema], [Name])
	EXEC(@query);

    UPDATE sp
    SET sp.[ProjectStoredProcId]=psp.[Id], sp.[LanguageOptionsReset]=psp.[LanguageOptionsReset], sp.[LanguageOptionsSet]=psp.[LanguageOptionsSet]
    FROM #EveryStoredProc sp
    JOIN [dbo].[ProjectStoredProc] psp ON psp.[ProjectId]=@projectId AND psp.[Schema]=sp.[Schema] 
    AND [Internal].[IsNameMatch](sp.[Name], psp.[NameMatchId], psp.[NamePattern], psp.[EscChar])=1
    LEFT JOIN [dbo].[ProjectStoredProc] xpsp ON xpsp.[ProjectId]=@projectId AND xpsp.[Schema]=sp.[Schema] 
    AND [Internal].[IsNameMatch](sp.[Name], xpsp.[NameMatchId], xpsp.[NamePattern], xpsp.[EscChar])=1
    AND (xpsp.[NameMatchId]<psp.[NameMatchId] OR (xpsp.[NameMatchId]=psp.[NameMatchId] AND xpsp.[Id]<psp.[Id]))
    WHERE xpsp.[Id] IS NULL;

    INSERT INTO #StoredProc ([Schema], [Name], [LanguageOptionsReset], [LanguageOptionsSet])
    SELECT [Schema], [Name], [LanguageOptionsReset], [LanguageOptionsSet]
    FROM #EveryStoredProc
    WHERE [ProjectStoredProcId] IS NOT NULL
	ORDER BY [Schema], [Name];

    DROP TABLE IF EXISTS #EveryStoredProc;
END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcParams]...';


GO


CREATE PROCEDURE [Internal].[GetStoredProcParams]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @PEM_EXPLICIT_ONLY TINYINT = 1;
	DECLARE @PEM_ENUM_NAME TINYINT = 2;
	DECLARE @PEM_ENUM_NAME_WITH_ID TINYINT = 3;
	DECLARE @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID TINYINT = 4;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	DECLARE @pemId TINYINT;

	SELECT @pemId=[ParamEnumMappingId]      
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @pemId IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END
	

	SELECT @spSchema=[Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	IF @spSchema IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@spId) + N' [StoredProcId], p.[parameter_id] [ParamId], p.[name] [Name], t.[name] [SqlType], SCHEMA_NAME(t.schema_id) [SqlTypeSchema], '
	SET @query += N'p.[max_length] [MaxLen], p.[precision] [Precision], p.[scale] [Scale], p.[is_output] [IsOutput], p.[is_readonly] [IsReadOnly], '
	SET @query += N't.[is_user_defined] [IsTypeUserDefined], t.[is_table_type] [IsTableType] '
	SET @query += N'FROM sys.procedures sp '
	SET @query += N'JOIN sys.parameters p ON p.[object_id]=sp.[object_id] '
	SET @query += N'JOIN sys.types t ON p.[user_type_id]=t.[user_type_id] '
	SET @query += N'WHERE sp.[Type]=''P'' '
	SET @query += N'AND SCHEMA_NAME(sp.schema_id)=' + QUOTENAME(@spSchema, N'''') + N' AND sp.[name]=' + QUOTENAME(@spName, N'''') + N' '
	SET @query += N'ORDER BY p.[parameter_id] '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #StoredProcParam ([StoredProcId], [ParamId], [Name], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [IsOutput], [IsReadOnly], [IsTypeUserDefined], [IsTableType])
	EXEC(@query);

	IF (@pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID))
	BEGIN
		UPDATE spp
		SET spp.[EnumId]=e.[Id]
		FROM #StoredProcParam spp
		JOIN #Enum e ON spp.[SqlType]=e.[ValueType] 
		AND ((e.[EnumName]=[Internal].[RemoveFromStart](spp.[Name], N'@') AND @pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)) 
		OR (spp.[Name] LIKE N'%Id' AND e.[EnumName]=[Internal].[RemoveFromEnd]([Internal].[RemoveFromStart](spp.[Name], N'@'), N'Id') AND @pemId IN (@PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)))
	END
	SET @rc=@RC_OK;
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Internal].[GetEnumForeignKeys]...';


GO


CREATE PROCEDURE [Internal].[GetEnumForeignKeys]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;
	

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	DECLARE @nameColumn NVARCHAR(128);
	DECLARE @valueColumn NVARCHAR(128);

	SELECT @enumSchema=[Schema], @enumTable=[Table], @nameColumn=[NameColumn], @valueColumn=[ValueColumn]
	FROM #Enum
	WHERE [Id]=@enumId;

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@enumId) + N' [EnumId], sch.name [ForeignSchema], tab1.name [ForeignTable], col1.name [ForeignColumn] ' 
	SET @query += N'FROM sys.foreign_key_columns fkc '
	SET @query += N'INNER JOIN sys.objects obj ON obj.object_id = fkc.constraint_object_id '
	SET @query += N'INNER JOIN sys.tables tab1 ON tab1.object_id = fkc.parent_object_id '
	SET @query += N'INNER JOIN sys.schemas sch ON tab1.schema_id = sch.schema_id '
	SET @query += N'INNER JOIN sys.columns col1 ON col1.column_id = parent_column_id AND col1.object_id = tab1.object_id '
	SET @query += N'INNER JOIN sys.tables tab2 ON tab2.object_id = fkc.referenced_object_id '
	SET @query += N'INNER JOIN sys.schemas sch2 ON tab2.schema_id = sch2.schema_id '
	SET @query += N'INNER JOIN sys.columns col2 ON col2.column_id = referenced_column_id AND col2.object_id = tab2.object_id '
	SET @query += N'WHERE sch2.name=' + QUOTENAME(@enumSchema, '''') + N' AND tab2.name=' + QUOTENAME(@enumTable, '''') + N' AND col2.name=' + QUOTENAME(@valueColumn, '''');
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #EnumForeignKey ([EnumId], [ForeignSchema], [ForeignTable], [ForeignColumn])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[PrintError]...';


GO

CREATE PROCEDURE [Internal].[PrintError] 
AS
BEGIN
    SET NOCOUNT ON;
	-- source: AdventureWorks sample database
    -- Print error information. 
    PRINT 'Error ' + CONVERT(varchar(50), ERROR_NUMBER()) +
          ', Severity ' + CONVERT(varchar(5), ERROR_SEVERITY()) +
          ', State ' + CONVERT(varchar(5), ERROR_STATE()) + 
          ', Procedure ' + ISNULL(ERROR_PROCEDURE(), '-') + 
          ', Line ' + CONVERT(varchar(5), ERROR_LINE());
    PRINT ERROR_MESSAGE();
END;
GO
PRINT N'Creating Procedure [Internal].[LogError]...';


GO



CREATE PROCEDURE [Internal].[LogError] 
    @errorLogId [int] = 0 OUTPUT -- contains the ID of the row inserted
AS                               -- by [Internal].[LogError] Stored Procedure in the ErrorLog table
BEGIN
    SET NOCOUNT ON;

	-- source: AdventureWorks sample database

    -- Output parameter value of 0 indicates that error 
    -- information was not logged
    SET @errorLogId = 0;

    BEGIN TRY
        -- Return if there is no error information to log
        IF ERROR_NUMBER() IS NULL
            RETURN;

        -- Return if inside an uncommittable transaction.
        -- Data insertion/modification is not allowed when 
        -- a transaction is in an uncommittable state.
        IF XACT_STATE() = -1
        BEGIN
            PRINT 'Cannot log error since the current transaction is in an uncommittable state. ' 
                + 'Rollback the transaction before executing uspLogError in order to successfully log error information.';
            RETURN;
        END

        INSERT [dbo].[ErrorLog] 
            (
            [UserName], 
            [ErrorNumber], 
            [ErrorSeverity], 
            [ErrorState], 
            [ErrorProcedure], 
            [ErrorLine], 
            [ErrorMessage]
            ) 
        VALUES 
            (
            CONVERT(sysname, CURRENT_USER), 
            ERROR_NUMBER(),
            ERROR_SEVERITY(),
            ERROR_STATE(),
            ERROR_PROCEDURE(),
            ERROR_LINE(),
            ERROR_MESSAGE()
            );

        -- Pass back the ErrorLogID of the row inserted
        SET @errorLogId = @@IDENTITY;
    END TRY
    BEGIN CATCH
        PRINT 'An error occurred in stored procedure uspLogError: ';
        EXECUTE [Internal].[PrintError];
        RETURN -1;
    END CATCH
END;
GO
PRINT N'Creating Procedure [Internal].[GetTableTypeColumns]...';


GO



CREATE PROCEDURE [Internal].[GetTableTypeColumns]
    @projectId SMALLINT,
    @dbId SMALLINT,
    @langId TINYINT,
    @ttId INT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @rc INT;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_PROJECT INT = 21;
    DECLARE @RC_ERR_DB INT = 22;
    DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @PEM_EXPLICIT_ONLY TINYINT = 1;
    DECLARE @PEM_ENUM_NAME TINYINT = 2;
    DECLARE @PEM_ENUM_NAME_WITH_ID TINYINT = 3;
    DECLARE @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID TINYINT = 4;

    DECLARE @schema NVARCHAR(128);
    DECLARE @name NVARCHAR(128);

    DECLARE @pemId TINYINT;

    SELECT @pemId=[ParamEnumMappingId]      
    FROM [dbo].[Project]
    WHERE [Id]=@projectId;

    IF @pemId IS NULL
    BEGIN
        SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
        RETURN @rc;
    END
    

    SELECT @name=[SqlType], @schema=[SqlTypeSchema]
    FROM #TableType
    WHERE [Id]=@ttId;

    IF @name IS NULL
    BEGIN
        SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
        RETURN @rc;
    END

    DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

    IF @dbName IS NULL
    BEGIN
        SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
        RETURN @rc;
    END

    DECLARE @query NVARCHAR(4000);

    

    SET @query = N'USE ' + QUOTENAME(@dbName) + N';
    ';
    SET @query += N'SELECT ' + LOWER(@ttId) + N' [TableTypeId], c.[column_id] [ColumnId],  ROW_NUMBER() OVER (ORDER BY c.[column_id]) - 1 [ColumnNumber], c.[name] [Name], ';
    SET @query += N'c.is_nullable [IsNullable], t.[name] [SqlType], SCHEMA_NAME(t.schema_id) [SqlTypeSchema], '
    SET @query += N'c.[max_length] [MaxLen], c.[precision] [Precision], c.[scale] [Scale], c.[is_identity] [IsIdentity] '
    SET @query += N'FROM sys.table_types tt '
    SET @query += N'JOIN sys.columns c on c.object_id = tt.type_table_object_id '
    SET @query += N'JOIN sys.types t ON c.system_type_id=t.system_type_id AND c.system_type_id = t.user_type_id '
    SET @query += N'WHERE SCHEMA_NAME(tt.schema_id)=' + QUOTENAME(@schema, N'''') + N' AND tt.[name]=' + QUOTENAME(@name, N'''') + N' '
    SET @query += N'ORDER BY c.[column_id] '
    SET @query += N';
    ';
    --PRINT(@query);
    
    INSERT INTO #TableTypeColumn
    ([TableTypeId], [ColumnId], [ColumnNumber], [Name], [IsNullable], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [IsIdentity])
    EXEC(@query);

    IF (@pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID))
    BEGIN
        UPDATE ttc
        SET ttc.[EnumId]=e.[Id]
        FROM #TableTypeColumn ttc
        JOIN #Enum e ON ttc.[SqlType]=e.[ValueType] 
        AND ((e.[EnumName]=[Internal].[RemoveFromStart](ttc.[Name], N'@') AND @pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)) 
        OR (ttc.[Name] LIKE N'%Id' AND e.[EnumName]=[Internal].[RemoveFromEnd]([Internal].[RemoveFromStart](ttc.[Name], N'@'), N'Id') AND @pemId IN (@PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)))
    END
    SET @rc=@RC_OK;
    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Internal].[GetEnums]...';


GO
CREATE PROCEDURE [Internal].[GetEnums]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @NM_EXACT_MATCH TINYINT = 1;
    DECLARE @NM_PREFIX TINYINT = 2;
    DECLARE @NM_SUFFIX TINYINT = 3;
    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;
	
    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id]=@projectId)
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @enumSchemas NVARCHAR(4000);
    SELECT @enumSchemas=STRING_AGG(QUOTENAME(e.[Schema], N''''), ',') FROM (SELECT DISTINCT [Schema] FROM [dbo].[ProjectEnum] WHERE [ProjectId]=@projectId) e;

    IF NULLIF(LTRIM(@enumSchemas), '') IS NULL
    BEGIN
        SELECT @rc = @RC_OK;
		RETURN @rc;
    END

    DROP TABLE IF EXISTS #EveryEnum;
    CREATE TABLE #EveryEnum
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [Schema] NVARCHAR(128) NOT NULL,
        [Table] NVARCHAR(128) NOT NULL,        
        [NameColumn] NVARCHAR(128) NOT NULL,
        [ValueColumn] NVARCHAR(128) NOT NULL,
        [EnumName] NVARCHAR(200) NULL,
        [ValueType] NVARCHAR(128) NOT NULL,
        [IsSetOfFlags] BIT NOT NULL DEFAULT (0),
        [ProjectEnumId] INT NULL,
        UNIQUE ([Schema], [Table])
    );

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT SCHEMA_NAME(t.schema_id) [Schema], t.[name] [Table], nc.name [NameColumn], vc.name [ValueColumn], vct.[name] [ValueType] '
	SET @query += N'FROM sys.tables t '
	SET @query += N'JOIN sys.indexes pk ON pk.object_id=t.object_id AND pk.is_primary_key=1 '
	SET @query += N'JOIN sys.index_columns pkc ON pkc.object_id=pk.object_id AND pkc.index_id=pk.index_id AND pkc.index_column_id=1 AND pkc.is_included_column=0 '
	SET @query += N'JOIN sys.columns vc ON vc.object_id=pkc.object_id AND vc.column_id=pkc.column_id '
	SET @query += N'JOIN sys.types vct ON vct.system_type_id=vc.system_type_id AND vct.user_type_id=vc.user_type_id AND vct.name IN (''tinyint'', ''smallint'', ''int'', ''bigint'') '
	SET @query += N'JOIN sys.indexes ux ON ux.object_id=t.object_id AND ux.is_primary_key=0 AND ux.is_unique=1 '
	SET @query += N'JOIN sys.index_columns uxc ON uxc.object_id=ux.object_id AND uxc.index_id=ux.index_id AND uxc.index_column_id=1 AND uxc.is_included_column=0 '
	SET @query += N'JOIN sys.columns nc ON nc.object_id=uxc.object_id AND nc.column_id=uxc.column_id '
	SET @query += N'JOIN sys.types nct ON nct.system_type_id=nc.system_type_id AND nct.user_type_id=nc.user_type_id AND nct.name IN (''varchar'', ''nvarchar'') '
	SET @query += N'LEFT JOIN sys.index_columns pkc2 ON pkc2.object_id=pk.object_id AND pkc2.index_id=pk.index_id AND pkc2.index_column_id=2 '
	SET @query += N'LEFT JOIN sys.index_columns uxc2 ON uxc2.object_id=pk.object_id AND uxc2.index_id=ux.index_id AND uxc2.index_column_id=2 '
	SET @query += N'LEFT JOIN sys.columns idnc ON idnc.object_id=t.object_id AND idnc.is_identity=1 '
	SET @query += N'LEFT JOIN sys.indexes ux2 ON ux2.object_id=t.object_id AND ux2.is_primary_key=0 AND ux2.is_unique=1 AND ux2.index_id<>ux.index_id '
	SET @query += N'WHERE t.[Type]=''U'' AND idnc.column_id IS NULL AND pkc2.index_column_id IS NULL AND uxc2.index_column_id IS NULL AND ux2.index_id IS NULL '
	SET @query += N'AND SCHEMA_NAME(t.schema_id) IN (' + @enumSchemas + N') '
	SET @query += N'ORDER BY t.[name] '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #EveryEnum ([Schema], [Table], [NameColumn], [ValueColumn], [ValueType])
	EXEC(@query);


	DECLARE c CURSOR LOCAL FAST_FORWARD FOR
	SELECT [Schema], [NamePattern], [NameColumn]
	FROM [dbo].[ProjectEnum]
	WHERE [ProjectId] = @projectId AND [NameColumn] IS NOT NULL;

	DECLARE @s NVARCHAR(128), @t NVARCHAR(200), @nc NVARCHAR(128);
	DECLARE @query2 NVARCHAR(MAX);

	OPEN c;
	FETCH NEXT FROM c INTO @s, @t, @nc;

	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @query2 = N'USE ' + QUOTENAME(@dbName) + N';
		SELECT 
			' + QUOTENAME(@s, '''') + N' AS [Schema],
			' + QUOTENAME(@t, '''') + N' AS [Table],
			' + QUOTENAME(@nc, '''') + N' AS [NameColumn],
			vc.[name] AS [ValueColumn],
			vct.[name] AS [ValueType]
		FROM sys.tables t
		JOIN sys.indexes pk ON pk.object_id = t.object_id AND pk.is_primary_key = 1
		JOIN sys.index_columns pkc ON pkc.object_id = pk.object_id AND pkc.index_id = pk.index_id AND pkc.index_column_id = 1 AND pkc.is_included_column = 0
		JOIN sys.columns vc ON vc.object_id = pkc.object_id AND vc.column_id = pkc.column_id
		JOIN sys.types vct ON vct.system_type_id = vc.system_type_id AND vct.user_type_id = vc.user_type_id AND vct.name IN (''tinyint'', ''smallint'', ''int'', ''bigint'')
		WHERE t.[name] = ' + QUOTENAME(@t, '''') + ' AND SCHEMA_NAME(t.schema_id) = ' + QUOTENAME(@s, '''') + ';
		';

		-- PRINT (@query2);

		INSERT INTO #EveryEnum ([Schema], [Table], [NameColumn], [ValueColumn], [ValueType])
		EXEC (@query2);

		FETCH NEXT FROM c INTO @s, @t, @nc;
	END

	CLOSE c; DEALLOCATE c;

    -- now filter only selected enums

    UPDATE e
    SET e.[ProjectEnumId]=pe.[Id], e.[IsSetOfFlags]=pe.[IsSetOfFlags]
    FROM #EveryEnum e
    JOIN [dbo].[ProjectEnum] pe ON pe.[ProjectId]=@projectId AND pe.[Schema]=e.[Schema] AND [Internal].[IsNameMatch](e.[Table], pe.[NameMatchId], pe.[NamePattern], pe.[EscChar])=1
    LEFT JOIN [dbo].[ProjectEnum] xpe ON xpe.[ProjectId]=@projectId AND xpe.[Schema]=e.[Schema] 
    AND [Internal].[IsNameMatch](e.[Table], xpe.[NameMatchId], xpe.[NamePattern], xpe.[EscChar])=1
    AND (xpe.[NameMatchId]<pe.[NameMatchId] OR (xpe.[NameMatchId]=pe.[NameMatchId] AND xpe.[Id]<pe.[Id]))
    WHERE xpe.[Id] IS NULL;
    
    INSERT INTO #Enum ([Schema], [Table], [NameColumn], [ValueColumn], [ValueType], [IsSetOfFlags])
    SELECT e.[Schema], e.[Table], e.[NameColumn], e.[ValueColumn], e.[ValueType], e.[IsSetOfFlags]
    FROM #EveryEnum e
    WHERE e.[ProjectEnumId] IS NOT NULL;

    DROP TABLE IF EXISTS #EveryEnum;
END
GO
PRINT N'Creating Procedure [Internal].[GetEnumValues]...';


GO

CREATE PROCEDURE [Internal].[GetEnumValues]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;
	

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	DECLARE @nameColumn NVARCHAR(128);
	DECLARE @valueColumn NVARCHAR(128);

	SELECT @enumSchema=[Schema], @enumTable=[Table], @nameColumn=[NameColumn], @valueColumn=[ValueColumn]
	FROM #Enum
	WHERE [Id]=@enumId;

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@enumId) + N' [EnumId], ' + QUOTENAME(@nameColumn) + N' [Name], ' + QUOTENAME(@valueColumn) + N' [Value] ' 
	SET @query += N'FROM ' + QUOTENAME(@enumSchema) + N'.' + QUOTENAME(@enumTable) + N' '
	SET @query += N'ORDER BY ' + QUOTENAME(@valueColumn)
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #EnumVal ([EnumId], [Name], [Value])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[CreateProject]...';


GO
CREATE PROCEDURE [Internal].[CreateProject]
    @name NVARCHAR(200),
    @namespaceName VARCHAR(100),
    @className VARCHAR(100),
    @classAccessId TINYINT,
    @languageId TINYINT,
    @paramEnumMappingId TINYINT,
    @mapResultSetEnums BIT,
    @languageOptions BIGINT,
    @defaultDatabase NVARCHAR(128) = NULL,
    @enumSchema NVARCHAR(128) = NULL,
    @storedProcSchema NVARCHAR(128) = NULL,
    @projectId SMALLINT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

	DECLARE @NM_ANY TINYINT = 255; -- Enum.NameMatch: 'Any'

    INSERT INTO [dbo].[Project] 
    ([Name], [NamespaceName], [ClassName], [ClassAccessId], [LanguageId], [ParamEnumMappingId], [MapResultSetEnums], [LanguageOptions], [DefaultDatabase])
    VALUES
    (@name, @namespaceName, @className, @classAccessId, @languageId, @paramEnumMappingId, @mapResultSetEnums, @languageOptions, @defaultDatabase);

    SET @projectId = SCOPE_IDENTITY();

    IF @enumSchema IS NOT NULL
    BEGIN
        INSERT INTO [dbo].[ProjectEnum] 
        ([ProjectId], [Schema], [NameMatchId], [NamePattern], [EscChar], [IsSetOfFlags])
        VALUES
        (@projectId, @enumSchema, @NM_ANY, NULL, NULL, 0);
    END

    IF @storedProcSchema IS NOT NULL
    BEGIN
        INSERT INTO [dbo].[ProjectStoredProc]
        ([ProjectId], [Schema], [NameMatchId], [NamePattern], [EscChar], [LanguageOptionsReset], [LanguageOptionsSet])
        VALUES
        (@projectId, @storedProcSchema, @NM_ANY, NULL, NULL, NULL, NULL);
    END

	RETURN 0;
END
GO
PRINT N'Creating Procedure [Internal].[GenerateTableTypeCode]...';


GO




CREATE PROCEDURE [Internal].[GenerateTableTypeCode]
    @projectId SMALLINT,
    @dbId SMALLINT,
    @langId TINYINT,
    @ttId INT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @rc INT;

    DECLARE @RC_OK INT = 0;
    
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='TvpTypes');

    DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
    DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
    DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
    DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
    DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
    DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
    DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
    DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
    DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_IDENTITY TINYINT = 44;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE TINYINT = 45;

    DECLARE @typeName NVARCHAR(200);
    DECLARE @ttSchema NVARCHAR(128);
    DECLARE @ttName NVARCHAR(128);

    DECLARE @className NVARCHAR(100);
    DECLARE @langOptions BIGINT;
    
    SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]
    FROM [dbo].[Project] p
    JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
    WHERE p.[Id]=@projectId;

    IF @className IS NULL
    BEGIN
        SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
    END

    SELECT @typeName=tt.[Name], @ttSchema=tt.[SqlTypeSchema], @ttName=tt.[SqlType]
    FROM #TableType tt    
    WHERE tt.[Id]=@ttId;

    IF @typeName IS NULL
    BEGIN        
        SET @errorCode='UnknownTableType';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
    END

    DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

    IF @dbName IS NULL
    BEGIN
        SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
    END

    DECLARE @numberOfColumns INT = (SELECT COUNT(*) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId);

    DECLARE @vars [Internal].[Variable];
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TtSchema', [Internal].[EscapeString](@langId, QUOTENAME(@ttSchema)));
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TtName', [Internal].[EscapeString](@langId, QUOTENAME(@ttName)));
    
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
    INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'BaseType', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnName', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'AllowNull', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'MaxLength', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Cast', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');    
    INSERT INTO @vars ([Name], [Value]) VALUES (N'NumberOfColumns', @numberOfColumns);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnNumber', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'SqlDbType', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Precision', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Scale', NULL);
    
    


    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_START)
    ORDER BY c.[Id];

    DECLARE @id INT = (SELECT MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0);
    DECLARE @lastId INT = (SELECT MAX([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0);    
    DECLARE @name NVARCHAR(128);
    DECLARE @columnName NVARCHAR(128);
    DECLARE @type NVARCHAR(128);
    DECLARE @baseType NVARCHAR(128);
    DECLARE @sqlDbType NVARCHAR(128);

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=ttc.[Name], @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';
        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_PROPERTY)
        ORDER BY c.[Id];

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0 AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_START)
    ORDER BY c.[Id];

    SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId;
    DECLARE @allowNull BIT
    DECLARE @maxLength INT;
    DECLARE @isIdentity BIT;
    DECLARE @columnNumber INT;
    DECLARE @precision INT;
    DECLARE @scale INT;

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=[Internal].[EscapeString](@langId, ttc.[Name]), @baseType=dtm.[NativeType], -- + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END, @isIdentity=ttc.[IsIdentity], @columnNumber=ttc.[ColumnNumber], @sqlDbType=dtm.SqlDbType,
        @precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN ttc.[Precision] ELSE NULL END, @scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN ttc.[Scale] ELSE NULL END
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';

        UPDATE @vars
        SET [Value]=@columnName
        WHERE [Name]=N'ColumnName';
        UPDATE @vars
        SET [Value]=@columnNumber
        WHERE [Name]=N'ColumnNumber';
        UPDATE @vars
        SET [Value]=@baseType
        WHERE [Name]=N'BaseType';
        UPDATE @vars
        SET [Value]=@sqlDbType
        WHERE [Name]=N'SqlDbType';
        

        UPDATE @vars
        SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
        WHERE [Name]=N'AllowNull';
        UPDATE @vars
        SET [Value]=@maxLength
        WHERE [Name]=N'MaxLength';

        UPDATE @vars
        SET [Value]=@precision
        WHERE [Name]=N'Precision';
        UPDATE @vars
        SET [Value]=@scale
        WHERE [Name]=N'Scale';

        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
            CASE WHEN @isIdentity=1 THEN @TT_TABLE_TYPE_DT_COLUMN_IDENTITY WHEN @maxLength IS NOT NULL THEN @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN 
            WHEN @precision IS NOT NULL THEN @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE ELSE @TT_TABLE_TYPE_DT_COLUMN END)
        ORDER BY c.[Id];


        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_COLUMN_ADD)
        ORDER BY c.[Id];

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_ROWS_START)
    ORDER BY c.[Id];

    SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0;
    DECLARE @cast NVARCHAR(200);

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=[Internal].[EscapeString](@langId, ttc.[Name]), @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,        
        @allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END, @columnNumber=ttc.[ColumnNumber]
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        SET @cast = CASE WHEN @baseType = @type THEN N'' ELSE N'(' + @baseType + N') ' END;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';

        UPDATE @vars
        SET [Value]=@columnName
        WHERE [Name]=N'ColumnName';
        UPDATE @vars
        SET [Value]=@columnNumber
        WHERE [Name]=N'ColumnNumber';
        UPDATE @vars
        SET [Value]=@baseType
        WHERE [Name]=N'BaseType';        

        UPDATE @vars
        SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
        WHERE [Name]=N'AllowNull';
        UPDATE @vars
        SET [Value]=@maxLength
        WHERE [Name]=N'MaxLength';

        UPDATE @vars
        SET [Value]=@cast
        WHERE [Name]=N'Cast';
        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, CASE WHEN @allowNull=1 THEN @TT_TABLE_TYPE_DT_ROW_NULL ELSE @TT_TABLE_TYPE_DT_ROW END)
        ORDER BY c.[Id];        

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0 AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_ROWS_END)
    ORDER BY c.[Id];

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_END)
    ORDER BY c.[Id];

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_END)
    ORDER BY c.[Id];

    

END
GO
PRINT N'Creating Procedure [Internal].[GenerateStoredProcWrapperCode]...';


GO




CREATE PROCEDURE [Internal].[GenerateStoredProcWrapperCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='SpWrappers');

	DECLARE @TT_WRAPPER_START TINYINT = 10;
	DECLARE @TT_WRAPPER_END TINYINT = 11;
	DECLARE @TT_WRAPPER_PREP TINYINT = 12;
	DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
	DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
	DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
	DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
	DECLARE @TT_WRAPPER_START2 TINYINT = 20;
	DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
	DECLARE @TT_WRAPPER_END2 TINYINT = 22;
	DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;
    DECLARE @TT_WRAPPER_EXEC_RS_RV TINYINT = 46;

	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

	DECLARE @LO_GENERATE_STATIC_CLASS BIGINT = 1;
    DECLARE @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT BIGINT = 2;
    DECLARE @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES BIGINT = 4;
    DECLARE @LO_TARGET_CLASSIC_DOT_NET BIGINT = 65536;
    DECLARE @LO_USE_SYNC_WRAPPERS BIGINT = 131072;

	DECLARE @NT_CLASS TINYINT = 1;
	DECLARE @NT_METHOD TINYINT = 2;
	DECLARE @NT_PROPERTY TINYINT = 3;
	DECLARE @NT_FIELD TINYINT = 4;
	DECLARE @NT_PARAMETER TINYINT = 5;
	DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
	DECLARE @NT_TUPLE_FIELD TINYINT = 7;
	DECLARE @NT_ENUM TINYINT = 8;
	DECLARE @NT_ENUM_MEMBER TINYINT = 9;
	
	DECLARE @wrapperName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	DECLARE @hasResultSet BIT;
    DECLARE @hasUnknownResultSet BIT;
	DECLARE @resultType NVARCHAR(200);
	

	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);		
	DECLARE @langOptions BIGINT;

	SELECT @className=p.[ClassName], @classAccess=ca.[Name], @langOptions=p.[LanguageOptions]
	--, @genStaticClass=p.[GenerateStaticClass], @treatOutputParamAsInputOutput=p.[TreatOutputParamAsInputOutput]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	--DECLARE @genStaticClass BIT; 	
    DECLARE @langOptionsReset BIGINT = NULL;
    DECLARE @langOptionsSet BIGINT = NULL;

	SELECT @wrapperName=sp.[WrapperName], @spSchema=sp.[Schema], @spName=sp.[Name], @hasResultSet=sp.[HasResultSet], @resultType=[ResultType], 
        @hasUnknownResultSet=sp.[HasUnknownResultSet], @langOptionsReset=[LanguageOptionsReset], @langOptionsSet=[LanguageOptionsSet]
	FROM #StoredProc sp 
	WHERE sp.[Id]=@spId;

	IF @wrapperName IS NULL
	BEGIN	
		SET @errorCode='UnknownStoredProcedure';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    IF @langOptionsReset IS NOT NULL
    BEGIN
        SET @langOptions &= ~@langOptionsReset;
    END

    IF @langOptionsSet IS NOT NULL
    BEGIN
        SET @langOptions |= @langOptionsSet;
    END

    DECLARE @treatOutputParamAsInputOutput BIT = CASE WHEN (@langOptions & @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT) = @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT THEN 1 ELSE 0 END;
    DECLARE @captureRetValForRsStoredProc BIT = CASE WHEN (@langOptions & @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES) = @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES THEN 1 ELSE 0 END;

    DECLARE @resultSetWithReturnValue BIT = CASE WHEN @hasUnknownResultSet=1 OR (@hasResultSet=1 AND @captureRetValForRsStoredProc=1) THEN 1 ELSE 0 END;

	DECLARE @methodAccess NVARCHAR(200) = N'public';

	DECLARE @resultTypeSingle NVARCHAR(200) = @resultType;

	IF @hasResultSet=1
	BEGIN
		SET @resultType = 'IList<' + @resultType + '>';
	END;

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'WrapperName', @wrapperName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', [Internal].[EscapeString](@langId, QUOTENAME(@spSchema)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', [Internal].[EscapeString](@langId, QUOTENAME(@spName)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultType', @resultType);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultTypeSingle', @resultTypeSingle);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarName', CASE WHEN @hasResultSet=1 THEN N'result' ELSE N'returnValue' END);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'RetValVarName', N'returnValue');
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'MethodAccess', @methodAccess);
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TypeCast', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ParamName', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'DbType', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Size', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Precision', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Scale', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');	

	INSERT INTO @vars ([Name], [Value]) VALUES (N'DtName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ReaderName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TvpName', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TableType', NULL);	
	
	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N',' ELSE N'' END WHERE [Name]=N'Sep';
	
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleStart', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N'(' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleEnd', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N')' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarNameTuple', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN CASE WHEN @hasResultSet=1 THEN N' Result' ELSE ' ReturnValue' END ELSE N'' END);

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_START)
	ORDER BY c.[Id];

	
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	DECLARE @name NVARCHAR(100);	
	DECLARE @type NVARCHAR(100);
	DECLARE @typeCast NVARCHAR(100);
	DECLARE @paramName NVARCHAR(100);	
	DECLARE @isOutput BIT;
	DECLARE @dbType NVARCHAR(100);
	DECLARE @size NVARCHAR(100);
	DECLARE @precision NVARCHAR(100);
	DECLARE @scale NVARCHAR(100);
	
    IF @resultSetWithReturnValue=1
    BEGIN
        UPDATE @vars
		SET [Value]=NULL
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=N'int'
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=[Internal].[GetName](@projectId, @NT_TUPLE_FIELD, N'returnValue', NULL)
		WHERE [Name]=N'ParamName';		
		
		
		IF @id IS NULL
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM_DEC)
		ORDER BY c.[Id];
    END
	

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName= [Internal].[GetName](@projectId, @NT_TUPLE_FIELD, p.[ParamName], NULL), @isOutput=p.[IsOutput]			
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM_DEC)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_START2)
	ORDER BY c.[Id];

	UPDATE @vars SET [Value]=',' WHERE [Name]=N'Sep';
	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	DECLARE @isTableType BIT;
	-- for CancellationToken parameter - C# specific, might need different logic to support different languages
	DECLARE @hasExtraParams BIT = CASE WHEN (@langOptions & @LO_USE_SYNC_WRAPPERS) = @LO_USE_SYNC_WRAPPERS THEN 0 ELSE 1 END;

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(ISNULL(N'IEnumerable<' + @className + N'.' + tt.[Name] + N'>', @className + N'.' + e.[EnumName]), dtm.[NativeType]) + CASE WHEN tt.[Id] IS NULL AND dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName=p.[ParamName], @isOutput=p.[IsOutput], @isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END
		FROM #StoredProcParam p 
		LEFT JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
				
		IF @id=@lastId AND @hasExtraParams=0
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PARAM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0) AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PREP)
	ORDER BY c.[Id];

	DECLARE @dtName NVARCHAR(200);
	DECLARE @readerName NVARCHAR(200);
	DECLARE @tvpName NVARCHAR(300);
	DECLARE @tableType NVARCHAR(300);

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],			
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' ELSE N'(' + dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END,
			@isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END,
			@dtName=[Internal].[GetName](@projectId, @NT_LOCAL_VARIABLE, N'dt_' + @paramName, NULL),
			@readerName=[Internal].[GetName](@projectId, @NT_LOCAL_VARIABLE, @paramName + '_reader', NULL),
			@tvpName=QUOTENAME(tt.[SqlTypeSchema]) + N'.' + [Internal].[EscapeString](@langId, QUOTENAME(tt.[SqlType])),
			@tableType=@className + N'.' + tt.[Name]
		FROM #StoredProcParam p 
		LEFT JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		UPDATE @vars
		SET [Value]=@tableType
		WHERE [Name]=N'TableType';
		


		UPDATE @vars
		SET [Value]=@dtName
		WHERE [Name]=N'DtName';
		UPDATE @vars
		SET [Value]=@readerName
		WHERE [Name]=N'ReaderName';
		UPDATE @vars
		SET [Value]=@tvpName
		WHERE [Name]=N'TvpName';
		
		
		
		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
			CASE WHEN @isTableType=1 THEN @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE WHEN @isOutput=0 THEN @TT_WRAPPER_PARAM_PRE_EXEC_INPUT ELSE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT END)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
    CASE WHEN @hasResultSet=0 THEN @TT_WRAPPER_EXEC WHEN @resultSetWithReturnValue=1 THEN @TT_WRAPPER_EXEC_RS_RV ELSE  @TT_WRAPPER_EXEC_RS END)
	ORDER BY c.[Id];

	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],			
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' 
				ELSE N'(' + ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		
		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PARAM_POST_EXEC)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN ',' ELSE '' END WHERE [Name]=N'Sep';
	
	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_END)
	ORDER BY c.[Id];

	IF @resultSetWithReturnValue=1
    BEGIN
        UPDATE @vars
		SET [Value]=NULL
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=N'int'
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=N'returnValue'
		WHERE [Name]=N'ParamName';		
		
		
		IF @id IS NULL
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM)
		ORDER BY c.[Id];
    END
    

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
		@paramName=p.[ParamName], @isOutput=p.[IsOutput]			
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_END2)
	ORDER BY c.[Id];
END
GO
PRINT N'Creating Procedure [Internal].[GenerateStartCode]...';


GO

CREATE PROCEDURE [Internal].[GenerateStartCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';
	
	DECLARE @codeHeaderPartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeHeader');
	DECLARE @CodeBootstrapPartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeBootstrap');
	


	DECLARE @TT_START_COMMENT TINYINT = 1;
	DECLARE @TT_START_USING TINYINT = 37;
	DECLARE @TT_START_CLASS TINYINT = 38;
	DECLARE @TT_START_COMMENT_TOOL TINYINT = 39;
	DECLARE @TT_START_COMMENT_ENV TINYINT = 40;
	DECLARE @TT_START_COMMENT_END TINYINT = 41;
	DECLARE @TT_STATIC_CTOR_END TINYINT = 42;
	DECLARE @TT_RS_MAPPING_SETUP TINYINT = 43;
	DECLARE @TT_WRAPPER_ENUM_START TINYINT = 48;
	DECLARE @TT_WRAPPER_ENUM_END TINYINT = 49;
	DECLARE @TT_WRAPPER_ENUM_ITEM TINYINT = 50;
	DECLARE @TT_START_CLASS_BOOTSTRAP TINYINT = 51;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	DECLARE @projectName NVARCHAR(200);
	DECLARE @genStaticClass BIT; 
	DECLARE @langOptions BIGINT;
	

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name], @projectName=p.[Name], @langOptions=p.[LanguageOptions]	
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    DECLARE @vars [Internal].[Variable];
	 
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ServerName', CAST(serverproperty('servername') AS NVARCHAR(500)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'InstanceName', @@SERVICENAME);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Database', @dbName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ProjectName', @projectName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Timestamp', CONVERT(NVARCHAR(50), CAST(SYSDATETIME() AS DATETIME2(0)), 120));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'DbUser', ORIGINAL_LOGIN());
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolDatabase', DB_NAME());
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolName', N'TigerWrap');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolUrl', N'https://github.com/rkozlowski/TigerWrap');	
	INSERT INTO @vars ([Name], [Value]) 
	SELECT TOP(1) N'ToolVersion', [Version]
	FROM [dbo].[SchemaVersion]
	ORDER BY [Id] DESC;
	INSERT INTO @vars ([Name], [Value]) VALUES (N'RsType', NULL);


	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_ENV)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_TOOL)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_END)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_USING)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_CLASS)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_CLASS_BOOTSTRAP)
	ORDER BY c.[Id];

	DECLARE @id INT;
	DECLARE @rsType VARCHAR(200);

	SELECT @id=MIN([Id]) FROM #StoredProcResultType;	
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @rsType=rt.[Name]
		FROM #StoredProcResultType rt		
		WHERE rt.[Id]=@id;

		UPDATE @vars
		SET [Value]=@rsType
		WHERE [Name]=N'RsType';

		INSERT INTO #Output ([CodePartId], [Text])
		SELECT @CodeBootstrapPartId, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RS_MAPPING_SETUP)
		ORDER BY c.[Id];

		

		SELECT @id=MIN([Id]) FROM #StoredProcResultType WHERE [Id] > @id;
	END

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_STATIC_CTOR_END)
	ORDER BY c.[Id];

	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumAccess', 'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumName', 'StoredProcedureWrapper');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', '');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', ',');

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_START)
	ORDER BY c.[Id];



	SELECT @id=MIN([Id]) FROM #StoredProc;
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProc);
	DECLARE @wrapperName NVARCHAR(200);
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @wrapperName=[WrapperName]
		FROM #StoredProc WHERE [Id]=@id;

		UPDATE @vars
		SET [Value]=@wrapperName
		WHERE [Name]=N'Name';

		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Text])
		SELECT @CodeBootstrapPartId, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_ITEM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProc WHERE [Id] > @id;
	END

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_END)
	ORDER BY c.[Id];
	
END
GO
PRINT N'Creating Procedure [Internal].[GenerateResultTypeCode]...';


GO



CREATE PROCEDURE [Internal].[GenerateResultTypeCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@rtId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='ResultTypes');

	DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
	DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
	DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;

	DECLARE @NT_CLASS TINYINT = 1;
	DECLARE @NT_METHOD TINYINT = 2;
	DECLARE @NT_PROPERTY TINYINT = 3;
	DECLARE @NT_FIELD TINYINT = 4;
	DECLARE @NT_PARAMETER TINYINT = 5;
	DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
	DECLARE @NT_TUPLE_FIELD TINYINT = 7;
	DECLARE @NT_ENUM TINYINT = 8;
	DECLARE @NT_ENUM_MEMBER TINYINT = 9;

	DECLARE @spId INT;
	DECLARE @typeName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	DECLARE @className NVARCHAR(100);
	DECLARE @langOptions BIGINT;

	SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	SELECT @spId=rt.[StoredProcId], @typeName=rt.[Name], @spSchema=sp.[Schema], @spName=sp.[Name]
	FROM #StoredProcResultType rt
	JOIN #StoredProc sp ON rt.[StoredProcId]=sp.[Id]
	WHERE rt.[Id]=@rtId;

	IF @typeName IS NULL
	BEGIN		
		SET @errorCode='UnknownResultType';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', [Internal].[EscapeString](@langId, QUOTENAME(@spSchema)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', [Internal].[EscapeString](@langId, QUOTENAME(@spName)));
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_START)
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @name NVARCHAR(128);
	DECLARE @columnName NVARCHAR(128);
	DECLARE @type NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @columnName=[Internal].[EscapeString](@langId, rs.[Name]), @name=rs.[PropertyName], 
			@type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN rs.[IsNullable]=1 AND dtm.[IsNullable]=0 THEN N'?' ELSE N'' END
		FROM #StoredProcResultSet rs 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=rs.[SqlType]
		LEFT JOIN #Enum e ON rs.[EnumId]=e.[Id]
		WHERE rs.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@columnName
		WHERE [Name]=N'ColumnName';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_PROPERTY)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_END)
	ORDER BY c.[Id];

	

END
GO
PRINT N'Creating Procedure [Internal].[GenerateEnumCode]...';


GO


CREATE PROCEDURE [Internal].[GenerateEnumCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='Enums');

	DECLARE @TT_ENUM_START TINYINT = 3;
	DECLARE @TT_ENUM_END TINYINT = 4;
	DECLARE @TT_ENUM_ENTRY TINYINT = 5;
    DECLARE @TT_ENUM_START_FLAG TINYINT = 47;

	DECLARE @className NVARCHAR(100);	
	DECLARE @langOptions BIGINT;
	DECLARE @isSetOfFlags BIT;

	SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]	
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @enumName NVARCHAR(100);
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	

	SELECT @enumName=[EnumName], @enumSchema=[Schema], @enumTable=[Table], @isSetOfFlags=[IsSetOfFlags]
	FROM #Enum	
	WHERE [Id]=@enumId;

	IF @enumName IS NULL
	BEGIN		
		SET @errorCode='UnknownEnum';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumName', @enumName);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumSchema', [Internal].[EscapeString](@langId, QUOTENAME(@enumSchema)));	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumTable', [Internal].[EscapeString](@langId, QUOTENAME(@enumTable)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Value', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @enumSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
        CASE WHEN @isSetOfFlags=1 THEN @TT_ENUM_START_FLAG ELSE @TT_ENUM_START END
        )
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @name NVARCHAR(100);
	DECLARE @value NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=[Name], @value=[Value] FROM #EnumVal WHERE [Id]=@id;
		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@value
		WHERE [Name]=N'Value';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @enumSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_ENUM_ENTRY)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @enumSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_ENUM_END)
	ORDER BY c.[Id];

	

END
GO
PRINT N'Creating Procedure [Internal].[GenerateEndCode]...';


GO

CREATE PROCEDURE [Internal].[GenerateEndCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @TT_START TINYINT = 1;
	DECLARE @TT_END TINYINT = 2;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	DECLARE @langOptions BIGINT;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeEnd');

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name], @langOptions=p.[LanguageOptions]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);


	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codePartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_END)
	ORDER BY c.[Id];

END
GO
PRINT N'Creating Procedure [Parser].[TokenizeTSql]...';


GO
CREATE PROCEDURE [Parser].[TokenizeTSql]
	@tsql NVARCHAR(MAX),
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_UNEXPECTED_CHARACTER INT = 1;
    DECLARE @RC_ERR_END_DELIMITER_NOT_FOUND INT = 2;
    DECLARE @RC_ERR_COMMENT_END_NOT_FOUND INT = 3;
    DECLARE @RC_ERR_TOKEN_NOT_RECOGNIZED INT = 4;
    DECLARE @RC_ERR_DB INT = 100;
    
    SET @errorMessage = NULL;

    DECLARE @rc INT = @RC_OK;

    DECLARE @len INT = LEN(@tsql);
    DECLARE @i INT = 1;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @CT_UNKNOWN TINYINT = 0;
    DECLARE @CT_LETTER TINYINT = 1;
    DECLARE @CT_UNICODE_LETTER TINYINT = 2;
    DECLARE @CT_DIGIT TINYINT = 3;
    DECLARE @CT_UNICODE_DIGIT TINYINT = 4;
    DECLARE @CT_OPERATOR TINYINT = 5;
    DECLARE @CT_SEPARATOR TINYINT = 6;
    DECLARE @CT_DELIMITER TINYINT = 7;
    DECLARE @CT_SPECIAL TINYINT = 8;
    DECLARE @CT_WHITESPACE TINYINT = 9;

    DECLARE @ST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @ST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @ST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @ST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @ST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @ST_STRING TINYINT = 6;
    DECLARE @ST_UNICODE_STRING TINYINT = 7;
    DECLARE @ST_INTEGER TINYINT = 8;
    DECLARE @ST_DECIMAL TINYINT = 9;
    DECLARE @ST_MONEY TINYINT = 10;
    DECLARE @ST_REAL TINYINT = 11;
    DECLARE @ST_BINARY TINYINT = 12;
    DECLARE @ST_COMMA TINYINT = 13;
    DECLARE @ST_SEMICOLON TINYINT = 14;
    DECLARE @ST_PERIOD TINYINT = 15;
    DECLARE @ST_VARIABLE_NAME TINYINT = 16;
    DECLARE @ST_UNARY_OPERATOR TINYINT = 17;
    DECLARE @ST_BINARY_OPERATOR TINYINT = 18;
    DECLARE @ST_UNARY_OR_BINARY_OPERATOR TINYINT = 19;

    --DECLARE @lastToken TINYINT = @TT_NONE;
    DECLARE @token TINYINT = @TT_NONE;
    DECLARE @tokenText NVARCHAR(MAX) = '';
    DECLARE @tokenLen INT = 0;
    DECLARE @c NCHAR(1);
    DECLARE @nc NCHAR(1);
    DECLARE @subType TINYINT;
    DECLARE @keyword SMALLINT;
    DECLARE @ct TINYINT;
    DECLARE @nct TINYINT;
    
    DECLARE @j INT;
    DECLARE @k INT;
    DECLARE @endDelim NCHAR(1);
    DECLARE @escDelim NCHAR(2);
    DECLARE @seqLen INT;
    DECLARE @temp NVARCHAR(1000);
    DECLARE @level INT;
    DECLARE @operatorId TINYINT;

    WHILE @i <= @len
    BEGIN
        SET @c = SUBSTRING(@tsql, @i, 1);
        SET @ct = [Parser].[GetCharType](@c);

        IF @token = @TT_NONE
        BEGIN
            SET @subType = NULL;
            SET @keyword = NULL;
            SET @operatorId = NULL;
            
            IF @ct = @CT_WHITESPACE
            BEGIN
                SET @token = @TT_WHITESPACE;
                SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_WHITESPACE, NULL, NULL, NULL);
                SET @tokenText = SUBSTRING(@tsql, @i, @seqLen);
                SET @i += @seqLen;                
            END
            ELSE IF @ct = @CT_DELIMITER
            BEGIN
                IF @c IN (N'(', N')')
                BEGIN
                    SET @token = @TT_DELIMITER;
                    SET @tokenText=@c;
                    SET @i += 1;
                END
                ELSE IF @c = N''''
                BEGIN
                    SET @i += 1;
                    SET @endDelim = N'''';
                    SET @escDelim = N'''''';
                    SET @j = [Parser].[FindEndDelimiter](@tsql, @i, @endDelim, @escDelim);
                    IF @j = 0
                    BEGIN
                        SELECT @rc = @RC_ERR_END_DELIMITER_NOT_FOUND, @errorMessage = N'End delimiter "' + @endDelim + '" not found. Start position: ' + LOWER(@i);  
                        RETURN @rc;
                    END
                    SET @token = @TT_LITERAL;
                    SET @subType = @ST_STRING;
                    SET @tokenText=REPLACE(SUBSTRING(@tsql, @i, @j - @i), @escDelim, @endDelim);
                    SET @i = @j + 1;
                END
                ELSE IF @c = N'['
                BEGIN
                    SET @i += 1;
                    SET @endDelim = N']';
                    SET @escDelim = N']]';
                    SET @j = [Parser].[FindEndDelimiter](@tsql, @i, @endDelim, @escDelim);
                    IF @j = 0
                    BEGIN
                        SELECT @rc = @RC_ERR_END_DELIMITER_NOT_FOUND, @errorMessage = N'End delimiter "' + @endDelim + '" not found. Start position: ' + LOWER(@i);  
                        RETURN @rc;
                    END
                    SET @token = @TT_IDENTIFIER;
                    SET @subType = @ST_IDENTIFIER_IN_BRACKETS;
                    SET @tokenText=REPLACE(SUBSTRING(@tsql, @i, @j - @i), @escDelim, @endDelim);
                    SET @i = @j + 1;
                END
                ELSE IF @c = N'"'
                BEGIN
                    SET @i += 1;
                    SET @endDelim = N'"';
                    SET @escDelim = N'""';
                    SET @j = [Parser].[FindEndDelimiter](@tsql, @i, @endDelim, @escDelim);
                    IF @j = 0
                    BEGIN
                        SELECT @rc = @RC_ERR_END_DELIMITER_NOT_FOUND, @errorMessage = N'End delimiter "' + @endDelim + '" not found. Start position: ' + LOWER(@i);  
                        RETURN @rc;
                    END
                    SET @token = @TT_IDENTIFIER;
                    SET @subType = @ST_IDENTIFIER_IN_DOUBLE_QUOTES;
                    SET @tokenText=REPLACE(SUBSTRING(@tsql, @i, @j - @i), @escDelim, @endDelim);
                    SET @i = @j + 1;
                END
            END
            ELSE IF @ct = @CT_SEPARATOR
            BEGIN
                SET @token = @TT_SEPARATOR;
                SET @tokenText = @c;
                SET @subType = CASE @c WHEN ',' THEN @ST_COMMA WHEN ';' THEN @ST_SEMICOLON WHEN '.' THEN @ST_PERIOD END;
                SET @i += 1;
                IF @subType = @ST_PERIOD AND @i <= @len
                BEGIN                    
                    -- check for numeric value
                    SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL);
                    if @seqLen > 0
                    BEGIN
                        SET @token = @TT_LITERAL;
                        SET @subType = @ST_DECIMAL;
                        SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                        SET @i += @seqLen;
                        IF @i < @len AND LOWER(SUBSTRING(@tsql, @i, 1))='e'
                        BEGIN
                            SET @tokenText += SUBSTRING(@tsql, @i, 1);
                            SET @i += 1;
                            SET @subType = @ST_REAL;
                            IF @i < @len AND SUBSTRING(@tsql, @i, 1) IN ('+', '-')
                            BEGIN
                                SET @tokenText += SUBSTRING(@tsql, @i, 1);
                                SET @i += 1;
                            END
                            SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL);
                            IF @seqLen > 0
                            BEGIN
                                SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                                SET @i += @seqLen;
                            END
                        END
                    END
                    SET @nc = SUBSTRING(@tsql, @i, 1);
                    SET @nct = [Parser].[GetCharType](@nc);
                    IF @nct = @CT_DIGIT
                    BEGIN
                        SET @token = @TT_LITERAL;
                        SET @subType = @ST_DECIMAL;
                        SET @tokenText += @nc;
                        SET @i += 1;
                        
                    END
                END
            END
            ELSE IF @ct = @CT_OPERATOR
            BEGIN
                SET @token = @TT_OPERATOR;
                SET @tokenText = @c;
                SET @i += 1;
                SET @nc = SUBSTRING(@tsql, @i, 1);
                SET @nct = [Parser].[GetCharType](@nc);
                IF @nct = @CT_OPERATOR
                BEGIN
                    SET @temp = @tokenText + @nc;
                    IF EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Operator]=@temp)
                    BEGIN
                        SET @tokenText = @temp;
                        SET @i += 1;
                    END
                    ELSE IF @temp='--'
                    BEGIN
                        -- single line comment
                        SET @token = @TT_COMMENT;
                        SET @subType = @ST_SINGLE_LINE_COMMENT;
                        SET @tokenText = @temp;
                        SET @i += 1;
                        SET @j = CHARINDEX(NCHAR(13), @tsql, @i);
                        SET @k = CHARINDEX(NCHAR(10), @tsql, @i);
                        IF @j = 0 OR (@k > 0 AND @k < @j)
                        BEGIN
                            SET @j = @k;
                        END
                        IF @j = 0
                        BEGIN
                            SET @j = @len + 1;
                        END
                        SET @tokenText += SUBSTRING(@tsql, @i, @j - @i);
                        SET @i = @j;
                    END
                    ELSE IF @temp='/*'
                    BEGIN                        
                        -- multi line comment
                        SET @token = @TT_COMMENT;
                        SET @subType = @ST_MULTI_LINE_COMMENT;
                        SET @tokenText = @temp;
                        SET @i += 1;
                        SET @j = CHARINDEX('*/', @tsql, @i);
                        SET @k = CHARINDEX('/*', @tsql, @i);
                        SET @level = 1;
                        WHILE @level > 0
                        BEGIN
                            if @j = 0
                            BEGIN                                
                                SELECT @rc = @RC_ERR_COMMENT_END_NOT_FOUND, @errorMessage = N'Multi line comment end not found. Start position: ' + LOWER(@i);
                                RETURN @rc;
                            END                            
                            IF @k > 0 AND @k < @j
                            BEGIN
                                SET @level += 1;
                                SET @j = @k;
                            END
                            ELSE
                            BEGIN
                                SET @level -= 1;
                            END
                            SET @tokenText += SUBSTRING(@tsql, @i, @j - @i + 2);
                            SET @i = @j + 2;
                            SET @j = CHARINDEX('*/', @tsql, @i);
                            SET @k = CHARINDEX('/*', @tsql, @i);
                        END
                    END  
                END
                IF @token = @TT_OPERATOR
                BEGIN
                    
                    DECLARE @unary BIT = 0;
                    DECLARE @binary BIT = 0;
                    SELECT @operatorId=[Id], @unary=[Unary], @binary=[Binary]
                    FROM [Parser].[Operator] 
                    WHERE [Operator]=@tokenText;
                    IF @unary=1 AND @binary=0
                    BEGIN
                        SET @subType=@ST_UNARY_OPERATOR;
                    END
                    ELSE IF @unary=0 AND @binary=1
                    BEGIN
                        SET @subType=@ST_BINARY_OPERATOR;
                    END
                    ELSE IF @unary=1 AND @binary=1
                    BEGIN
                        SET @subType=@ST_UNARY_OR_BINARY_OPERATOR;
                    END
                    
                END
            END
            ELSE IF @ct = @CT_DIGIT
            BEGIN
                SET @token = @TT_LITERAL;
                SET @subType = @ST_INTEGER;
                SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL);
                SET @tokenText = SUBSTRING(@tsql, @i, @seqLen);
                SET @i += @seqLen;
                IF (@i <= @len)
                BEGIN
                    SET @nc = SUBSTRING(@tsql, @i, 1);
                    SET @nct = [Parser].[GetCharType](@nc);
                    IF @nc = '.'
                    BEGIN
                        SET @subType = @ST_DECIMAL;
                        SET @tokenText += @nc;
                        SET @i += 1;
                        SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL);
                        SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                        SET @i += @seqLen;
                        IF (@i <= @len)
                        BEGIN
                            SET @nc = SUBSTRING(@tsql, @i, 1);
                            SET @nct = [Parser].[GetCharType](@nc);
                        END
                        ELSE
                        BEGIN
                            SET @nc = ' ';
                        END
                    END                    
                    IF LOWER(@nc) = 'e'
                    BEGIN
                        SET @subType = @ST_REAL;
                        SET @tokenText += @nc;
                        SET @i += 1;
                        IF (@i <= @len)
                        BEGIN
                            SET @nc = SUBSTRING(@tsql, @i, 1);
                            SET @nct = [Parser].[GetCharType](@nc);
                        END
                        ELSE
                        BEGIN
                            SET @nc = ' ';
                        END
                        IF @nc IN ('+', '-')
                        BEGIN
                            SET @tokenText += @nc;
                            SET @i += 1;
                        END
                        SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL);
                        SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                        SET @i += @seqLen;
                    END
                END
            END
            ELSE IF @ct IN (@CT_SPECIAL, @CT_LETTER)
            BEGIN
                IF @i < @len
                BEGIN
                    SET @nc = SUBSTRING(@tsql, @i + 1, 1);
                    SET @nct = [Parser].[GetCharType](@nc);
                END
                ELSE
                BEGIN
                    SET @nc = ' ';
                    SET @nct = 0;
                END
                IF @c = N'N' AND @nc = N''''
                BEGIN                    
                    SET @i += 2;
                    SET @endDelim = N'''';
                    SET @escDelim = N'''''';
                    SET @j = [Parser].[FindEndDelimiter](@tsql, @i, @endDelim, @escDelim);
                    IF @j = 0
                    BEGIN
                        SELECT @rc = @RC_ERR_END_DELIMITER_NOT_FOUND, @errorMessage = N'End delimiter "' + @endDelim + '" not found. Start position: ' + LOWER(@i);  
                        RETURN @rc;
                    END
                    SET @token = @TT_LITERAL;
                    SET @subType = @ST_UNICODE_STRING;
                    SET @tokenText=REPLACE(SUBSTRING(@tsql, @i, @j - @i), @escDelim, @endDelim);
                    SET @i = @j + 1;
                END
                ELSE IF (@c=N'$' AND (@nct=@CT_DIGIT OR @nc=N'.'))
                BEGIN                    
                    SET @token = @TT_LITERAL;
                    SET @subType = @ST_MONEY;
                    SET @tokenText = @c;
                    SET @i += 1;
                    IF @nct=@CT_DIGIT
                    BEGIN
                        SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL); 
                        SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                        SET @i += @seqLen;
                        IF @i <= @len
                        BEGIN
                            SET @nc = SUBSTRING(@tsql, @i, 1);
                            SET @nct = [Parser].[GetCharType](@nc);
                        END
                        ELSE
                        BEGIN
                            SET @nc = ' ';
                            SET @nct = 0;
                        END
                    END
                    IF @nc=N'.'
                    BEGIN
                        SET @tokenText += @nc;
                        SET @i += 1;
                        SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_DIGIT, NULL, NULL, NULL); 
                        SET @tokenText += SUBSTRING(@tsql, @i, @seqLen);
                        SET @i += @seqLen;
                    END                    
                END
                ELSE
                BEGIN                    
                    SET @token = @TT_IDENTIFIER;
                
                    SET @seqLen = [Parser].[GetSequenceLength](@tsql, @i, @len, @CT_LETTER, @CT_DIGIT, @CT_SPECIAL, NULL);                    
                    SET @tokenText = SUBSTRING(@tsql, @i, @seqLen);
                    SET @i += @seqLen;

                    -- set subtype, check keyword etc                    
                    SELECT @keyword=kw.[Id]
                    FROM [ParserEnum].[TSqlKeyword] kw
                    WHERE kw.[Name]=UPPER(@tokenText);                    
                    IF @keyword IS NOT NULL
                    BEGIN
                        SET @token = @TT_KEYWORD;
                    END
                    ELSE
                    BEGIN
                        SET @subType = CASE WHEN @tokenText LIKE N'@%' THEN @ST_VARIABLE_NAME ELSE @ST_REGULAR_IDENTIFIER END;                        
                    END
                END
            END

            IF @token <>@TT_NONE
            BEGIN
                INSERT INTO #Token ([TypeId], [SubtypeId], [KeywordId], [OperatorId], [Text])
                VALUES (@token, @subType, @keyword, @operatorId, @tokenText);
                SET @token=@TT_NONE;
            END
            ELSE
            BEGIN
                SELECT @rc = @RC_ERR_TOKEN_NOT_RECOGNIZED, 
                    @errorMessage = N'Token not recognized. Start position: ' + LOWER(@i) +  N'; Text: ' + NCHAR(13) + NCHAR(10) + SUBSTRING(@tsql, @i, 50); 
                RETURN @rc;
            END

        END
    END


    -- intentionally adding additional empty token at the end
    -- to make sure parser wouldn't run out of tokens while matching end element
    INSERT INTO #Token ([TypeId], [SubtypeId], [KeywordId], [Text]) 
    VALUES (@TT_WHITESPACE, NULL, NULL, N'');

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Parser].[TryParseSequence]...';


GO


CREATE PROCEDURE [Parser].[TryParseSequence]
    @tokenId INT,
    @sequenceId SMALLINT,
    @parentStatementId INT,
    @parentStatementPartId TINYINT,
    @lastTokenId INT OUTPUT,
    @isFinished BIT OUTPUT,
    @statementSeparatorTokenId INT OUTPUT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

    --PRINT(N'[Parser].[TryParseSequence] @tokenId: ' + LOWER(@tokenId) + N'; @sequenceId: ' + LOWER(@sequenceId));
	--PRINT(N'[Parser].[TryParseSequence] @parentStatementId: ' + ISNULL(LOWER(@parentStatementId), '<NULL>') + N'; @parentStatementPartId: ' + ISNULL(LOWER(@parentStatementPartId), '<NULL>'));

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_NOT_MATCH INT = 1;

    DECLARE @RC_ERR_DATA INT = 10;

    DECLARE @RC_ERR_DB INT = 100;
    
    SELECT @lastTokenId=NULL, @isFinished=0, @statementSeparatorTokenId=NULL,  @errorMessage=NULL;

    DECLARE @rc INT = @RC_NOT_MATCH;

    DECLARE @startTokenId INT = @tokenId;

    DECLARE @ET_KEYWORD TINYINT = 1;
    DECLARE @ET_IDENTIFIER TINYINT = 2;
    DECLARE @ET_OPERATOR TINYINT = 3;
    DECLARE @ET_SEPARATOR TINYINT = 4;
    DECLARE @ET_DELIMITER TINYINT = 5;
    DECLARE @ET_STATEMENT TINYINT = 6;
    DECLARE @ET_SEQUENCE_OF_STATEMENTS TINYINT = 7;
    DECLARE @ET_BLOCK TINYINT = 8;
    DECLARE @ET_LITERAL_STRING TINYINT = 9;
    DECLARE @ET_SEQUENCE TINYINT = 10;
    DECLARE @ET_END TINYINT = 11;
    DECLARE @ET_LITERAL_INT TINYINT = 12;
    DECLARE @ET_VARIABLE_NAME TINYINT = 13;
    DECLARE @ET_SPECIAL_SEQUENCE TINYINT = 14;
    DECLARE @ET_LITERAL TINYINT = 15;

    DECLARE @SQT_NORMAL TINYINT = 1;
    DECLARE @SQT_ANY_STATEMENT TINYINT = 2;
    DECLARE @SQT_BLOCK_STATEMENT TINYINT = 3;
    DECLARE @SQT_SEQUENCE_OF_STATEMENTS TINYINT = 4;
    DECLARE @SQT_TWO_PART_IDENTIFIER TINYINT = 5;
    DECLARE @SQT_THREE_PART_IDENTIFIER TINYINT = 6;
    DECLARE @SQT_MORE_TOKENS TINYINT = 7;
    DECLARE @SQT_LABEL TINYINT = 8;
    DECLARE @SQT_BEGIN_BLOCK TINYINT = 9;
    DECLARE @SQT_END_BLOCK TINYINT = 10;
    DECLARE @SQT_SEQUENCE_IN_PARENTHESES TINYINT = 11;
    DECLARE @SQT_FOUR_PART_IDENTIFIER TINYINT = 12;
    DECLARE @SQT_SCALAR_EXPRESSION TINYINT = 13;
    DECLARE @SQT_OUTPUT_CLAUSE TINYINT = 14;
    DECLARE @SQT_CASE_EXPRESSION TINYINT = 15;

    DECLARE @SP_IDENTIFIER TINYINT = 1;
    DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
    DECLARE @SP_DEFINITION TINYINT = 3;
    DECLARE @SP_CHILD_STATEMENT TINYINT = 4;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @TST_STRING TINYINT = 6;
    DECLARE @TST_UNICODE_STRING TINYINT = 7;
    DECLARE @TST_INTEGER TINYINT = 8;
    DECLARE @TST_DECIMAL TINYINT = 9;
    DECLARE @TST_MONEY TINYINT = 10;
    DECLARE @TST_REAL TINYINT = 11;
    DECLARE @TST_BINARY TINYINT = 12;
    DECLARE @TST_COMMA TINYINT = 13;
    DECLARE @TST_SEMICOLON TINYINT = 14;
    DECLARE @TST_PERIOD TINYINT = 15;
    DECLARE @TST_VARIABLE_NAME TINYINT = 16;

    DECLARE @BT_REGULAR_BLOCK TINYINT = 1;
    DECLARE @BT_TRY_BLOCK TINYINT = 2;
    DECLARE @BT_CATCH_BLOCK TINYINT = 3;
    DECLARE @BT_ATOMIC_BLOCK TINYINT = 4;
    DECLARE @BT_CASE_BLOCK TINYINT = 5;


    DECLARE @KW_ADD SMALLINT = 1;
    DECLARE @KW_ALL SMALLINT = 2;
    DECLARE @KW_ALTER SMALLINT = 3;
    DECLARE @KW_AND SMALLINT = 4;
    DECLARE @KW_ANY SMALLINT = 5;
    DECLARE @KW_AS SMALLINT = 6;
    DECLARE @KW_ASC SMALLINT = 7;
    DECLARE @KW_AUTHORIZATION SMALLINT = 8;
    DECLARE @KW_BACKUP SMALLINT = 9;
    DECLARE @KW_BEGIN SMALLINT = 10;
    DECLARE @KW_BETWEEN SMALLINT = 11;
    DECLARE @KW_BREAK SMALLINT = 12;
    DECLARE @KW_BROWSE SMALLINT = 13;
    DECLARE @KW_BULK SMALLINT = 14;
    DECLARE @KW_BY SMALLINT = 15;
    DECLARE @KW_CASCADE SMALLINT = 16;
    DECLARE @KW_CASE SMALLINT = 17;
    DECLARE @KW_CHECK SMALLINT = 18;
    DECLARE @KW_CHECKPOINT SMALLINT = 19;
    DECLARE @KW_CLOSE SMALLINT = 20;
    DECLARE @KW_CLUSTERED SMALLINT = 21;
    DECLARE @KW_COALESCE SMALLINT = 22;
    DECLARE @KW_COLLATE SMALLINT = 23;
    DECLARE @KW_COLUMN SMALLINT = 24;
    DECLARE @KW_COMMIT SMALLINT = 25;
    DECLARE @KW_COMPUTE SMALLINT = 26;
    DECLARE @KW_CONSTRAINT SMALLINT = 27;
    DECLARE @KW_CONTAINS SMALLINT = 28;
    DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
    DECLARE @KW_CONTINUE SMALLINT = 30;
    DECLARE @KW_CONVERT SMALLINT = 31;
    DECLARE @KW_CREATE SMALLINT = 32;
    DECLARE @KW_CROSS SMALLINT = 33;
    DECLARE @KW_CURRENT SMALLINT = 34;
    DECLARE @KW_CURRENT_DATE SMALLINT = 35;
    DECLARE @KW_CURRENT_TIME SMALLINT = 36;
    DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
    DECLARE @KW_CURRENT_USER SMALLINT = 38;
    DECLARE @KW_CURSOR SMALLINT = 39;
    DECLARE @KW_DATABASE SMALLINT = 40;
    DECLARE @KW_DBCC SMALLINT = 41;
    DECLARE @KW_DEALLOCATE SMALLINT = 42;
    DECLARE @KW_DECLARE SMALLINT = 43;
    DECLARE @KW_DEFAULT SMALLINT = 44;
    DECLARE @KW_DELETE SMALLINT = 45;
    DECLARE @KW_DENY SMALLINT = 46;
    DECLARE @KW_DESC SMALLINT = 47;
    DECLARE @KW_DISK SMALLINT = 48;
    DECLARE @KW_DISTINCT SMALLINT = 49;
    DECLARE @KW_DISTRIBUTED SMALLINT = 50;
    DECLARE @KW_DOUBLE SMALLINT = 51;
    DECLARE @KW_DROP SMALLINT = 52;
    DECLARE @KW_DUMP SMALLINT = 53;
    DECLARE @KW_ELSE SMALLINT = 54;
    DECLARE @KW_END SMALLINT = 55;
    DECLARE @KW_ERRLVL SMALLINT = 56;
    DECLARE @KW_ESCAPE SMALLINT = 57;
    DECLARE @KW_EXCEPT SMALLINT = 58;
    DECLARE @KW_EXEC SMALLINT = 59;
    DECLARE @KW_EXECUTE SMALLINT = 60;
    DECLARE @KW_EXISTS SMALLINT = 61;
    DECLARE @KW_EXIT SMALLINT = 62;
    DECLARE @KW_EXTERNAL SMALLINT = 63;
    DECLARE @KW_FETCH SMALLINT = 64;
    DECLARE @KW_FILE SMALLINT = 65;
    DECLARE @KW_FILLFACTOR SMALLINT = 66;
    DECLARE @KW_FOR SMALLINT = 67;
    DECLARE @KW_FOREIGN SMALLINT = 68;
    DECLARE @KW_FREETEXT SMALLINT = 69;
    DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
    DECLARE @KW_FROM SMALLINT = 71;
    DECLARE @KW_FULL SMALLINT = 72;
    DECLARE @KW_FUNCTION SMALLINT = 73;
    DECLARE @KW_GOTO SMALLINT = 74;
    DECLARE @KW_GRANT SMALLINT = 75;
    DECLARE @KW_GROUP SMALLINT = 76;
    DECLARE @KW_HAVING SMALLINT = 77;
    DECLARE @KW_HOLDLOCK SMALLINT = 78;
    DECLARE @KW_IDENTITY SMALLINT = 79;
    DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
    DECLARE @KW_IDENTITYCOL SMALLINT = 81;
    DECLARE @KW_IF SMALLINT = 82;
    DECLARE @KW_IN SMALLINT = 83;
    DECLARE @KW_INDEX SMALLINT = 84;
    DECLARE @KW_INNER SMALLINT = 85;
    DECLARE @KW_INSERT SMALLINT = 86;
    DECLARE @KW_INTERSECT SMALLINT = 87;
    DECLARE @KW_INTO SMALLINT = 88;
    DECLARE @KW_IS SMALLINT = 89;
    DECLARE @KW_JOIN SMALLINT = 90;
    DECLARE @KW_KEY SMALLINT = 91;
    DECLARE @KW_KILL SMALLINT = 92;
    DECLARE @KW_LEFT SMALLINT = 93;
    DECLARE @KW_LIKE SMALLINT = 94;
    DECLARE @KW_LINENO SMALLINT = 95;
    DECLARE @KW_LOAD SMALLINT = 96;
    DECLARE @KW_MERGE SMALLINT = 97;
    DECLARE @KW_NATIONAL SMALLINT = 98;
    DECLARE @KW_NOCHECK SMALLINT = 99;
    DECLARE @KW_NONCLUSTERED SMALLINT = 100;
    DECLARE @KW_NOT SMALLINT = 101;
    DECLARE @KW_NULL SMALLINT = 102;
    DECLARE @KW_NULLIF SMALLINT = 103;
    DECLARE @KW_OF SMALLINT = 104;
    DECLARE @KW_OFF SMALLINT = 105;
    DECLARE @KW_OFFSETS SMALLINT = 106;
    DECLARE @KW_ON SMALLINT = 107;
    DECLARE @KW_OPEN SMALLINT = 108;
    DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
    DECLARE @KW_OPENQUERY SMALLINT = 110;
    DECLARE @KW_OPENROWSET SMALLINT = 111;
    DECLARE @KW_OPENXML SMALLINT = 112;
    DECLARE @KW_OPTION SMALLINT = 113;
    DECLARE @KW_OR SMALLINT = 114;
    DECLARE @KW_ORDER SMALLINT = 115;
    DECLARE @KW_OUTER SMALLINT = 116;
    DECLARE @KW_OVER SMALLINT = 117;
    DECLARE @KW_PERCENT SMALLINT = 118;
    DECLARE @KW_PIVOT SMALLINT = 119;
    DECLARE @KW_PLAN SMALLINT = 120;
    DECLARE @KW_PRECISION SMALLINT = 121;
    DECLARE @KW_PRIMARY SMALLINT = 122;
    DECLARE @KW_PRINT SMALLINT = 123;
    DECLARE @KW_PROC SMALLINT = 124;
    DECLARE @KW_PROCEDURE SMALLINT = 125;
    DECLARE @KW_PUBLIC SMALLINT = 126;
    DECLARE @KW_RAISERROR SMALLINT = 127;
    DECLARE @KW_READ SMALLINT = 128;
    DECLARE @KW_READTEXT SMALLINT = 129;
    DECLARE @KW_RECONFIGURE SMALLINT = 130;
    DECLARE @KW_REFERENCES SMALLINT = 131;
    DECLARE @KW_REPLICATION SMALLINT = 132;
    DECLARE @KW_RESTORE SMALLINT = 133;
    DECLARE @KW_RESTRICT SMALLINT = 134;
    DECLARE @KW_RETURN SMALLINT = 135;
    DECLARE @KW_REVERT SMALLINT = 136;
    DECLARE @KW_REVOKE SMALLINT = 137;
    DECLARE @KW_RIGHT SMALLINT = 138;
    DECLARE @KW_ROLLBACK SMALLINT = 139;
    DECLARE @KW_ROWCOUNT SMALLINT = 140;
    DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
    DECLARE @KW_RULE SMALLINT = 142;
    DECLARE @KW_SAVE SMALLINT = 143;
    DECLARE @KW_SCHEMA SMALLINT = 144;
    DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
    DECLARE @KW_SELECT SMALLINT = 146;
    DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
    DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
    DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
    DECLARE @KW_SESSION_USER SMALLINT = 150;
    DECLARE @KW_SET SMALLINT = 151;
    DECLARE @KW_SETUSER SMALLINT = 152;
    DECLARE @KW_SHUTDOWN SMALLINT = 153;
    DECLARE @KW_SOME SMALLINT = 154;
    DECLARE @KW_STATISTICS SMALLINT = 155;
    DECLARE @KW_SYSTEM_USER SMALLINT = 156;
    DECLARE @KW_TABLE SMALLINT = 157;
    DECLARE @KW_TABLESAMPLE SMALLINT = 158;
    DECLARE @KW_TEXTSIZE SMALLINT = 159;
    DECLARE @KW_THEN SMALLINT = 160;
    DECLARE @KW_TO SMALLINT = 161;
    DECLARE @KW_TOP SMALLINT = 162;
    DECLARE @KW_TRAN SMALLINT = 163;
    DECLARE @KW_TRANSACTION SMALLINT = 164;
    DECLARE @KW_TRIGGER SMALLINT = 165;
    DECLARE @KW_TRUNCATE SMALLINT = 166;
    DECLARE @KW_TRY_CONVERT SMALLINT = 167;
    DECLARE @KW_TSEQUAL SMALLINT = 168;
    DECLARE @KW_UNION SMALLINT = 169;
    DECLARE @KW_UNIQUE SMALLINT = 170;
    DECLARE @KW_UNPIVOT SMALLINT = 171;
    DECLARE @KW_UPDATE SMALLINT = 172;
    DECLARE @KW_UPDATETEXT SMALLINT = 173;
    DECLARE @KW_USE SMALLINT = 174;
    DECLARE @KW_USER SMALLINT = 175;
    DECLARE @KW_VALUES SMALLINT = 176;
    DECLARE @KW_VARYING SMALLINT = 177;
    DECLARE @KW_VIEW SMALLINT = 178;
    DECLARE @KW_WAITFOR SMALLINT = 179;
    DECLARE @KW_WHEN SMALLINT = 180;
    DECLARE @KW_WHERE SMALLINT = 181;
    DECLARE @KW_WHILE SMALLINT = 182;
    DECLARE @KW_WITH SMALLINT = 183;
    DECLARE @KW_WITHIN SMALLINT = 184;
    DECLARE @KW_WRITETEXT SMALLINT = 185;
    DECLARE @KW_ATOMIC SMALLINT = 186;
    DECLARE @KW_CONVERSATION SMALLINT = 187;
    DECLARE @KW_DIALOG SMALLINT = 188;
    DECLARE @KW_CATCH SMALLINT = 189;
    DECLARE @KW_TRY SMALLINT = 190;
    DECLARE @KW_THROW SMALLINT = 191;
    DECLARE @KW_FILETABLE SMALLINT = 192;
    DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;

    DECLARE @elementId INT;

    DECLARE @typeId [tinyint];
    --DECLARE @sequenceId [smallint];
    --DECLARE @isStartElement [bit];
    DECLARE @nextElementId [int];
    DECLARE @altElementId [int];
    DECLARE @keywordId [smallint];
    DECLARE @operatorId [tinyint];
    DECLARE @sequenceTypeId [tinyint];
    DECLARE @statementPartId [tinyint];
    DECLARE @tokenTypeId [tinyint];
    DECLARE @tokenSubtypeId [tinyint];
    DECLARE @stringValue [nvarchar](200);
    DECLARE @intValue [bigint];

    DECLARE @tkTypeId TINYINT;
    DECLARE @tkKeywordId SMALLINT;
    DECLARE @tkSubtypeId SMALLINT;
    DECLARE @tkText NVARCHAR(MAX);
    DECLARE @tkLevel SMALLINT;
    DECLARE @tkStartTokenId INT;
    DECLARE @tkEndTokenId INT;
    DECLARE @tkBlockTypeId TINYINT;
    DECLARE @tkSeqStartTokenId INT;
    DECLARE @tkSeqEndTokenId INT;
    DECLARE @tkSeqTypeId TINYINT;
    DECLARE @tkOperatorId TINYINT;
    DECLARE @match BIT = 0;
    DECLARE @done BIT = 0;
    
    SELECT @elementId=MIN(el.[Id])
    FROM [Parser].[TSqlSeqElement] el
    WHERE el.[SequenceId]=@sequenceId;

    --PRINT('Get token details');
    SELECT @tkTypeId=tk.[TypeId], @tkKeywordId=tk.[KeywordId], @tkSubtypeId=tk.[SubtypeId], @tkText=tk.[Text], @tkLevel=tk.[Level], @tkStartTokenId=tk.[StartTokenId],
        @tkEndTokenId=tk.[EndTokenId], @tkBlockTypeId=tk.[BlockTypeId], @tkSeqStartTokenId=tk.[SeqStartTokenId], @tkSeqEndTokenId=tk.[SeqEndTokenId], 
        @tkSeqTypeId=tk.[SeqTypeId], @tkOperatorId=tk.[OperatorId]
    FROM #Token tk
    WHERE tk.[Id]=@tokenId;

    DECLARE @statementId INT = NULL;
    DECLARE @statementTypeId SMALLINT = NULL;
    DECLARE @isNewStatement BIT = 0;
    DECLARE @lastTokenIdBeforeChildStatement INT = NULL;

    SELECT @statementTypeId=st.[Id]
    FROM [Parser].[TSqlSequence] seq 
    JOIN [ParserEnum].[TSqlStatementType] st ON seq.[StatementTypeId]=st.[Id]
    WHERE seq.[Id]=@sequenceId;

    IF @statementTypeId IS NOT NULL
    BEGIN
		--PRINT('INSERT Statement ' + LOWER(@statementTypeId) + ', ' + LOWER(@tokenId));
        INSERT INTO #Statement ([TypeId], [StartTokenId])
        VALUES (@statementTypeId, @tokenId);
        SET @statementId=SCOPE_IDENTITY();
        SET @isNewStatement=1;
    END
    ELSE
    BEGIN
        SELECT @statementId=MAX([Id])
        FROM #Statement;
    END

    IF @statementId IS NULL
    BEGIN
        SELECT @rc=@RC_ERR_DATA, @errorMessage=N'Statement Id not set. Sequence Id: ' + @sequenceId;
        RETURN @rc;
    END

    DECLARE @tpsRc INT;
    DECLARE @tpsParentStatementId INT;
    DECLARE @tpsParentStatementPartId TINYINT;
    DECLARE @tpsLastTokenId INT;
    DECLARE @tpsIsFinished BIT;
    DECLARE @tpsStatementSeparatorTokenId INT;
    DECLARE @tpsErrorMessage NVARCHAR(4000);
    DECLARE @tpsSequenceId SMALLINT;
    DECLARE @elStatementTypeId SMALLINT;
    
    WHILE @elementId IS NOT NULL AND @done=0
    BEGIN
        --PRINT('Get element details');
        SELECT @typeId=el.[TypeId], @nextElementId=el.[NextElementId], @altElementId=el.[AltElementId], @keywordId=el.[KeywordId], @operatorId=el.[OperatorId],
            @sequenceTypeId=el.[SequenceTypeId], @statementPartId=el.[StatementPartId], @tokenTypeId=el.[TokenTypeId], @tokenSubtypeId=el.[TokenSubtypeId],
            @elStatementTypeId=el.[StatementTypeId], @stringValue=el.[StringValue], @intValue=el.[IntValue]
        FROM [Parser].[TSqlSeqElement] el
        WHERE el.[Id]=@elementId;

        

        --PRINT('Check if they match');
        
        SET @match=0;
        --SET @lastTokenId=NULL;

        IF @typeId=@ET_KEYWORD
        BEGIN
            IF @tkTypeId=@tokenTypeId AND @tkKeywordId=@keywordId
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId IN (@ET_IDENTIFIER, @ET_VARIABLE_NAME, @ET_SEPARATOR)
        BEGIN
            IF @tkTypeId=@tokenTypeId AND (@tokenSubtypeId IS NULL OR @tokenSubtypeId=@tkSubtypeId)
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId=@ET_OPERATOR
        BEGIN
            --PRINT('Operator');
            IF @tkTypeId=ISNULL(@tokenTypeId, @TT_OPERATOR) AND (@operatorId IS NULL OR @tkOperatorId=@operatorId) -- subtype?
            BEGIN
                SET @lastTokenId = @tkEndTokenId;
                SET @match=1;
                --PRINT('Operator match');
            END
        END ELSE IF @typeId IN (@ET_LITERAL, @ET_LITERAL_INT, @ET_LITERAL_STRING)
        BEGIN
            IF @tkTypeId=ISNULL(@tokenTypeId, @TT_LITERAL) AND ((@typeId=@ET_LITERAL_INT AND @tkSubtypeId=@TST_INTEGER) OR (@typeId=@ET_LITERAL_STRING AND @tkSubtypeId IN (@TST_STRING, @TST_UNICODE_STRING)) 
                OR (@typeId=@ET_LITERAL AND (@tokenSubtypeId IS NULL OR @tkSubtypeId=@tokenSubtypeId)))
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId IN (@ET_SEQUENCE, @ET_STATEMENT)
        BEGIN
            IF @typeId=@ET_SEQUENCE
            BEGIN
                --PRINT('@ET_SEQUENCE');
                SELECT @tpsSequenceId=[Id]
                FROM [Parser].[TSqlSequence] WHERE [SequenceTypeId]=@sequenceTypeId;
            END
            ELSE
            BEGIN
                --PRINT('@ET_STATEMENT');
                SET @lastTokenIdBeforeChildStatement = @lastTokenId;
                SELECT @tpsSequenceId=[Id]
                FROM [Parser].[TSqlSequence] WHERE [StatementTypeId]=@elStatementTypeId;
            END
            -- recursively call [Parser].[TryParseStatement]
            EXEC @tpsRc = [Parser].[TryParseSequence] @tokenId, @tpsSequenceId, @statementId, @statementPartId, 
                @tpsLastTokenId OUTPUT, @tpsIsFinished OUTPUT, @tpsStatementSeparatorTokenId OUTPUT, @tpsErrorMessage OUTPUT;
            IF @tpsRc=@RC_OK
            BEGIN
                SET @match=1;
                SET @lastTokenId = @tpsLastTokenId;
            END
            ELSE IF @tpsRc<>@RC_NOT_MATCH
            BEGIN
                SET @errorMessage = N'[TryParseSequence] recursive call returned : ' + LOWER(@tpsRc) + N' - ' + ISNULL(@tpsErrorMessage, '<NULL>');
                SET @rc = @RC_ERR_DATA;
                RETURN @rc;
            END

        END ELSE IF @typeId=@ET_SPECIAL_SEQUENCE
        BEGIN
            --PRINT('@ET_SPECIAL_SEQUENCE');
            IF @sequenceTypeId = @SQT_MORE_TOKENS
            BEGIN
                SET @done = 1;
                SET @lastTokenId = @tokenId;
                SET @match = 1;
                SET @isFinished = 0;
                SELECT @statementSeparatorTokenId = MIN([Id])
                FROM #Token
                WHERE [Id] > @tokenId AND [TypeId]=@TT_SEPARATOR AND [SubtypeId]=@TST_SEMICOLON;
            END
            ELSE IF @sequenceTypeId=@SQT_SEQUENCE_IN_PARENTHESES AND @tkTypeId=@TT_DELIMITER AND @tkText=N'('
            BEGIN
                SET @match = 1;
                SET @lastTokenId = @tkEndTokenId;
            END
            ELSE IF @sequenceTypeId=@SQT_CASE_EXPRESSION AND @tkBlockTypeId=@BT_CASE_BLOCK AND @tkKeywordId=@KW_CASE
            BEGIN
                SET @match = 1;
                SET @lastTokenId = @tkEndTokenId;
            END
        END ELSE IF @typeId=@ET_END
        BEGIN
            --PRINT('@ET_END');
            SET @done = 1;
            SET @match = 1;
            SET @isFinished = 1;
        END ELSE
        BEGIN
            PRINT('???');
            SELECT @rc = @RC_ERR_DATA, @errorMessage=N'Unexpected element type: ' + LOWER(@typeId);
            RETURN @rc;
        END
        
        IF @done=1
        BEGIN
            --PRINT('MATCH');
            SET @elementId=NULL;
            SET @rc = @RC_OK;
            IF @parentStatementId IS NOT NULL AND  @parentStatementPartId IS NOT NULL
            BEGIN
				/*
				PRINT ('StatementPart ' + ISNULL(LOWER(@parentStatementId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@parentStatementPartId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@startTokenId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@lastTokenId), '<NULL>'));
				*/
                INSERT INTO #StatementPart ([StatementId], [TypeId], [StartTokenId], [EndTokenId])
                VALUES (@parentStatementId, @parentStatementPartId, @startTokenId, @lastTokenId);
            END
            IF @isNewStatement=1
            BEGIN
				--PRINT('******');
				--PRINT('[ParentStatementId]: ' + ISNULL(LOWER(@typeId), '<NULL>') + ' (' + LOWER(@ET_STATEMENT) + '), ' +  ISNULL(LOWER(@parentStatementId), '<NULL>'));
                UPDATE #Statement
                SET [EndTokenId]=ISNULL(@lastTokenIdBeforeChildStatement, @lastTokenId), [IsFinished]=@isFinished, [StatementSeparatorTokenId]=@statementSeparatorTokenId, 
                --[ParentStatementId]=CASE WHEN @typeId=@ET_STATEMENT THEN @parentStatementId ELSE NULL END
				[ParentStatementId]=@parentStatementId
                WHERE [Id]=@statementId;
				SET @isNewStatement=0; -- ????
				--PRINT ('UPDATE: ' + LOWER(@statementId) + '; Parent: ' + ISNULL(LOWER(CASE WHEN @typeId=@ET_STATEMENT THEN @parentStatementId ELSE NULL END), '<NULL>'));
				--PRINT('!!!!');
            END
        END
        ELSE
        BEGIN
            IF @match=0
            BEGIN
                SET @elementId=@altElementId;
                IF @elementId IS NULL
                BEGIN
                    --PRINT('NOT MATCH');
                    SET @rc = @RC_NOT_MATCH;
                    SET @done=1;
                    -- revert inserts from recursive calls
                    SET @statementId=SCOPE_IDENTITY();
                    SET @isNewStatement=1;
                    IF @isNewStatement=1
                    BEGIN
                        DELETE FROM #StatementPart
                        WHERE [StatementId]>=@statementId;
                        
                        DELETE FROM #Statement
                        WHERE [Id]>=@statementId;
                    END
                    ELSE
                    BEGIN
                        DELETE FROM #StatementPart
                        WHERE [StatementId]>@statementId;
                        
                        DELETE FROM #Statement
                        WHERE [Id]>@statementId;
                    END
                END
            END
            ELSE
            BEGIN
                
                IF @lastTokenId IS NULL OR @lastTokenId<@tokenId
                BEGIN
                    SET @lastTokenId = @tokenId;
                END

                SET @elementId=@nextElementId;
                IF @elementId IS NULL
                BEGIN
                    PRINT('ERROR');
                    SELECT @rc = @RC_ERR_DATA, @errorMessage=N'Next element not set. Sequence Id: ' + LOWER(@sequenceId);
                    RETURN @rc;
                END
                SELECT TOP(1) @tokenId=tk.[Id], @tkTypeId=tk.[TypeId], @tkKeywordId=tk.[KeywordId], @tkSubtypeId=tk.[SubtypeId], @tkText=tk.[Text], @tkLevel=tk.[Level], @tkStartTokenId=tk.[StartTokenId],
                    @tkEndTokenId=tk.[EndTokenId], @tkBlockTypeId=tk.[BlockTypeId], @tkSeqStartTokenId=tk.[SeqStartTokenId], @tkSeqEndTokenId=tk.[SeqEndTokenId],
                    @tkSeqTypeId=tk.[SeqTypeId], @tkOperatorId=tk.[OperatorId]
                FROM #Token tk
                WHERE tk.[Id]>@lastTokenId AND tk.[TypeId] NOT IN (@TT_COMMENT, @TT_WHITESPACE)
                ORDER BY tk.[Id];
            END
        END
        
        
        
        
    END

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Parser].[GetSeqElemIdRange]...';


GO

CREATE PROCEDURE [Parser].[GetSeqElemIdRange]
	@rangeLen INT = 1
AS
BEGIN
	DECLARE @firstId INT;

    IF ISNULL(@rangeLen, 0) < 1
    BEGIN
        SET @rangeLen = 1;
    END

    DROP TABLE IF EXISTS #SeqElemIdRange;

    CREATE TABLE #SeqElemIdRange
    (
        [NextId] INT NOT NULL PRIMARY KEY,
    );

    INSERT INTO #SeqElemIdRange ([NextId])
    SELECT NEXT VALUE FOR [Parser].[TSqlSeqEl] OVER (ORDER BY n.[N]) [NextId]
    FROM [Static].[Number] n 
    WHERE n.[N] BETWEEN 1 AND @rangeLen    
    ORDER BY n.[N];

    SELECT @firstId = MIN([NextId])
    FROM #SeqElemIdRange;

    DROP TABLE IF EXISTS #SeqElemIdRange;

	RETURN @firstId;
END
GO
PRINT N'Creating Procedure [Project].[CreateProject]...';


GO
CREATE PROCEDURE [Project].[CreateProject]
	@name NVARCHAR(200),
	@namespaceName VARCHAR(100),
	@className VARCHAR(100),
	@errorMessage NVARCHAR(2000) OUTPUT,
	@defaultDatabase NVARCHAR(128) = NULL,
	@enumSchema NVARCHAR(128) = NULL,
	@storedProcSchema NVARCHAR(128) = NULL,
	@classAccess VARCHAR(200) = 'public',	
	@language VARCHAR(200) = 'c#',
	@paramEnumMapping VARCHAR(100) = NULL, 
	@mapResultSetEnums BIT = 0,
	@languageOptions VARCHAR(1000) = NULL
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

    SET LOCK_TIMEOUT 1000; -- wait for up to 1 seconds for a lock to be released.
	SET DEADLOCK_PRIORITY NORMAL;

	
	DECLARE @RC_OK INT = 0;	
	DECLARE @RC_DB_ERROR INT = 1;
	DECLARE @RC_INTERNAL_ERROR INT = 2;
	
    DECLARE @NM_EXACT_MATCH TINYINT = 1;
    DECLARE @NM_PREFIX TINYINT = 2;
    DECLARE @NM_SUFFIX TINYINT = 3;
    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;

	DECLARE @rc INT;
	DECLARE @errorCode VARCHAR(100) = 'InternalError'
	
	DECLARE @tranCount INT = @@TRANCOUNT;

	DECLARE @classAccessId TINYINT = (SELECT [Id] FROM [Enum].[ClassAccess] WHERE [Name]=@classAccess);
	IF @classAccessId IS NULL
	BEGIN
		SET @errorCode = 'InvalidClassAccess';
		SELECT @rc=[Id], @errorMessage='Invalid class access: ' + ISNULL(@classAccess, '<NULL>')
		FROM [Enum].[ToolkitResponseCode] WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @languageId TINYINT = (SELECT [Id] FROM [Enum].[Language] WHERE [Name]=@language);
	IF @languageId IS NULL
	BEGIN
		SET @errorCode = 'InvalidLanguage';
		SELECT @rc=[Id], @errorMessage='Invalid programming language: ' + ISNULL(@language, '<NULL>')
		FROM [Enum].[ToolkitResponseCode] WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @paramEnumMappingId TINYINT = (SELECT [Id] FROM [Enum].[ParamEnumMapping] WHERE [Name]=ISNULL(@paramEnumMapping, 'ExplicitOnly'));
	IF @paramEnumMappingId IS NULL
	BEGIN
		SET @errorCode = 'InvalidParamEnumMapping';
		SELECT @rc=[Id], @errorMessage='Invalid enum mapping for parameters: ' + ISNULL(@paramEnumMapping, '<NULL>')
		FROM [Enum].[ToolkitResponseCode] WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @languageOptionsVal BIGINT = [Internal].[GetLanguageOptions](@languageId, @languageOptions);
    DECLARE @projectId SMALLINT;

	BEGIN TRY
		IF @tranCount = 0
			BEGIN TRANSACTION
		ELSE
			SAVE TRANSACTION TrnSp; 

		EXEC [Internal].[CreateProject]
            @name, @namespaceName, @className, @classAccessId, @languageId, @paramEnumMappingId,
            @mapResultSetEnums, @languageOptionsVal, @defaultDatabase, @enumSchema, @storedProcSchema,
            @projectId OUTPUT;

		IF @tranCount = 0    
			COMMIT TRANSACTION

		SET @rc = @RC_OK;
	END TRY
	BEGIN CATCH
		SET @rc = @RC_DB_ERROR;
        

		SET @errorMessage = ERROR_MESSAGE();

		DECLARE @xstate INT;
		SELECT @xstate = XACT_STATE();
			
		IF @xstate = -1
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount = 0
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount > 0
			ROLLBACK TRANSACTION TrnSp;
		
		EXEC [Internal].[LogError];
	END CATCH

	
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Project].[UpdateProject]...';


GO
CREATE PROCEDURE [Project].[UpdateProject]
	@name NVARCHAR(200),	
	@errorMessage NVARCHAR(2000) OUTPUT,
    @namespaceName VARCHAR(100) = NULL,
	@className VARCHAR(100) = NULL,
	@defaultDatabase NVARCHAR(128) = NULL,
	--@enumSchema NVARCHAR(128) = NULL,
	--@storedProcSchema NVARCHAR(128) = NULL,
	@classAccess VARCHAR(200) = NULL,	
	@paramEnumMapping VARCHAR(100) = NULL, 
	@mapResultSetEnums BIT = NULL,
	@languageOptions VARCHAR(1000) = NULL
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

    SET LOCK_TIMEOUT 1000; -- wait for up to 1 seconds for a lock to be released.
	SET DEADLOCK_PRIORITY NORMAL;

	DECLARE @RC_OK INT = 0;	
	DECLARE @RC_UNKNOWN_CLASS_ACCESS INT = 1;	
	DECLARE @RC_UNKNOWN_PEM INT = 3;
    DECLARE @RC_UNKNOWN_PROJECT INT = 4;
	DECLARE @RC_DB_ERROR INT = 51;
	DECLARE @RC_UNKNOWN_ERROR INT = 99;

	DECLARE @rc INT = @RC_UNKNOWN_ERROR;
	
	DECLARE @tranCount INT = @@TRANCOUNT;

    DECLARE @projectId SMALLINT;
    DECLARE @languageId TINYINT;
    SELECT @projectId=[Id], @languageId=[LanguageId] FROM [dbo].[Project] WHERE [Name]=@name;

    IF @projectId IS NULL
    BEGIN
        SELECT @rc=@RC_UNKNOWN_PROJECT, @errorMessage='Project not found: ' + ISNULL(@name, '<NULL>');
        RETURN @rc;
    END

	DECLARE @classAccessId TINYINT = NULL;
    
    IF @classAccess IS NOT NULL
    BEGIN
        SELECT @classAccessId=[Id] FROM [Enum].[ClassAccess] WHERE [Name]=@classAccess;
	    IF @classAccessId IS NULL
	    BEGIN
		    SELECT @rc=@RC_UNKNOWN_CLASS_ACCESS, @errorMessage='Unknown class access: ' + ISNULL(@classAccess, '<NULL>');
		    RETURN @rc;
	    END
    END;
    
    DECLARE @paramEnumMappingId TINYINT = NULL;
    IF @paramEnumMapping IS NOT NULL
    BEGIN
	    SELECT @paramEnumMappingId=[Id] FROM [Enum].[ParamEnumMapping] WHERE [Name]=ISNULL(@paramEnumMapping, 'ExplicitOnly');
	    IF @paramEnumMappingId IS NULL
	    BEGIN
		    SELECT @rc=@RC_UNKNOWN_PEM, @errorMessage='Invalid enum mapping for parameters: ' + ISNULL(@paramEnumMapping, '<NULL>');
		    RETURN @rc;
	    END
    END

	DECLARE @languageOptionsVal BIGINT = NULL;
    IF NULLIF(LTRIM(@languageOptions), '') IS NOT NULL
    BEGIN
        SET @languageOptionsVal=[Internal].[GetLanguageOptions](@languageId, @languageOptions);
    END

	BEGIN TRY
		IF @tranCount = 0
			BEGIN TRANSACTION
		ELSE
			SAVE TRANSACTION TrnSp; 

        UPDATE [dbo].[Project]
        SET 
            [NamespaceName] = ISNULL(NULLIF(LTRIM(@namespaceName), ''), [NamespaceName]),
            [ClassName] = ISNULL(NULLIF(LTRIM(@className), ''), [ClassName]),
            [ClassAccessId] = ISNULL(@classAccessId, [ClassAccessId]),            
            [ParamEnumMappingId] = ISNULL(@paramEnumMappingId, [ParamEnumMappingId]),
            [MapResultSetEnums] = ISNULL(@mapResultSetEnums, [MapResultSetEnums]),
            [LanguageOptions] = ISNULL(@languageOptionsVal, [LanguageOptions]),
            [DefaultDatabase] = ISNULL(NULLIF(LTRIM(@defaultDatabase), ''), [DefaultDatabase])
        WHERE [Id]=@projectId;		

		IF @tranCount = 0    
			COMMIT TRANSACTION

		SET @rc = @RC_OK;
	END TRY
	BEGIN CATCH
		SET @rc = @RC_DB_ERROR;
        

		SET @errorMessage = ERROR_MESSAGE();

		DECLARE @xstate INT;
		SELECT @xstate = XACT_STATE();
			
		IF @xstate = -1
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount = 0
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount > 0
			ROLLBACK TRANSACTION TrnSp;
		
		EXEC [Internal].[LogError];
	END CATCH

	
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[GetLanguages]...';


GO

-- =============================================
-- 3️⃣ [Toolkit].[GetLanguages]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetLanguages]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        [Id],
        [Name],
        [Code]
    FROM [Enum].[Language]
    WHERE [StatusId] = 1
    ORDER BY [Id];
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjects]...';


GO

-- =============================================
-- 4️⃣ [Toolkit].[GetProjects]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetProjects]
    @languageId TINYINT = NULL
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        p.[Id],
        p.[Name],
        p.[ClassName],
        p.[NamespaceName],
        l.[Name] AS [LanguageName],
        l.[Code] AS [LanguageCode]
    FROM [dbo].[Project] p
    LEFT JOIN [Enum].[Language] l ON l.[Id] = p.[LanguageId]
    WHERE (@languageId IS NULL OR p.[LanguageId] = @languageId)
    ORDER BY p.[Name];
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetResponseCodes]...';


GO

-- ============================================
-- Stored Procedure: [Toolkit].[GetResponseCodes]
-- ============================================
CREATE PROCEDURE [Toolkit].[GetResponseCodes]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT
        Id,
        Name,
        Description,
        IsSuccess
    FROM [Enum].[ToolkitResponseCode]
    ORDER BY Id;
END
GO
PRINT N'Creating Procedure [Toolkit].[CreateProject]...';


GO
CREATE PROCEDURE [Toolkit].[CreateProject]
    @name NVARCHAR(200),
    @namespaceName VARCHAR(100),
    @className VARCHAR(100),
    @classAccessId TINYINT,
    @languageId TINYINT,
    @paramEnumMappingId TINYINT,
    @mapResultSetEnums BIT,
    @languageOptions BIGINT,
    @defaultDatabase NVARCHAR(128),    
	@projectId SMALLINT OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT    
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

	DECLARE @RC_OK INT = 0;	
	DECLARE @RC_DB_ERROR INT = 1;
	DECLARE @RC_INTERNAL_ERROR INT = 2;

    DECLARE @rc INT = @RC_INTERNAL_ERROR;    
	DECLARE @tranCount INT = @@TRANCOUNT;
	
	DECLARE @errorCode VARCHAR(100) = 'InternalError'

	IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=@classAccessId)
	BEGIN
		SET @errorCode='InvalidClassAccess';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END
	
	IF NOT EXISTS (SELECT 1 FROM [Enum].[Language] WHERE [Id]=@languageId)
	BEGIN
		SET @errorCode='InvalidLanguage';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	IF NOT EXISTS (SELECT 1 FROM [sys].[databases] WHERE [name]=@defaultDatabase)
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END


    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION
        ELSE
            SAVE TRANSACTION TrnSp;

        EXEC @rc = [Internal].[CreateProject]
            @name, @namespaceName, @className, @classAccessId, @languageId, @paramEnumMappingId,
            @mapResultSetEnums, @languageOptions, @defaultDatabase, NULL, NULL,
            @projectId OUTPUT;

        IF @tranCount = 0
            COMMIT TRANSACTION;

        --SET @rc = 0;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[GetAllProjects]...';


GO
CREATE PROCEDURE [Toolkit].[GetAllProjects]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT
        p.[Id],
        p.[Name],
        p.[ClassName],
        p.[NamespaceName],
        l.[Name] AS [LanguageName]
    FROM [dbo].[Project] p
    LEFT JOIN [Enum].[Language] l ON l.[Id] = p.[LanguageId]
    ORDER BY p.[Name];
END
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectId]...';


GO

CREATE PROCEDURE [Toolkit].[GetProjectId]
    @name NVARCHAR(200),
    @projectId SMALLINT OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
	
	DECLARE @RC_OK INT = 0;	
	DECLARE @RC_DB_ERROR INT = 1;
	DECLARE @RC_INTERNAL_ERROR INT = 2;

    DECLARE @rc INT = @RC_INTERNAL_ERROR;    

	
	DECLARE @errorCode VARCHAR(100);

    SELECT @projectId = p.[Id]
    FROM [dbo].[Project] p
    WHERE p.[Name] = @name;

    IF @projectId IS NULL
    BEGIN
        SET @errorCode = 'UnknownProject';
        SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
    END
	SET @rc = @RC_OK;
    
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[GetDbInfo]...';


GO

-- =============================================
-- 2️⃣ [Toolkit].[GetDbInfo]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetDbInfo]
    @dbName NVARCHAR(128) OUTPUT,
    @version NVARCHAR(50) OUTPUT,
    @apiLevel TINYINT OUTPUT,
    @minApiLevel TINYINT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT TOP (1)
        @dbName = [DbInfo].[GetName](),
        @version = [Version],
        @apiLevel = [ApiLevel],
        @minApiLevel = [MinApiLevel]
    FROM [dbo].[SchemaVersion]
    ORDER BY [Id] DESC; -- Consistent with [DbInfo].[GetCurrentVersion]

END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectInfo]...';


GO
CREATE   PROCEDURE [Toolkit].[GetProjectInfo]
    @projectName NVARCHAR(200),
    @projectId SMALLINT OUTPUT,
    @languageId TINYINT OUTPUT,
    @defaultDatabase NVARCHAR(128) OUTPUT,
	@className VARCHAR(100) OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_UNKNOWN_PROJECT INT = 3;  -- Matches [Enum].[ToolkitResponseCode]
    DECLARE @rc INT = @RC_UNKNOWN_PROJECT;

    -- Look up project by name
    SELECT 
        @projectId = p.[Id],
        @languageId = p.[LanguageId],
        @defaultDatabase = p.[DefaultDatabase],
		@className = p.[ClassName]
    FROM [dbo].[Project] p
    WHERE p.[Name] = @projectName;

    IF @projectId IS NULL
    BEGIN
        SELECT @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';

        RETURN @RC_UNKNOWN_PROJECT;
    END

    -- Validate default database is a user DB only (database_id > 4)
    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (
        SELECT 1 
        FROM sys.databases 
        WHERE [name] = @defaultDatabase AND [database_id] > 4
    )
    BEGIN
        SET @defaultDatabase = NULL;
    END

    SET @rc = @RC_OK;
    RETURN @rc;
END;
GO
PRINT N'Creating Procedure [Toolkit].[UpdateProject]...';


GO

CREATE   PROCEDURE [Toolkit].[UpdateProject]
    @projectId SMALLINT,
    @name NVARCHAR(200) = NULL,
    @namespaceName VARCHAR(100) = NULL,
    @className VARCHAR(100) = NULL,
    @classAccessId TINYINT = NULL,
    @paramEnumMappingId TINYINT = NULL,
    @mapResultSetEnums BIT = NULL,
    @languageOptions BIGINT = NULL,
    @defaultDatabase NVARCHAR(128) = NULL,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_DB_ERROR INT = 1;
    DECLARE @RC_INTERNAL_ERROR INT = 2;
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;
    DECLARE @errorCode VARCHAR(100) = 'InternalError';

    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'MissingProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @classAccessId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id] = @classAccessId)
    BEGIN
        SET @errorCode = 'InvalidClassAccess';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @paramEnumMappingId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id] = @paramEnumMappingId)
    BEGIN
        SET @errorCode = 'InvalidParamEnumMapping';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [sys].[databases] WHERE [name] = @defaultDatabase)
    BEGIN
        SET @errorCode = 'InvalidDatabase';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @name IS NOT NULL AND EXISTS (
        SELECT 1 FROM [dbo].[Project] WHERE [Name] = @name AND [Id] <> @projectId
    )
    BEGIN
        SET @errorCode = 'DuplicateProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        UPDATE [dbo].[Project]
        SET 
            [Name] = COALESCE(@name, [Name]),
            [NamespaceName] = COALESCE(@namespaceName, [NamespaceName]),
            [ClassName] = COALESCE(@className, [ClassName]),
            [ClassAccessId] = COALESCE(@classAccessId, [ClassAccessId]),
            [ParamEnumMappingId] = COALESCE(@paramEnumMappingId, [ParamEnumMappingId]),
            [MapResultSetEnums] = COALESCE(@mapResultSetEnums, [MapResultSetEnums]),
            [LanguageOptions] = COALESCE(@languageOptions, [LanguageOptions]),
            [DefaultDatabase] = COALESCE(@defaultDatabase, [DefaultDatabase])
        WHERE [Id] = @projectId;

        IF @tranCount = 0
            COMMIT TRANSACTION;

        SET @rc = @RC_OK;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectStoredProcMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-07-02
-- Description: Removes a stored procedure mapping from a project.
-- Parameters:
--   @projectId             - Target project ID
--   @spMappingId           - ID of the mapping to be removed
--   @errorMessage          - Output error message if any
-- =============================================
CREATE   PROCEDURE [Toolkit].[RemoveProjectStoredProcMapping]
    @projectId SMALLINT,
    @spMappingId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
   
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectStoredProc]
        WHERE [Id] = @spMappingId AND [ProjectId] = @projectId
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownStoredProcMapping';
        RETURN @rc;
    END

    -- Delete
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectStoredProc]
        WHERE [Id] = @spMappingId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectNameNormalization]...';


GO
CREATE   PROCEDURE [Toolkit].[RemoveProjectNameNormalization]
    @projectId SMALLINT,
    @normalizationId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;

    DECLARE @rc INT = @RC_INTERNAL_ERROR,
        @errorCode VARCHAR(100) = 'InternalError',
        @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectNameNormalization]
        WHERE [Id] = @normalizationId AND [ProjectId] = @projectId
    )
    BEGIN
        SET @errorCode = 'UnknownNameNormalization';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectNameNormalization]
        WHERE [Id] = @normalizationId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectEnumMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-07-02
-- Description: Removes an enum mapping from a project.
-- Parameters:
--   @projectId             - Target project ID
--   @spMappingId           - ID of the mapping to be removed
--   @errorMessage          - Output error message if any
-- =============================================
CREATE   PROCEDURE [Toolkit].[RemoveProjectEnumMapping]
    @projectId SMALLINT,
    @enumMappingId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
   
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectEnum]
        WHERE [Id] = @enumMappingId AND [ProjectId] = @projectId
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownEnumMapping';
        RETURN @rc;
    END

    -- Delete
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectEnum]
        WHERE [Id] = @enumMappingId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectStoredProcedureMappings]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectStoredProcedureMappings]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [Schema], [NameMatchId], [NamePattern], [EscChar], [LanguageOptionsReset], [LanguageOptionsSet]
	FROM [dbo].[ProjectStoredProc]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectNameNormalizations]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectNameNormalizations]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [NamePart], [NamePartTypeId]
	FROM [dbo].[ProjectNameNormalization]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectEnumMappings]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectEnumMappings]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [Schema], [NameMatchId], [NamePattern], [EscChar], [IsSetOfFlags], [NameColumn]
	FROM [dbo].[ProjectEnum]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];

END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDetails]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectDetails]
    @projectName NVARCHAR(200),
    @projectId SMALLINT OUTPUT,
    @languageId TINYINT OUTPUT,
    @defaultDatabase NVARCHAR(128) OUTPUT,
	@className VARCHAR(100) OUTPUT,
	@namespaceName VARCHAR(100) OUTPUT,
	@classAccessId TINYINT OUTPUT,
	@languageOptions BIGINT OUTPUT,
	@paramEnumMappingId TINYINT OUTPUT,
	@mapResultSetEnums BIT OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_UNKNOWN_PROJECT INT = 3;  -- Matches [Enum].[ToolkitResponseCode]
    DECLARE @rc INT = @RC_UNKNOWN_PROJECT;

    -- Look up project by name
    SELECT 
        @projectId = p.[Id],
        @languageId = p.[LanguageId],
        @defaultDatabase = p.[DefaultDatabase],
		@className = p.[ClassName],
		@namespaceName = p.[NamespaceName],
		@classAccessId = p.[ClassAccessId],
		@languageOptions = p.[LanguageOptions],
		@paramEnumMappingId = p.[ParamEnumMappingId],
		@mapResultSetEnums = p.[MapResultSetEnums]
    FROM [dbo].[Project] p
    WHERE p.[Name] = @projectName;

    IF @projectId IS NULL
    BEGIN
        SELECT @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';

        RETURN @RC_UNKNOWN_PROJECT;
    END

    -- Validate default database is a user DB only (database_id > 4)
    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (
        SELECT 1 
        FROM sys.databases 
        WHERE [name] = @defaultDatabase AND [database_id] > 4
    )
    BEGIN
        SET @defaultDatabase = NULL;
    END

    SET @rc = @RC_OK;
    RETURN @rc;
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemas]...';


GO

CREATE PROCEDURE [Toolkit].[GetProjectDbSchemas]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

	DROP TABLE IF EXISTS #Result;

	CREATE TABLE #Result
	(
		[Name] NVARCHAR(128) NOT NULL PRIMARY KEY
	);
	DECLARE @query NVARCHAR(1000);
	SELECT @query='SELECT [name] FROM ' + QUOTENAME(d.[name]) 
		+ '.[sys].[schemas] WHERE [schema_id]<16384 AND [name] NOT IN (''guest'', ''INFORMATION_SCHEMA'', ''sys'') ORDER BY [name]'
	FROM [dbo].[Project] p
	JOIN [sys].[databases] d ON p.[DefaultDatabase]=d.[name] 
	WHERE p.[Id]=@projectId;

	--PRINT @query;

	INSERT INTO #Result ([Name])
	EXEC(@query);
    
	SELECT [Name]
	FROM #Result
	ORDER BY [Name];

	DROP TABLE IF EXISTS #Result;
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemaProcs]...';


GO

CREATE PROCEDURE [Toolkit].[GetProjectDbSchemaProcs]
    @projectId SMALLINT,
	@schema NVARCHAR(128)
AS
BEGIN
    SET NOCOUNT ON;

	DROP TABLE IF EXISTS #Result;

	CREATE TABLE #Result
	(
		[Name] NVARCHAR(128) NOT NULL PRIMARY KEY
	);
	DECLARE @query NVARCHAR(1000);
	SELECT @query='SELECT p.[name] FROM ' + QUOTENAME(d.[name]) 
		+ '.[sys].[procedures] p WHERE p.[Type]=''P'' AND SCHEMA_NAME(p.schema_id)=' + QUOTENAME(@schema, '''') + ' ORDER BY p.[name]'
	FROM [dbo].[Project] p
	JOIN [sys].[databases] d ON p.[DefaultDatabase]=d.[name] 
	WHERE p.[Id]=@projectId;

	--PRINT @query;

	INSERT INTO #Result ([Name])
	EXEC(@query);
    
	SELECT [Name]
	FROM #Result
	ORDER BY [Name];

	DROP TABLE IF EXISTS #Result;
END;
GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemaEnumCandidates]...';


GO

CREATE   PROCEDURE [Toolkit].[GetProjectDbSchemaEnumCandidates]
    @projectId SMALLINT,
    @schema NVARCHAR(128)
AS
BEGIN
    SET NOCOUNT ON;

    DROP TABLE IF EXISTS #Result;

    CREATE TABLE #Result
    (
        [Name] NVARCHAR(128) NOT NULL PRIMARY KEY, -- Table name
        [NameColumn] NVARCHAR(128) NULL,           -- Auto-detected name column (optional)
        [NameColumns] NVARCHAR(4000) NOT NULL      -- JSON array of char-like columns
    );

    DECLARE @dbName NVARCHAR(256);
    SELECT @dbName = d.[name]
    FROM [dbo].[Project] p
    JOIN [sys].[databases] d ON p.[DefaultDatabase] = d.[name]
    WHERE p.[Id] = @projectId;

    IF @dbName IS NULL
    BEGIN
        RAISERROR('Could not resolve target database name for the specified project.', 16, 1);
        RETURN;
    END

    DECLARE @sql NVARCHAR(MAX);

    SET @sql = N'
    WITH CandidateTables AS (
        SELECT t.[name] AS TableName, t.[object_id]
        FROM ' + QUOTENAME(@dbName) + '.sys.tables t
        JOIN ' + QUOTENAME(@dbName) + '.sys.schemas s ON t.[schema_id] = s.[schema_id]
        WHERE s.[name] = @schema
        AND EXISTS (
            SELECT 1
            FROM ' + QUOTENAME(@dbName) + '.sys.indexes i
            JOIN ' + QUOTENAME(@dbName) + '.sys.index_columns ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
            JOIN ' + QUOTENAME(@dbName) + '.sys.columns c ON ic.[object_id] = c.[object_id] AND ic.[column_id] = c.[column_id]
            WHERE i.[object_id] = t.[object_id]
              AND i.is_primary_key = 1
              AND c.system_type_id IN (48, 52, 56, 127) -- tinyint, smallint, int, bigint
            GROUP BY i.[object_id]
            HAVING COUNT(*) = 1
        )
        AND EXISTS (
            SELECT 1
            FROM ' + QUOTENAME(@dbName) + '.sys.columns c
            WHERE c.[object_id] = t.[object_id]
              AND c.system_type_id IN (175, 239, 167, 231) -- char, nchar, varchar, nvarchar
        )
    )
    INSERT INTO #Result ([Name], [NameColumn], [NameColumns])
    SELECT 
        ct.TableName,
        (
            SELECT TOP 1 c.[name]
            FROM ' + QUOTENAME(@dbName) + '.sys.indexes i
            JOIN ' + QUOTENAME(@dbName) + '.sys.index_columns ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
            JOIN ' + QUOTENAME(@dbName) + '.sys.columns c ON ic.[object_id] = c.[object_id] AND ic.[column_id] = c.[column_id]
            WHERE i.[object_id] = ct.[object_id]
              AND i.is_unique = 1
              AND c.system_type_id IN (175, 239, 167, 231)
            GROUP BY c.[name]
            HAVING COUNT(*) = 1
        ),
        (
            SELECT c.[name]
            FROM ' + QUOTENAME(@dbName) + '.sys.columns c
            WHERE c.[object_id] = ct.[object_id]
              AND c.system_type_id IN (175, 239, 167, 231)
            FOR JSON PATH
        )
    FROM CandidateTables ct;
    ';

    EXEC sp_executesql @sql, N'@schema NVARCHAR(128)', @schema = @schema;

    SELECT [Name], [NameColumn], [NameColumns]
    FROM #Result
    ORDER BY [Name];

    DROP TABLE IF EXISTS #Result;
END;
GO
PRINT N'Creating Procedure [Toolkit].[AddProjectStoredProcMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Updated:     2025-07-02
-- Description: Adds a stored procedure mapping to a project.
-- Parameters:
--   @projectId             - Target project ID
--   @schema                - Schema of the procedure
--   @nameMatchId           - Name matching strategy
--   @namePattern           - Pattern for matching
--   @escChar               - Escape character for LIKE pattern
--   @languageOptionsReset  - Options to reset (bitmask)
--   @languageOptionsSet    - Options to set (bitmask)
--   @id                    - Output ID of new row
--   @errorMessage          - Output error message if any
-- =============================================
CREATE PROCEDURE [Toolkit].[AddProjectStoredProcMapping]
    @projectId             SMALLINT,
    @schema                NVARCHAR(128),
    @nameMatchId           TINYINT,
    @namePattern           NVARCHAR(200),
    @escChar               NCHAR(1),
    @languageOptionsReset  BIGINT,
    @languageOptionsSet    BIGINT,
    @id                    INT OUTPUT,
    @errorMessage          NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
    
	DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;

    SET @id = NULL;
    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';
        RETURN @rc;
    END

	IF ISNULL(@schema, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'SchemaNotProvided';
        RETURN @rc;
    END

    IF @nameMatchId <> @NM_ANY AND ISNULL(@namePattern, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'NamePatternNotProvided';
        RETURN @rc;
    END

    IF @nameMatchId <> @NM_LIKE AND @escChar IS NOT NULL
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnexpectedEscChar';
        RETURN @rc;
    END

    IF EXISTS (
        SELECT 1 FROM [dbo].[ProjectStoredProc]
        WHERE [ProjectId] = @projectId AND [Schema] = @schema AND [NamePattern] = @namePattern
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'DuplicateStoredProcMapping';
        RETURN @rc;
    END

    -- Insert
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectStoredProc]
        (
            [ProjectId],
            [Schema],
            [NameMatchId],
            [NamePattern],
            [EscChar],
            [LanguageOptionsReset],
            [LanguageOptionsSet]
        )
        VALUES
        (
            @projectId,
            @schema,
            @nameMatchId,
            @namePattern,
            @escChar,
            @languageOptionsReset,
            @languageOptionsSet
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
PRINT N'Creating Procedure [Toolkit].[AddProjectNameNormalization]...';


GO
CREATE   PROCEDURE [Toolkit].[AddProjectNameNormalization]
    @projectId SMALLINT,
    @namePart NVARCHAR(128),
    @namePartTypeId TINYINT,
    @id INT OUTPUT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
    DECLARE @rc INT = @RC_INTERNAL_ERROR,
        @errorCode VARCHAR(100) = 'InternalError',
        @tranCount INT = @@TRANCOUNT;

    SET @id = NULL;
    SET @errorMessage = NULL;

    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'UnknownProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id] = @namePartTypeId)
    BEGIN
        SET @errorCode = 'InvalidNamePartType';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectNameNormalization]
        (
            [ProjectId],
            [NamePart],
            [NamePartTypeId]
        )
        VALUES
        (
            @projectId,
            @namePart,
            @namePartTypeId
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[AddProjectEnumMapping]...';


GO
-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Updated:     2025-07-02
-- Description: Adds an enum mapping to a project, avoiding duplicates.
-- Parameters:
--   @projectId      - Target project ID
--   @schema         - Schema of the enum table
--   @nameMatchId    - Name matching strategy (from enum)
--   @namePattern    - Pattern used to match the enum
--   @escChar        - Escape character used in pattern (if any)
--   @isSetOfFlags   - Whether this enum is a set of flags
--   @nameColumn     - Column name for enum display name
--   @id             - ID of the inserted or existing row
--   @errorMessage   - detailed error message if any
-- =============================================
CREATE PROCEDURE [Toolkit].[AddProjectEnumMapping]
    @projectId      SMALLINT,
    @schema         NVARCHAR(128),
    @nameMatchId    TINYINT,
    @namePattern    NVARCHAR(200),
    @escChar        NCHAR(1),
    @isSetOfFlags   BIT,
    @nameColumn     NVARCHAR(128),
    @id             INT OUTPUT,
    @errorMessage   NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
	SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;

	
	DECLARE @NM_LIKE TINYINT = 4;
	DECLARE @NM_ANY TINYINT = 255;

    SET @id = NULL;
    SET @errorMessage = NULL;
	DECLARE @errorCode VARCHAR(100) = 'InternalError';
	SET @id = NULL;

    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

	IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'UnknownProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF ISNULL(@schema, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'SchemaNotProvided';
        RETURN @rc;
    END

	IF @nameMatchId <> @NM_ANY AND ISNULL(@namePattern, '') = ''
    BEGIN
        SET @errorCode = 'NamePatternNotProvided';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF @nameMatchId <> @NM_LIKE AND @escChar IS NOT NULL
	BEGIN
        SET @errorCode = 'UnexpectedEscChar';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF EXISTS (
		SELECT 1 FROM [dbo].[ProjectEnum] 
		WHERE [ProjectId] = @projectId AND [Schema] = @schema AND [NamePattern] = @namePattern
	)
	BEGIN
        SET @errorCode = 'DuplicateEnumMapping';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectEnum]
        (
			[ProjectId], [Schema], [NameMatchId], [NamePattern], [EscChar], [IsSetOfFlags], [NameColumn]
        )
        VALUES
        (
			@projectId, @schema, @nameMatchId, @namePattern, @escChar, @isSetOfFlags, @nameColumn
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;
        

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[GetLanguageOptions]...';


GO
-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Description: Returns all primary language options for the specified language,
--              including global options (LanguageId IS NULL).
-- Parameters:
--   @languageId - Language ID to filter by
-- =============================================
CREATE PROCEDURE [Toolkit].[GetLanguageOptions]
    @languageId TINYINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        [Id],
        [Name],
        [Value],
        [IsOverridablePerStoredProc]
    FROM [Static].[LanguageOption]
    WHERE 
        [IsPrimary] = 1
        AND ISNULL([LanguageId], @languageId) = @languageId
    ORDER BY [Value];
END
GO
PRINT N'Creating Procedure [Parser].[ParseTSql]...';


GO

CREATE PROCEDURE [Parser].[ParseTSql]	
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;

    DECLARE @RC_START_PARENTHESIS_NOT_FOUND INT = 1;
    DECLARE @RC_END_PARENTHESIS_NOT_FOUND INT = 2;
    DECLARE @RC_START_BLOCK_NOT_FOUND INT = 3;
    DECLARE @RC_END_BLOCK_NOT_FOUND INT = 4;
    DECLARE @RC_UNEXPECTED_END_OF_TOKENS INT = 5;
    DECLARE @RC_UNEXPECTED_TOKEN INT = 6;
    DECLARE @RC_INVALID_END_BLOCK INT = 7;
    DECLARE @RC_PARSE_ERROR INT = 20;

    DECLARE @RC_ERR_DB INT = 100;

    DECLARE @TPS_RC_OK INT = 0;
    DECLARE @TPS_RC_NOT_MATCH INT = 1;
    
    SET @errorMessage = NULL;

    DECLARE @rc INT = @RC_OK;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @ST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @ST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @ST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @ST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @ST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @ST_STRING TINYINT = 6;
    DECLARE @ST_UNICODE_STRING TINYINT = 7;
    DECLARE @ST_INTEGER TINYINT = 8;
    DECLARE @ST_DECIMAL TINYINT = 9;
    DECLARE @ST_MONEY TINYINT = 10;
    DECLARE @ST_REAL TINYINT = 11;
    DECLARE @ST_BINARY TINYINT = 12;
    DECLARE @ST_COMMA TINYINT = 13;
    DECLARE @ST_SEMICOLON TINYINT = 14;
    DECLARE @ST_PERIOD TINYINT = 15;

    DECLARE @BT_REGULAR_BLOCK TINYINT = 1;
    DECLARE @BT_TRY_BLOCK TINYINT = 2;
    DECLARE @BT_CATCH_BLOCK TINYINT = 3;
    DECLARE @BT_ATOMIC_BLOCK TINYINT = 4;
    DECLARE @BT_CASE_BLOCK TINYINT = 5;

    DECLARE @KW_ADD SMALLINT = 1;
    DECLARE @KW_ALL SMALLINT = 2;
    DECLARE @KW_ALTER SMALLINT = 3;
    DECLARE @KW_AND SMALLINT = 4;
    DECLARE @KW_ANY SMALLINT = 5;
    DECLARE @KW_AS SMALLINT = 6;
    DECLARE @KW_ASC SMALLINT = 7;
    DECLARE @KW_AUTHORIZATION SMALLINT = 8;
    DECLARE @KW_BACKUP SMALLINT = 9;
    DECLARE @KW_BEGIN SMALLINT = 10;
    DECLARE @KW_BETWEEN SMALLINT = 11;
    DECLARE @KW_BREAK SMALLINT = 12;
    DECLARE @KW_BROWSE SMALLINT = 13;
    DECLARE @KW_BULK SMALLINT = 14;
    DECLARE @KW_BY SMALLINT = 15;
    DECLARE @KW_CASCADE SMALLINT = 16;
    DECLARE @KW_CASE SMALLINT = 17;
    DECLARE @KW_CHECK SMALLINT = 18;
    DECLARE @KW_CHECKPOINT SMALLINT = 19;
    DECLARE @KW_CLOSE SMALLINT = 20;
    DECLARE @KW_CLUSTERED SMALLINT = 21;
    DECLARE @KW_COALESCE SMALLINT = 22;
    DECLARE @KW_COLLATE SMALLINT = 23;
    DECLARE @KW_COLUMN SMALLINT = 24;
    DECLARE @KW_COMMIT SMALLINT = 25;
    DECLARE @KW_COMPUTE SMALLINT = 26;
    DECLARE @KW_CONSTRAINT SMALLINT = 27;
    DECLARE @KW_CONTAINS SMALLINT = 28;
    DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
    DECLARE @KW_CONTINUE SMALLINT = 30;
    DECLARE @KW_CONVERT SMALLINT = 31;
    DECLARE @KW_CREATE SMALLINT = 32;
    DECLARE @KW_CROSS SMALLINT = 33;
    DECLARE @KW_CURRENT SMALLINT = 34;
    DECLARE @KW_CURRENT_DATE SMALLINT = 35;
    DECLARE @KW_CURRENT_TIME SMALLINT = 36;
    DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
    DECLARE @KW_CURRENT_USER SMALLINT = 38;
    DECLARE @KW_CURSOR SMALLINT = 39;
    DECLARE @KW_DATABASE SMALLINT = 40;
    DECLARE @KW_DBCC SMALLINT = 41;
    DECLARE @KW_DEALLOCATE SMALLINT = 42;
    DECLARE @KW_DECLARE SMALLINT = 43;
    DECLARE @KW_DEFAULT SMALLINT = 44;
    DECLARE @KW_DELETE SMALLINT = 45;
    DECLARE @KW_DENY SMALLINT = 46;
    DECLARE @KW_DESC SMALLINT = 47;
    DECLARE @KW_DISK SMALLINT = 48;
    DECLARE @KW_DISTINCT SMALLINT = 49;
    DECLARE @KW_DISTRIBUTED SMALLINT = 50;
    DECLARE @KW_DOUBLE SMALLINT = 51;
    DECLARE @KW_DROP SMALLINT = 52;
    DECLARE @KW_DUMP SMALLINT = 53;
    DECLARE @KW_ELSE SMALLINT = 54;
    DECLARE @KW_END SMALLINT = 55;
    DECLARE @KW_ERRLVL SMALLINT = 56;
    DECLARE @KW_ESCAPE SMALLINT = 57;
    DECLARE @KW_EXCEPT SMALLINT = 58;
    DECLARE @KW_EXEC SMALLINT = 59;
    DECLARE @KW_EXECUTE SMALLINT = 60;
    DECLARE @KW_EXISTS SMALLINT = 61;
    DECLARE @KW_EXIT SMALLINT = 62;
    DECLARE @KW_EXTERNAL SMALLINT = 63;
    DECLARE @KW_FETCH SMALLINT = 64;
    DECLARE @KW_FILE SMALLINT = 65;
    DECLARE @KW_FILLFACTOR SMALLINT = 66;
    DECLARE @KW_FOR SMALLINT = 67;
    DECLARE @KW_FOREIGN SMALLINT = 68;
    DECLARE @KW_FREETEXT SMALLINT = 69;
    DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
    DECLARE @KW_FROM SMALLINT = 71;
    DECLARE @KW_FULL SMALLINT = 72;
    DECLARE @KW_FUNCTION SMALLINT = 73;
    DECLARE @KW_GOTO SMALLINT = 74;
    DECLARE @KW_GRANT SMALLINT = 75;
    DECLARE @KW_GROUP SMALLINT = 76;
    DECLARE @KW_HAVING SMALLINT = 77;
    DECLARE @KW_HOLDLOCK SMALLINT = 78;
    DECLARE @KW_IDENTITY SMALLINT = 79;
    DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
    DECLARE @KW_IDENTITYCOL SMALLINT = 81;
    DECLARE @KW_IF SMALLINT = 82;
    DECLARE @KW_IN SMALLINT = 83;
    DECLARE @KW_INDEX SMALLINT = 84;
    DECLARE @KW_INNER SMALLINT = 85;
    DECLARE @KW_INSERT SMALLINT = 86;
    DECLARE @KW_INTERSECT SMALLINT = 87;
    DECLARE @KW_INTO SMALLINT = 88;
    DECLARE @KW_IS SMALLINT = 89;
    DECLARE @KW_JOIN SMALLINT = 90;
    DECLARE @KW_KEY SMALLINT = 91;
    DECLARE @KW_KILL SMALLINT = 92;
    DECLARE @KW_LEFT SMALLINT = 93;
    DECLARE @KW_LIKE SMALLINT = 94;
    DECLARE @KW_LINENO SMALLINT = 95;
    DECLARE @KW_LOAD SMALLINT = 96;
    DECLARE @KW_MERGE SMALLINT = 97;
    DECLARE @KW_NATIONAL SMALLINT = 98;
    DECLARE @KW_NOCHECK SMALLINT = 99;
    DECLARE @KW_NONCLUSTERED SMALLINT = 100;
    DECLARE @KW_NOT SMALLINT = 101;
    DECLARE @KW_NULL SMALLINT = 102;
    DECLARE @KW_NULLIF SMALLINT = 103;
    DECLARE @KW_OF SMALLINT = 104;
    DECLARE @KW_OFF SMALLINT = 105;
    DECLARE @KW_OFFSETS SMALLINT = 106;
    DECLARE @KW_ON SMALLINT = 107;
    DECLARE @KW_OPEN SMALLINT = 108;
    DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
    DECLARE @KW_OPENQUERY SMALLINT = 110;
    DECLARE @KW_OPENROWSET SMALLINT = 111;
    DECLARE @KW_OPENXML SMALLINT = 112;
    DECLARE @KW_OPTION SMALLINT = 113;
    DECLARE @KW_OR SMALLINT = 114;
    DECLARE @KW_ORDER SMALLINT = 115;
    DECLARE @KW_OUTER SMALLINT = 116;
    DECLARE @KW_OVER SMALLINT = 117;
    DECLARE @KW_PERCENT SMALLINT = 118;
    DECLARE @KW_PIVOT SMALLINT = 119;
    DECLARE @KW_PLAN SMALLINT = 120;
    DECLARE @KW_PRECISION SMALLINT = 121;
    DECLARE @KW_PRIMARY SMALLINT = 122;
    DECLARE @KW_PRINT SMALLINT = 123;
    DECLARE @KW_PROC SMALLINT = 124;
    DECLARE @KW_PROCEDURE SMALLINT = 125;
    DECLARE @KW_PUBLIC SMALLINT = 126;
    DECLARE @KW_RAISERROR SMALLINT = 127;
    DECLARE @KW_READ SMALLINT = 128;
    DECLARE @KW_READTEXT SMALLINT = 129;
    DECLARE @KW_RECONFIGURE SMALLINT = 130;
    DECLARE @KW_REFERENCES SMALLINT = 131;
    DECLARE @KW_REPLICATION SMALLINT = 132;
    DECLARE @KW_RESTORE SMALLINT = 133;
    DECLARE @KW_RESTRICT SMALLINT = 134;
    DECLARE @KW_RETURN SMALLINT = 135;
    DECLARE @KW_REVERT SMALLINT = 136;
    DECLARE @KW_REVOKE SMALLINT = 137;
    DECLARE @KW_RIGHT SMALLINT = 138;
    DECLARE @KW_ROLLBACK SMALLINT = 139;
    DECLARE @KW_ROWCOUNT SMALLINT = 140;
    DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
    DECLARE @KW_RULE SMALLINT = 142;
    DECLARE @KW_SAVE SMALLINT = 143;
    DECLARE @KW_SCHEMA SMALLINT = 144;
    DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
    DECLARE @KW_SELECT SMALLINT = 146;
    DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
    DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
    DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
    DECLARE @KW_SESSION_USER SMALLINT = 150;
    DECLARE @KW_SET SMALLINT = 151;
    DECLARE @KW_SETUSER SMALLINT = 152;
    DECLARE @KW_SHUTDOWN SMALLINT = 153;
    DECLARE @KW_SOME SMALLINT = 154;
    DECLARE @KW_STATISTICS SMALLINT = 155;
    DECLARE @KW_SYSTEM_USER SMALLINT = 156;
    DECLARE @KW_TABLE SMALLINT = 157;
    DECLARE @KW_TABLESAMPLE SMALLINT = 158;
    DECLARE @KW_TEXTSIZE SMALLINT = 159;
    DECLARE @KW_THEN SMALLINT = 160;
    DECLARE @KW_TO SMALLINT = 161;
    DECLARE @KW_TOP SMALLINT = 162;
    DECLARE @KW_TRAN SMALLINT = 163;
    DECLARE @KW_TRANSACTION SMALLINT = 164;
    DECLARE @KW_TRIGGER SMALLINT = 165;
    DECLARE @KW_TRUNCATE SMALLINT = 166;
    DECLARE @KW_TRY_CONVERT SMALLINT = 167;
    DECLARE @KW_TSEQUAL SMALLINT = 168;
    DECLARE @KW_UNION SMALLINT = 169;
    DECLARE @KW_UNIQUE SMALLINT = 170;
    DECLARE @KW_UNPIVOT SMALLINT = 171;
    DECLARE @KW_UPDATE SMALLINT = 172;
    DECLARE @KW_UPDATETEXT SMALLINT = 173;
    DECLARE @KW_USE SMALLINT = 174;
    DECLARE @KW_USER SMALLINT = 175;
    DECLARE @KW_VALUES SMALLINT = 176;
    DECLARE @KW_VARYING SMALLINT = 177;
    DECLARE @KW_VIEW SMALLINT = 178;
    DECLARE @KW_WAITFOR SMALLINT = 179;
    DECLARE @KW_WHEN SMALLINT = 180;
    DECLARE @KW_WHERE SMALLINT = 181;
    DECLARE @KW_WHILE SMALLINT = 182;
    DECLARE @KW_WITH SMALLINT = 183;
    DECLARE @KW_WITHIN SMALLINT = 184;
    DECLARE @KW_WRITETEXT SMALLINT = 185;
    DECLARE @KW_ATOMIC SMALLINT = 186;
    DECLARE @KW_CONVERSATION SMALLINT = 187;
    DECLARE @KW_DIALOG SMALLINT = 188;
    DECLARE @KW_CATCH SMALLINT = 189;
    DECLARE @KW_TRY SMALLINT = 190;
    DECLARE @KW_THROW SMALLINT = 191;
    DECLARE @KW_FILETABLE SMALLINT = 192;
    DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;

    DECLARE @parLevel SMALLINT = 0;
    DECLARE @blockLevel SMALLINT = 0;
    
    DECLARE @startTokenId INT;
    DECLARE @endTokenId INT;

    DECLARE @typeId TINYINT;
    DECLARE @keywordId SMALLINT;
    DECLARE @subtypeId SMALLINT;
    DECLARE @text NVARCHAR(MAX);
    
    DECLARE @nextTokenId INT;
    DECLARE @nextTypeId TINYINT;
    DECLARE @nextKeywordId SMALLINT;
    DECLARE @nextSubtypeId SMALLINT;
    DECLARE @nextText NVARCHAR(MAX);

    DECLARE @tokenId INT = (SELECT MIN([Id]) FROM #Token);
    DECLARE @lastTokenId INT = (SELECT MAX([Id]) FROM #Token);

    -- First pass: identify parentheses

    WHILE @tokenId IS NOT NULL
    BEGIN
        SELECT @typeId=[TypeId], @keywordId=[KeywordId], @subtypeId=[SubtypeId], @text=[Text]
        FROM #Token WHERE [Id]=@tokenId;

        IF @typeId=@TT_DELIMITER
        BEGIN
            IF @text = N'('
            BEGIN
                SET @parLevel += 1;
                UPDATE #Token 
                SET [Level]=@parLevel
                WHERE [Id]=@tokenId;
            END
            ELSE IF @text = N')'                
            BEGIN
                SELECT @startTokenId=[Id]
                FROM #Token 
                WHERE [Level]=@parLevel AND [Id] < @tokenId AND [EndTokenId] IS NULL;
                IF @startTokenId IS NULL
                BEGIN
                    SELECT @rc=@RC_START_PARENTHESIS_NOT_FOUND, @errorMessage='Start parenthesis not found (TokenId: ' + LOWER(@tokenId) + ')';
                    RETURN @rc;
                END
                UPDATE #Token 
                SET [Level]=@parLevel, [StartTokenId]=@startTokenId
                WHERE [Id]=@tokenId;
                UPDATE #Token 
                SET [EndTokenId]=@tokenId
                WHERE [Id]=@startTokenId;
                SET @parLevel -= 1;
            END
        END
        SELECT @tokenId=MIN([Id]) FROM #Token WHERE [Id]>@tokenId;
    END

    IF @parLevel > 0
    BEGIN
        SELECT @rc=@RC_END_PARENTHESIS_NOT_FOUND, @errorMessage='End parenthesis not found';
        RETURN @rc;
    END

    DECLARE @blockTypeId TINYINT;
    DECLARE @seqStartTokenId INT;
    DECLARE @seqEndTokenId INT;
    DECLARE @startBlockTypeId TINYINT;

    -- Second  pass: identify blocks
    SELECT @tokenId=MIN([Id]) FROM #Token;
    
    WHILE @tokenId IS NOT NULL
    BEGIN
        SELECT @typeId=[TypeId], @keywordId=[KeywordId], @subtypeId=[SubtypeId], @text=[Text]
        FROM #Token WHERE [Id]=@tokenId;

        IF @typeId=@TT_KEYWORD
        BEGIN
            SELECT TOP(1) @nextTokenId=[Id], @nextTypeId=[TypeId], @nextKeywordId=[KeywordId], @nextSubtypeId=[SubtypeId], @nextText=[Text]
            FROM #Token
            WHERE [Id] > @tokenId AND [TypeId] NOT IN (@TT_WHITESPACE, @TT_COMMENT)
            ORDER BY [Id];

            IF @keywordId=@KW_BEGIN
            BEGIN
                IF @nextTokenId IS NULL
                BEGIN                    
                    SELECT @rc=@RC_UNEXPECTED_END_OF_TOKENS, @errorMessage='Unexpected end of tokens (TokenId: ' + LOWER(@tokenId) + ')';
                    RETURN @rc;
                END
                IF @nextTypeId<>@TT_KEYWORD OR @nextKeywordId NOT IN (@KW_CONVERSATION, @KW_DIALOG, @KW_TRAN, @KW_TRANSACTION, @KW_DISTRIBUTED)
                BEGIN
                    -- begin block                    
                    SET @blockLevel += 1;
                    SET @blockTypeId = CASE WHEN @nextTypeId<>@TT_KEYWORD THEN @BT_REGULAR_BLOCK 
                    ELSE CASE @nextKeywordId WHEN @KW_TRY THEN @BT_TRY_BLOCK WHEN @KW_CATCH THEN @BT_CATCH_BLOCK WHEN @KW_ATOMIC THEN @BT_ATOMIC_BLOCK ELSE @BT_REGULAR_BLOCK END END;

                    SET @seqStartTokenId = @tokenId;
                    SET @seqEndTokenId = CASE WHEN @blockTypeId=@BT_REGULAR_BLOCK THEN @tokenId ELSE @nextTokenId END;

                    IF @blockTypeId=@BT_ATOMIC_BLOCK
                    BEGIN
                        SELECT TOP(1) @nextTokenId=[Id], @nextTypeId=[TypeId], @nextKeywordId=[KeywordId], @nextSubtypeId=[SubtypeId], @nextText=[Text]
                        FROM #Token
                        WHERE [Id] > @nextTokenId AND [TypeId] NOT IN (@TT_WHITESPACE, @TT_COMMENT)
                        ORDER BY [Id];
                        IF @nextTokenId IS NULL
                        BEGIN                    
                            SELECT @rc=@RC_UNEXPECTED_END_OF_TOKENS, @errorMessage='Unexpected end of tokens (TokenId: ' + LOWER(@tokenId) + ')';
                            RETURN @rc;
                        END
                        IF @nextTypeId=@TT_KEYWORD AND @nextKeywordId=@KW_WITH
                        BEGIN
                            SELECT TOP(1) @nextTokenId=[Id], @nextTypeId=[TypeId], @nextKeywordId=[KeywordId], @nextSubtypeId=[SubtypeId], @nextText=[Text], @endTokenId=[EndTokenId]
                            FROM #Token
                            WHERE [Id] > @nextTokenId AND [TypeId] NOT IN (@TT_WHITESPACE, @TT_COMMENT)
                            ORDER BY [Id];
                            IF @nextTokenId IS NULL
                            BEGIN                    
                                SELECT @rc=@RC_UNEXPECTED_END_OF_TOKENS, @errorMessage='Unexpected end of tokens (TokenId: ' + LOWER(@tokenId) + ')';
                                RETURN @rc;
                            END
                            IF @nextTypeId<>@TT_DELIMITER OR @nextText<>N'(' OR @endTokenId IS NULL
                            BEGIN
                                SELECT @rc=@RC_UNEXPECTED_TOKEN, @errorMessage='Unexpected token (TokenId: ' + LOWER(@nextTokenId) + ')';
                                RETURN @rc;
                            END
                             SET @seqEndTokenId=@endTokenId;
                        END
                    END

                    UPDATE #Token 
                    SET [Level]=@blockLevel, [BlockTypeId]=@blockTypeId, [SeqStartTokenId]=@tokenId, [SeqEndTokenId]=@seqEndTokenId
                    WHERE [Id]=@tokenId;
                    SET @tokenId=@seqEndTokenId;
                END
            END
            ELSE IF @keywordId=@KW_CASE
            BEGIN
                SET @blockLevel += 1;
                SET @blockTypeId = @BT_CASE_BLOCK;
                SET @seqStartTokenId = @tokenId;
                SET @seqEndTokenId = @tokenId;
                UPDATE #Token 
                SET [Level]=@blockLevel, [BlockTypeId]=@blockTypeId, [SeqStartTokenId]=@tokenId, [SeqEndTokenId]=@seqEndTokenId
                WHERE [Id]=@tokenId;
                SET @tokenId=@seqEndTokenId;
            END
            ELSE IF @keywordId=@KW_END
            BEGIN
                IF @nextTokenId IS NULL OR @nextTypeId<>@TT_KEYWORD OR @nextKeywordId NOT IN (@KW_CONVERSATION)
                BEGIN
                    -- end block                    
                    SELECT @startTokenId=[Id], @startBlockTypeId=[BlockTypeId]
                    FROM #Token 
                    WHERE [TypeId]=@TT_KEYWORD AND [Level]=@blockLevel AND [Id] < @tokenId AND [EndTokenId] IS NULL;
                    
                    IF @startTokenId IS NULL OR @startBlockTypeId IS NULL
                    BEGIN
                        SELECT @rc=@RC_START_BLOCK_NOT_FOUND, @errorMessage='Block start not found (TokenId: ' + LOWER(@tokenId) + ')';
                        RETURN @rc;
                    END
                    SET @blockTypeId=@BT_REGULAR_BLOCK;
                    SET @seqStartTokenId = @tokenId;
                    SET @seqEndTokenId = @tokenId;
                    IF @nextTokenId IS NOT NULL AND @nextTypeId=@TT_KEYWORD AND @nextKeywordId IN (@KW_TRY, @KW_CATCH)
                    BEGIN
                        SET @blockTypeId=CASE WHEN @nextKeywordId=@KW_TRY THEN @BT_TRY_BLOCK ELSE @BT_CATCH_BLOCK END;
                        SET @seqEndTokenId=@nextTokenId;
                    END

                    IF @startBlockTypeId=@BT_ATOMIC_BLOCK AND @blockTypeId=@BT_REGULAR_BLOCK
                    BEGIN
                        SET @blockTypeId=@BT_ATOMIC_BLOCK;
                    END
                    IF @startBlockTypeId=@BT_CASE_BLOCK AND @blockTypeId=@BT_REGULAR_BLOCK
                    BEGIN
                        SET @blockTypeId=@BT_CASE_BLOCK;
                    END
                    IF @startBlockTypeId<>@blockTypeId
                    BEGIN
                        SELECT @rc=@RC_INVALID_END_BLOCK, @errorMessage='Invalid end block type (TokenId: ' + LOWER(@tokenId) + ')';
                        RETURN @rc;                        
                    END

                    UPDATE #Token 
                    SET [Level]=@blockLevel, [StartTokenId]=@startTokenId, [BlockTypeId]=@blockTypeId, [SeqStartTokenId]=@tokenId, [SeqEndTokenId]=@seqEndTokenId
                    WHERE [Id]=@tokenId;

                    UPDATE #Token 
                    SET [EndTokenId]=@tokenId
                    WHERE [Id]=@startTokenId;
                    
                    SET @blockLevel -= 1;                    
                    SET @tokenId=@seqEndTokenId;
                END
            END
        END

        SELECT @tokenId=MIN([Id]) FROM #Token WHERE [Id]>@tokenId;
    END
    
    IF @blockLevel > 0
    BEGIN
        SELECT @rc=@RC_END_BLOCK_NOT_FOUND, @errorMessage='Block end not found';
        RETURN @rc;
    END

    DROP TABLE IF EXISTS #StartKeyword;
    DROP TABLE IF EXISTS #Sequence;    


    CREATE TABLE #StartKeyword
    (
        [Id] SMALLINT NOT NULL PRIMARY KEY,
        [Name] VARCHAR(50) NOT NULL UNIQUE
    );

    CREATE TABLE #Sequence
    (
        [Id] SMALLINT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [SequenceId] SMALLINT NOT NULL  UNIQUE
    );    

    INSERT INTO #StartKeyword ([Id], [Name])
    SELECT DISTINCT kw.[Id], kw.[Name]
    FROM [Parser].[TSqlSeqElement] el
    JOIN [Parser].[TSqlSequence] seq ON el.[SequenceId]=seq.[Id]
    JOIN [ParserEnum].[TSqlStatementType] st ON seq.[StatementTypeId]=st.[Id]
    JOIN [ParserEnum].[TSqlKeyword] kw ON kw.[Id]=el.[KeywordId]
    WHERE el.[IsStartElement]=1;

    DECLARE @id SMALLINT;
    DECLARE @sequenceId SMALLINT = NULL;

    -- Third pass: identify statements
    SELECT @tokenId=MIN(t.[Id]) 
    FROM #Token t 
    JOIN #StartKeyword sk ON sk.[Id]=t.[KeywordId]
    WHERE t.[TypeId]=@TT_KEYWORD;

    DECLARE @tpsRc INT;
    DECLARE @parentStatementId INT;
    DECLARE @parentStatementPartId TINYINT;
    DECLARE @tpsLastTokenId INT;
    DECLARE @isFinished BIT;
    DECLARE @statementSeparatorTokenId INT;
    DECLARE @tpsErrorMessage NVARCHAR(4000);

    WHILE @tokenId IS NOT NULL
    BEGIN        
        --PRINT('Token Id: ' + LOWER(@tokenId));
        TRUNCATE TABLE #Sequence;

        INSERT INTO #Sequence ([SequenceId])
        SELECT seq.[Id]
        FROM #Token t
        JOIN [Parser].[TSqlSeqElement] el ON el.[IsStartElement]=1 AND el.[KeywordId]=t.[KeywordId]
        JOIN [Parser].[TSqlSequence] seq ON el.[SequenceId]=seq.[Id]
        JOIN [ParserEnum].[TSqlStatementType] st ON seq.[StatementTypeId]=st.[Id]
        JOIN [ParserEnum].[TSqlKeyword] kw ON kw.[Id]=el.[KeywordId]
        WHERE t.[Id]=@tokenId
        ORDER BY seq.[Precedence], seq.[Id];
        --PRINT('Number of sequences: ' + LOWER(@@ROWCOUNT));

        SELECT TOP(1) @id=[Id], @sequenceId=[SequenceId]
        FROM #Sequence
        ORDER BY [Id];

        WHILE @sequenceId IS NOT NULL
        BEGIN
            --PRINT('Sequence Id: ' + LOWER(@sequenceId) + ' (' + LOWER(@id) + ')');
            EXEC @tpsRc = [Parser].[TryParseSequence] @tokenId, @sequenceId, @parentStatementId, @parentStatementPartId, 
                @tpsLastTokenId OUTPUT, @isFinished OUTPUT, @statementSeparatorTokenId OUTPUT, @tpsErrorMessage OUTPUT;
            IF @tpsRC=@TPS_RC_OK
            BEGIN
                --PRINT(N'Match t: ' + LOWER(@tokenId) + N' - ' + LOWER(@tpsLastTokenId));
                SELECT @tokenId = @tpsLastTokenId;
                BREAK;
            END

            IF @tpsRC<>@TPS_RC_NOT_MATCH
            BEGIN
                SET @errorMessage = N'Unexpected parsing result: ' + LOWER(@tpsRC) + N' - ' + ISNULL(@tpsErrorMessage, '<NULL>')
                PRINT(@errorMessage);
                SET @rc=@RC_PARSE_ERROR;
                RETURN @rc;
            END
            --PRINT('Not match');
            SET @sequenceId=NULL;
            SELECT TOP(1) @id=[Id], @sequenceId=[SequenceId]
            FROM #Sequence
            WHERE [Id] > @id
            ORDER BY [Id];    
            --PRINT('New sequence Id: ' + ISNULL(LOWER(@sequenceId), '<NULL>') + ' (' + ISNULL(LOWER(@id), '<NULL>') + ')');
        END
        
        SELECT @tokenId=MIN(t.[Id]) 
        FROM #Token t 
        JOIN #StartKeyword sk ON sk.[Id]=t.[KeywordId]
        WHERE t.[TypeId]=@TT_KEYWORD AND t.[Id] > @tokenId;
        --PRINT('New token Id: ' + ISNULL(LOWER(@tokenId), '<NULL>'));
    END

    DROP TABLE IF EXISTS #StartKeyword;
    DROP TABLE IF EXISTS #Sequence;    

    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Parser].[TryDescribeFirstResultSetWorkaround]...';


GO

CREATE PROCEDURE [Parser].[TryDescribeFirstResultSetWorkaround]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,	
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_PARSE INT = 1;

	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;


    DECLARE @ST_CREATE_PROCEDURE SMALLINT = 1;
    DECLARE @ST_CREATE_TABLE SMALLINT = 2;
    DECLARE @ST_EXEC SMALLINT = 3;
    DECLARE @ST_SELECT SMALLINT = 4;
    DECLARE @ST_INSERT SMALLINT = 5;
    DECLARE @ST_UPDATE SMALLINT = 6;
    DECLARE @ST_DELETE SMALLINT = 7;
    DECLARE @ST_DECLARE SMALLINT = 8;
    DECLARE @ST_SET SMALLINT = 9;

    DECLARE @ST_TRUNCATE_TABLE SMALLINT = 10;
    DECLARE @ST_DROP_TABLE SMALLINT = 11;

    DECLARE @ST_BEGIN_TRANSACTION SMALLINT = 20;
    DECLARE @ST_BEGIN_DISTRIBUTED_TRANSACTION SMALLINT = 21;
    DECLARE @ST_COMMIT SMALLINT = 23;
    DECLARE @ST_ROLLBACK SMALLINT = 24;

    DECLARE @ST_IF SMALLINT = 31;
    DECLARE @ST_WHILE SMALLINT = 32;
    DECLARE @ST_CONTINUE SMALLINT = 33;
    DECLARE @ST_BREAK SMALLINT = 34;
    DECLARE @ST_THROW SMALLINT = 35;
    DECLARE @ST_RAISERROR SMALLINT = 36;
    DECLARE @ST_PRINT SMALLINT = 37;
    DECLARE @ST_RETURN SMALLINT = 38;
	
    DECLARE @SP_IDENTIFIER TINYINT = 1;
    DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
    DECLARE @SP_DEFINITION TINYINT = 3;
    DECLARE @SP_CHILD_STATEMENT TINYINT = 4;

    DECLARE @KW_ADD SMALLINT = 1;
    DECLARE @KW_ALL SMALLINT = 2;
    DECLARE @KW_ALTER SMALLINT = 3;
    DECLARE @KW_AND SMALLINT = 4;
    DECLARE @KW_ANY SMALLINT = 5;
    DECLARE @KW_AS SMALLINT = 6;
    DECLARE @KW_ASC SMALLINT = 7;
    DECLARE @KW_AUTHORIZATION SMALLINT = 8;
    DECLARE @KW_BACKUP SMALLINT = 9;
    DECLARE @KW_BEGIN SMALLINT = 10;
    DECLARE @KW_BETWEEN SMALLINT = 11;
    DECLARE @KW_BREAK SMALLINT = 12;
    DECLARE @KW_BROWSE SMALLINT = 13;
    DECLARE @KW_BULK SMALLINT = 14;
    DECLARE @KW_BY SMALLINT = 15;
    DECLARE @KW_CASCADE SMALLINT = 16;
    DECLARE @KW_CASE SMALLINT = 17;
    DECLARE @KW_CHECK SMALLINT = 18;
    DECLARE @KW_CHECKPOINT SMALLINT = 19;
    DECLARE @KW_CLOSE SMALLINT = 20;
    DECLARE @KW_CLUSTERED SMALLINT = 21;
    DECLARE @KW_COALESCE SMALLINT = 22;
    DECLARE @KW_COLLATE SMALLINT = 23;
    DECLARE @KW_COLUMN SMALLINT = 24;
    DECLARE @KW_COMMIT SMALLINT = 25;
    DECLARE @KW_COMPUTE SMALLINT = 26;
    DECLARE @KW_CONSTRAINT SMALLINT = 27;
    DECLARE @KW_CONTAINS SMALLINT = 28;
    DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
    DECLARE @KW_CONTINUE SMALLINT = 30;
    DECLARE @KW_CONVERT SMALLINT = 31;
    DECLARE @KW_CREATE SMALLINT = 32;
    DECLARE @KW_CROSS SMALLINT = 33;
    DECLARE @KW_CURRENT SMALLINT = 34;
    DECLARE @KW_CURRENT_DATE SMALLINT = 35;
    DECLARE @KW_CURRENT_TIME SMALLINT = 36;
    DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
    DECLARE @KW_CURRENT_USER SMALLINT = 38;
    DECLARE @KW_CURSOR SMALLINT = 39;
    DECLARE @KW_DATABASE SMALLINT = 40;
    DECLARE @KW_DBCC SMALLINT = 41;
    DECLARE @KW_DEALLOCATE SMALLINT = 42;
    DECLARE @KW_DECLARE SMALLINT = 43;
    DECLARE @KW_DEFAULT SMALLINT = 44;
    DECLARE @KW_DELETE SMALLINT = 45;
    DECLARE @KW_DENY SMALLINT = 46;
    DECLARE @KW_DESC SMALLINT = 47;
    DECLARE @KW_DISK SMALLINT = 48;
    DECLARE @KW_DISTINCT SMALLINT = 49;
    DECLARE @KW_DISTRIBUTED SMALLINT = 50;
    DECLARE @KW_DOUBLE SMALLINT = 51;
    DECLARE @KW_DROP SMALLINT = 52;
    DECLARE @KW_DUMP SMALLINT = 53;
    DECLARE @KW_ELSE SMALLINT = 54;
    DECLARE @KW_END SMALLINT = 55;
    DECLARE @KW_ERRLVL SMALLINT = 56;
    DECLARE @KW_ESCAPE SMALLINT = 57;
    DECLARE @KW_EXCEPT SMALLINT = 58;
    DECLARE @KW_EXEC SMALLINT = 59;
    DECLARE @KW_EXECUTE SMALLINT = 60;
    DECLARE @KW_EXISTS SMALLINT = 61;
    DECLARE @KW_EXIT SMALLINT = 62;
    DECLARE @KW_EXTERNAL SMALLINT = 63;
    DECLARE @KW_FETCH SMALLINT = 64;
    DECLARE @KW_FILE SMALLINT = 65;
    DECLARE @KW_FILLFACTOR SMALLINT = 66;
    DECLARE @KW_FOR SMALLINT = 67;
    DECLARE @KW_FOREIGN SMALLINT = 68;
    DECLARE @KW_FREETEXT SMALLINT = 69;
    DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
    DECLARE @KW_FROM SMALLINT = 71;
    DECLARE @KW_FULL SMALLINT = 72;
    DECLARE @KW_FUNCTION SMALLINT = 73;
    DECLARE @KW_GOTO SMALLINT = 74;
    DECLARE @KW_GRANT SMALLINT = 75;
    DECLARE @KW_GROUP SMALLINT = 76;
    DECLARE @KW_HAVING SMALLINT = 77;
    DECLARE @KW_HOLDLOCK SMALLINT = 78;
    DECLARE @KW_IDENTITY SMALLINT = 79;
    DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
    DECLARE @KW_IDENTITYCOL SMALLINT = 81;
    DECLARE @KW_IF SMALLINT = 82;
    DECLARE @KW_IN SMALLINT = 83;
    DECLARE @KW_INDEX SMALLINT = 84;
    DECLARE @KW_INNER SMALLINT = 85;
    DECLARE @KW_INSERT SMALLINT = 86;
    DECLARE @KW_INTERSECT SMALLINT = 87;
    DECLARE @KW_INTO SMALLINT = 88;
    DECLARE @KW_IS SMALLINT = 89;
    DECLARE @KW_JOIN SMALLINT = 90;
    DECLARE @KW_KEY SMALLINT = 91;
    DECLARE @KW_KILL SMALLINT = 92;
    DECLARE @KW_LEFT SMALLINT = 93;
    DECLARE @KW_LIKE SMALLINT = 94;
    DECLARE @KW_LINENO SMALLINT = 95;
    DECLARE @KW_LOAD SMALLINT = 96;
    DECLARE @KW_MERGE SMALLINT = 97;
    DECLARE @KW_NATIONAL SMALLINT = 98;
    DECLARE @KW_NOCHECK SMALLINT = 99;
    DECLARE @KW_NONCLUSTERED SMALLINT = 100;
    DECLARE @KW_NOT SMALLINT = 101;
    DECLARE @KW_NULL SMALLINT = 102;
    DECLARE @KW_NULLIF SMALLINT = 103;
    DECLARE @KW_OF SMALLINT = 104;
    DECLARE @KW_OFF SMALLINT = 105;
    DECLARE @KW_OFFSETS SMALLINT = 106;
    DECLARE @KW_ON SMALLINT = 107;
    DECLARE @KW_OPEN SMALLINT = 108;
    DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
    DECLARE @KW_OPENQUERY SMALLINT = 110;
    DECLARE @KW_OPENROWSET SMALLINT = 111;
    DECLARE @KW_OPENXML SMALLINT = 112;
    DECLARE @KW_OPTION SMALLINT = 113;
    DECLARE @KW_OR SMALLINT = 114;
    DECLARE @KW_ORDER SMALLINT = 115;
    DECLARE @KW_OUTER SMALLINT = 116;
    DECLARE @KW_OVER SMALLINT = 117;
    DECLARE @KW_PERCENT SMALLINT = 118;
    DECLARE @KW_PIVOT SMALLINT = 119;
    DECLARE @KW_PLAN SMALLINT = 120;
    DECLARE @KW_PRECISION SMALLINT = 121;
    DECLARE @KW_PRIMARY SMALLINT = 122;
    DECLARE @KW_PRINT SMALLINT = 123;
    DECLARE @KW_PROC SMALLINT = 124;
    DECLARE @KW_PROCEDURE SMALLINT = 125;
    DECLARE @KW_PUBLIC SMALLINT = 126;
    DECLARE @KW_RAISERROR SMALLINT = 127;
    DECLARE @KW_READ SMALLINT = 128;
    DECLARE @KW_READTEXT SMALLINT = 129;
    DECLARE @KW_RECONFIGURE SMALLINT = 130;
    DECLARE @KW_REFERENCES SMALLINT = 131;
    DECLARE @KW_REPLICATION SMALLINT = 132;
    DECLARE @KW_RESTORE SMALLINT = 133;
    DECLARE @KW_RESTRICT SMALLINT = 134;
    DECLARE @KW_RETURN SMALLINT = 135;
    DECLARE @KW_REVERT SMALLINT = 136;
    DECLARE @KW_REVOKE SMALLINT = 137;
    DECLARE @KW_RIGHT SMALLINT = 138;
    DECLARE @KW_ROLLBACK SMALLINT = 139;
    DECLARE @KW_ROWCOUNT SMALLINT = 140;
    DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
    DECLARE @KW_RULE SMALLINT = 142;
    DECLARE @KW_SAVE SMALLINT = 143;
    DECLARE @KW_SCHEMA SMALLINT = 144;
    DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
    DECLARE @KW_SELECT SMALLINT = 146;
    DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
    DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
    DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
    DECLARE @KW_SESSION_USER SMALLINT = 150;
    DECLARE @KW_SET SMALLINT = 151;
    DECLARE @KW_SETUSER SMALLINT = 152;
    DECLARE @KW_SHUTDOWN SMALLINT = 153;
    DECLARE @KW_SOME SMALLINT = 154;
    DECLARE @KW_STATISTICS SMALLINT = 155;
    DECLARE @KW_SYSTEM_USER SMALLINT = 156;
    DECLARE @KW_TABLE SMALLINT = 157;
    DECLARE @KW_TABLESAMPLE SMALLINT = 158;
    DECLARE @KW_TEXTSIZE SMALLINT = 159;
    DECLARE @KW_THEN SMALLINT = 160;
    DECLARE @KW_TO SMALLINT = 161;
    DECLARE @KW_TOP SMALLINT = 162;
    DECLARE @KW_TRAN SMALLINT = 163;
    DECLARE @KW_TRANSACTION SMALLINT = 164;
    DECLARE @KW_TRIGGER SMALLINT = 165;
    DECLARE @KW_TRUNCATE SMALLINT = 166;
    DECLARE @KW_TRY_CONVERT SMALLINT = 167;
    DECLARE @KW_TSEQUAL SMALLINT = 168;
    DECLARE @KW_UNION SMALLINT = 169;
    DECLARE @KW_UNIQUE SMALLINT = 170;
    DECLARE @KW_UNPIVOT SMALLINT = 171;
    DECLARE @KW_UPDATE SMALLINT = 172;
    DECLARE @KW_UPDATETEXT SMALLINT = 173;
    DECLARE @KW_USE SMALLINT = 174;
    DECLARE @KW_USER SMALLINT = 175;
    DECLARE @KW_VALUES SMALLINT = 176;
    DECLARE @KW_VARYING SMALLINT = 177;
    DECLARE @KW_VIEW SMALLINT = 178;
    DECLARE @KW_WAITFOR SMALLINT = 179;
    DECLARE @KW_WHEN SMALLINT = 180;
    DECLARE @KW_WHERE SMALLINT = 181;
    DECLARE @KW_WHILE SMALLINT = 182;
    DECLARE @KW_WITH SMALLINT = 183;
    DECLARE @KW_WITHIN SMALLINT = 184;
    DECLARE @KW_WRITETEXT SMALLINT = 185;
    DECLARE @KW_ATOMIC SMALLINT = 186;
    DECLARE @KW_CONVERSATION SMALLINT = 187;
    DECLARE @KW_DIALOG SMALLINT = 188;
    DECLARE @KW_CATCH SMALLINT = 189;
    DECLARE @KW_TRY SMALLINT = 190;
    DECLARE @KW_THROW SMALLINT = 191;
    DECLARE @KW_FILETABLE SMALLINT = 192;
    DECLARE @KW_OUTPUT SMALLINT = 193;
    DECLARE @KW_LOGIN SMALLINT = 194;
    DECLARE @KW_AT SMALLINT = 195;
    DECLARE @KW_DATA_SOURCE SMALLINT = 196;
    DECLARE @KW_RECOMPILE SMALLINT = 197;
    DECLARE @KW_RESULT SMALLINT = 198;
    DECLARE @KW_SETS SMALLINT = 199;
    DECLARE @KW_UNDEFINED SMALLINT = 200;
    DECLARE @KW_NONE SMALLINT = 201;
    DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @TST_STRING TINYINT = 6;
    DECLARE @TST_UNICODE_STRING TINYINT = 7;
    DECLARE @TST_INTEGER TINYINT = 8;
    DECLARE @TST_DECIMAL TINYINT = 9;
    DECLARE @TST_MONEY TINYINT = 10;
    DECLARE @TST_REAL TINYINT = 11;
    DECLARE @TST_BINARY TINYINT = 12;
    DECLARE @TST_COMMA TINYINT = 13;
    DECLARE @TST_SEMICOLON TINYINT = 14;
    DECLARE @TST_PERIOD TINYINT = 15;
    DECLARE @TST_VARIABLE_NAME TINYINT = 16;
    DECLARE @TST_UNARY_OPERATOR TINYINT = 17;
    DECLARE @TST_BINARY_OPERATOR TINYINT = 18;
    DECLARE @TST_UNARY_OR_BINARY_OPERATOR TINYINT = 19;

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);
    DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
    SELECT @spSchema = [Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	DROP TABLE IF EXISTS #Definition;

    CREATE TABLE #Definition
    (
        [Id] INT NOT NULL IDENTITY(1, 1) PRIMARY KEY,
        [Schema] NVARCHAR(128) NOT NULL,
        [Name] NVARCHAR(128) NOT NULL,
        [Definition] NVARCHAR(MAX) NOT NULL,
        UNIQUE ([Schema], [Name])
    );

    DECLARE @query NVARCHAR(MAX);

    SET @query = N'USE ' + QUOTENAME(@dbName) + N';
    '
    SET @query += N'SELECT SCHEMA_NAME(o.[schema_id]) [Schema], OBJECT_NAME(m.[object_id]) [Name], m.[definition] [Definition]
    FROM sys.all_sql_modules m
    JOIN sys.all_objects o ON m.object_id=o.[object_id]
    WHERE m.object_id=OBJECT_ID(' + QUOTENAME(QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName), '''') + N');
    ';

    INSERT INTO #Definition ([Schema], [Name], [Definition])
    EXEC(@query);

    DECLARE @tsql NVARCHAR(MAX);

    SELECT TOP(1) @tsql=[Definition] FROM #Definition;

    DROP TABLE IF EXISTS #Definition;

    DROP TABLE IF EXISTS #Token, #Statement, #StatementPart;

    CREATE TABLE #Token
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TypeId] TINYINT NOT NULL,
        [KeywordId] SMALLINT NULL,
        [SubTypeId] SMALLINT NULL,
        [OperatorId] TINYINT NULL,
        [Text] NVARCHAR(MAX) NULL,
        [Level] SMALLINT NULL,
        [StartTokenId] INT NULL,
        [EndTokenId] INT NULL,
        [BlockTypeId] TINYINT NULL,
        [SeqStartTokenId] INT NULL,
        [SeqEndTokenId] INT NULL,
        [SeqTypeId] TINYINT NULL,
    
    );

    CREATE TABLE #Statement
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TypeId] SMALLINT NOT NULL, -- [Enum].[TSqlStatementType]
        [StartTokenId] INT NOT NULL,
        [EndTokenId] INT NULL,
        [IsFinished] BIT NOT NULL DEFAULT (0),
        [StatementSeparatorTokenId] INT NULL,
        [ParentStatementId] INT NULL
    );


    CREATE TABLE #StatementPart
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StatementId] INT NOT NULL,
        [TypeId] TINYINT NOT NULL, -- [Enum].[TSqlStatementPart]
        [StartTokenId] INT NOT NULL,
        [EndTokenId] INT NOT NULL
    );

    CREATE TABLE #TempTable
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [Name] NVARCHAR(128) NOT NULL UNIQUE,
        [TvName] NVARCHAR(128) NOT NULL UNIQUE,
        [CreateTokenId] INT NOT NULL,
        [TableTokenId] INT NOT NULL,
        [NameTokenId] INT NOT NULL,
		[EndTokenId] INT NOT NULL,
		[CloseParenTokenId] INT NOT NULL
    );

    DECLARE	@returnValue int,
        @spErrorMessage nvarchar(4000);

    EXEC @returnValue = [Parser].[TokenizeTSql] @tsql = @tsql, @errorMessage = @spErrorMessage OUTPUT;

    IF @returnValue = @RC_OK
    BEGIN
        EXEC @returnValue = [Parser].[ParseTSql] @errorMessage = @errorMessage OUTPUT;
    END
    IF @returnValue <> @RC_OK
    BEGIN
        SELECT @rc = @RC_ERR_PARSE, @errorMessage=N'Failed to parse the stored procedure';
        RETURN @rc;
    END

    DECLARE @tempSpName NVARCHAR(128) = N'__Temp__' + LEFT(@spName, 64) + N'__' + REPLACE(LOWER(NEWID()), '-', '');

    INSERT INTO #TempTable ([Name], [TvName], [CreateTokenId], [TableTokenId], [NameTokenId], [EndTokenId], [CloseParenTokenId])
    SELECT tkn.[Text], N'@' + [Internal].[GetCaseName](@C_CAMEL_CASE, LEFT(tkn.[Text], 65), NULL) + N'___' + REPLACE(LOWER(NEWID()), '-', ''), tkc.[Id], tkt.[Id], tkn.[Id],
		st.[EndTokenId], tkcp.[Id]
    FROM #Statement st    
    JOIN #StatementPart stp ON stp.[StatementId]=st.[Id] AND stp.[TypeId]=@SP_IDENTIFIER AND stp.[StartTokenId]=stp.[EndTokenId]
    JOIN #Token tkn ON tkn.[Id]=stp.[StartTokenId]
    JOIN #Token tkc ON tkc.[Id] >= st.[StartTokenId] AND tkc.[Id] <= st.[EndTokenId] AND tkc.[TypeId]=@TT_KEYWORD AND tkc.[KeywordId]=@KW_CREATE
    JOIN #Token tkt ON tkt.[Id] >= st.[StartTokenId] AND tkt.[Id] <= st.[EndTokenId] AND tkt.[TypeId]=@TT_KEYWORD AND tkt.[KeywordId]=@KW_TABLE AND tkt.[Id] > tkc.[Id]
	JOIN #Token tkcp ON tkcp.[Id] >= st.[StartTokenId] AND tkcp.[Id] <= st.[EndTokenId] AND tkcp.[Text] = ')' AND tkcp.[TypeId]=@TT_DELIMITER AND tkcp.[Id] > tkt.[Id]
	
	LEFT JOIN #Token xtkc ON xtkc.[Id] >= st.[StartTokenId] AND xtkc.[Id] <= st.[EndTokenId] AND xtkc.[TypeId]=@TT_KEYWORD AND xtkc.[KeywordId]=@KW_CREATE AND xtkc.[Id] < tkc.[Id]
    LEFT JOIN #Token xtkt ON xtkt.[Id] >= st.[StartTokenId] AND xtkt.[Id] <= st.[EndTokenId] AND xtkt.[TypeId]=@TT_KEYWORD AND xtkt.[KeywordId]=@KW_TABLE AND xtkt.[Id] < tkt.[Id]
	LEFT JOIN #Token xtkcp ON xtkcp.[Id] >= st.[StartTokenId] AND xtkcp.[Id] <= st.[EndTokenId] AND xtkcp.[Text] = ')' AND xtkcp.[TypeId]=@TT_DELIMITER AND xtkcp.[Id] > tkcp.[Id]

	WHERE st.[TypeId]=@ST_CREATE_TABLE AND tkn.[Text] LIKE N'#[^#]%' AND xtkc.[Id] IS NULL AND xtkt.[Id] IS NULL AND xtkcp.[Id] IS NULL;
    
    -- SELECT * 
	-- FROM #TempTable;

    -- change SP name
    WITH cte AS
    (
        SELECT TOP(1) st.[Id], sp.[StartTokenId], sp.[EndTokenId]
        FROM #Statement st
        JOIN #StatementPart sp ON sp.[StatementId]=st.[Id] AND sp.[TypeId]=@SP_IDENTIFIER
        WHERE st.[TypeId]=@ST_CREATE_PROCEDURE
        ORDER BY st.[Id]
    )
    UPDATE tk
    SET tk.[Text]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @tempSpName ELSE N'' END,
        tk.[TypeId]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @TT_IDENTIFIER ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @TST_REGULAR_IDENTIFIER ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id] BETWEEN cte.[StartTokenId] AND cte.[EndTokenId];



    -- remove comments
    UPDATE #Token
    SET [TypeId]=@TT_WHITESPACE, [Text]=CASE WHEN [SubTypeId]=@TST_SINGLE_LINE_COMMENT THEN N'' ELSE N' ' END, [SubTypeId]=NULL
    WHERE [TypeId]=@TT_COMMENT;

    -- remove DROP TABLE ...
    UPDATE tk
    SET [Text]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId] IN (@KW_DROP, @KW_TABLE) THEN CASE WHEN tk.[KeywordId]=@KW_DROP THEN N'PRINT' ELSE N'DROP TABLE removed...' END ELSE N' ' END,
        [SubTypeId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId]=@KW_TABLE THEN @TST_STRING ELSE NULL END,
        [TypeId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId] IN (@KW_DROP, @KW_TABLE) THEN CASE WHEN tk.[KeywordId]=@KW_DROP THEN @TT_KEYWORD ELSE @TT_LITERAL END ELSE @TT_WHITESPACE END,
        [KeywordId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId]=@KW_DROP THEN @KW_PRINT ELSE NULL END        
    FROM #Statement st
    JOIN #Token tk ON tk.[Id] BETWEEN st.[StartTokenId] AND st.[EndTokenId]
    WHERE st.TypeId=@ST_DROP_TABLE;

	--SELECT * 
	--FROM #Token;

	--SELECT *
	--FROM #Statement;

    -- remove INSERT... EXEC
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY sti.[Id] ORDER BY tk.[Id]) [RowNum], sti.[Id] [StatementId], tk.[Id] [TokenId]
        FROM #Statement sti
        JOIN #Statement ste ON ste.[ParentStatementId]=sti.[Id] AND ste.[TypeId]=@ST_EXEC
        JOIN #Token tk ON tk.[Id] BETWEEN sti.[StartTokenId] AND ste.[EndTokenId]
        WHERE sti.[TypeId]=@ST_INSERT AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD  WHEN 2 THEN @TT_LITERAL ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 2 THEN @TST_STRING ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'PRINT' WHEN 2 THEN N'INSERT... EXEC removed...' ELSE N'' END,
        tk.[KeywordId]=CASE WHEN cte.[RowNum]=1 THEN @KW_PRINT ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- remove EXEC
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY ste.[Id] ORDER BY tk.[Id]) [RowNum], ste.[Id] [StatementId], tk.[Id] [TokenId]
        FROM #Statement ste
        JOIN #Token tk ON tk.[Id] BETWEEN ste.[StartTokenId] AND ste.[EndTokenId]
        WHERE ste.[TypeId]=@ST_EXEC AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD  WHEN 2 THEN @TT_LITERAL ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 2 THEN @TST_STRING ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'PRINT' WHEN 2 THEN N'EXEC removed...' ELSE N'' END,
        tk.[KeywordId]=CASE WHEN cte.[RowNum]=1 THEN @KW_PRINT ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- replace TRUNCATE TABLE #... with DELETE FROM @...
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY st.[Id] ORDER BY tk.[Id]) [RowNum], st.[Id] [StatementId], tk.[Id] [TokenId], tt.[Name] [TableName], tt.[TvName]
        FROM #Statement st
        JOIN #StatementPart stp ON stp.[StatementId]=st.[Id] AND stp.[TypeId]=@SP_IDENTIFIER AND stp.[StartTokenId]=stp.[EndTokenId]
        JOIN #Token ntk ON ntk.[Id]=stp.[StartTokenId]
        JOIN #TempTable tt ON tt.[Name]=ntk.[Text]
        JOIN #Token tk ON tk.[Id] BETWEEN st.[StartTokenId] AND st.[EndTokenId]
        WHERE st.[TypeId]=@ST_TRUNCATE_TABLE AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD WHEN 2 THEN @TT_KEYWORD WHEN 3 THEN @TT_IDENTIFIER ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 3 THEN @TST_VARIABLE_NAME ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'DELETE' WHEN 2 THEN N'FROM' WHEN 3 THEN cte.[TvName] ELSE N'' END,
        tk.[KeywordId]=CASE cte.[RowNum] WHEN 1 THEN @KW_DELETE WHEN 2 THEN @KW_FROM ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- replace CREATE TABLE #... with DECLARE @... TABLE

    UPDATE tk
    SET tk.[KeywordId]=@KW_DECLARE, tk.[Text]=N'DECLARE'
    FROM #TempTable tt
    JOIN #Token tk ON tt.[CreateTokenId]=tk.[Id];

    UPDATE tk
    SET tk.[TypeId]=@TT_IDENTIFIER, tk.[SubTypeId]=@TST_VARIABLE_NAME, tk.[KeywordId]=NULL, tk.[Text]=tt.[TvName]
    FROM #TempTable tt
    JOIN #Token tk ON tt.[TableTokenId]=tk.[Id];

    UPDATE tk
    SET tk.[TypeId]=@TT_KEYWORD, tk.[SubTypeId]=NULL, tk.[KeywordId]=@KW_TABLE, tk.[Text]=N'TABLE'
    FROM #TempTable tt
    JOIN #Token tk ON tt.[NameTokenId]=tk.[Id];


	-- Remove trailing comma before closing parenthesis in DECLARE @... TABLE
	UPDATE tk
	SET tk.[TypeId]=@TT_COMMENT, tk.[SubTypeId]=@TST_MULTI_LINE_COMMENT, tk.[Text]='/* comma removed */'
	FROM #TempTable tt
	JOIN #Token tk ON tk.[Text] = ',' AND tk.[TypeId]=@TT_SEPARATOR AND tk.[Id] < tt.[CloseParenTokenId] AND tk.[Id] > tt.[NameTokenId]
	LEFT JOIN #Token xtk ON xtk.[TypeId]<>@TT_WHITESPACE AND xtk.[Id] > tk.[Id] AND xtk.[Id] < tt.[CloseParenTokenId]
	WHERE xtk.[Id] IS NULL;

    -- replace #... with @... in all identifiers

    UPDATE tk
    SET tk.[Text]=tt.[TvName], tk.[SubTypeId]=@TST_VARIABLE_NAME
    FROM #TempTable tt
    JOIN #Token tk ON tt.[Name]=tk.[Text]
    WHERE tk.[TypeId]=@TT_IDENTIFIER;


    SELECT @tsql=STRING_AGG([Parser].[GetFullText]([Text], [SubTypeId]), N'') WITHIN GROUP (ORDER BY [Id])
    FROM #Token;

    

    --PRINT N'---------------------------------'
    --SELECT @tsql;
    --PRINT N'---------------------------------'

    SET @query = N'USE ' + QUOTENAME(@dbName) + N';    
    '
    SET @query += N'EXEC(N''' + REPLACE(@tsql, '''', '''''') + N''');
    ';
    SET @query += N'SELECT frs.[is_hidden], frs.[column_ordinal], frs.[name], frs.[is_nullable], frs.[system_type_id], frs.[system_type_name], frs.[max_length], frs.[precision], frs.[scale], 
        frs.[collation_name], frs.[user_type_id], frs.[user_type_database], frs.[user_type_schema], frs.[user_type_name], frs.[assembly_qualified_type_name], frs.[xml_collection_id], 
        frs.[xml_collection_database], frs.[xml_collection_schema], frs.[xml_collection_name], frs.[is_xml_document], frs.[is_case_sensitive], frs.[is_fixed_length_clr_type], 
        frs.[source_server], frs.[source_database], frs.[source_schema], frs.[source_table], frs.[source_column], frs.[is_identity_column], frs.[is_part_of_unique_key], 
        frs.[is_updateable], frs.[is_computed_column], frs.[is_sparse_column_set], frs.[ordinal_in_order_by_list], frs.[order_by_is_descending], frs.[order_by_list_length], 
        frs.[error_number], frs.[error_severity], frs.[error_state], frs.[error_message], frs.[error_type], frs.[error_type_desc]
    FROM sys.dm_exec_describe_first_result_set(''' + @tempSpName + N''', NULL, 1) frs;    
    '

    SET @query += N'DROP PROCEDURE ' + @tempSpName + N';    
    ';

    --SELECT @query;

    TRUNCATE TABLE #SingleStoredProcResultSet;

    INSERT INTO #SingleStoredProcResultSet 
    ([is_hidden], [column_ordinal], [name], [is_nullable], [system_type_id], [system_type_name], [max_length], [precision], [scale], [collation_name], [user_type_id], 
     [user_type_database], [user_type_schema], [user_type_name], [assembly_qualified_type_name], [xml_collection_id], [xml_collection_database], [xml_collection_schema], 
     [xml_collection_name], [is_xml_document], [is_case_sensitive], [is_fixed_length_clr_type], [source_server], [source_database], [source_schema], [source_table], 
     [source_column], [is_identity_column], [is_part_of_unique_key], [is_updateable], [is_computed_column], [is_sparse_column_set], [ordinal_in_order_by_list], 
     [order_by_is_descending], [order_by_list_length], [error_number], [error_severity], [error_state], [error_message], [error_type], [error_type_desc])
    EXEC(@query);

    --PRINT('All OK?')
    --SELECT * FROM #SingleStoredProcResultSet;

    DROP TABLE IF EXISTS #Token, #Statement, #StatementPart;
    RETURN @RC_OK;
END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcResultSet]...';


GO



CREATE PROCEDURE [Internal].[GetStoredProcResultSet]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @DFRS_ERR_MISC INT = 1;
    DECLARE @DFRS_ERR_SYNTAX INT = 2;
    DECLARE @DFRS_ERR_CONFLICTING_RESULTS INT = 3;
    DECLARE @DFRS_ERR_DYNAMIC_SQL INT = 4;
    DECLARE @DFRS_ERR_CLR_PROCEDURE INT = 5;
    DECLARE @DFRS_ERR_CLR_TRIGGER INT = 6;
    DECLARE @DFRS_ERR_EXTENDED_PROCEDURE INT = 7;
    DECLARE @DFRS_ERR_UNDECLARED_PARAMETER INT = 8;
    DECLARE @DFRS_ERR_RECURSION INT = 9;
    DECLARE @DFRS_ERR_TEMPORARY_TABLE INT = 10;
    DECLARE @DFRS_ERR_UNSUPPORTED_STATEMENT INT = 11;
    DECLARE @DFRS_ERR_OBJECT_TYPE_NOT_SUPPORTED INT = 12;
    DECLARE @DFRS_ERR_OBJECT_DOES_NOT_EXIST INT = 13;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	
	DECLARE @mapEnums TINYINT;

	SELECT @mapEnums=[MapResultSetEnums]
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @mapEnums IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @spSchema = [Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	IF @spSchema IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @tsql NVARCHAR(4000);

    TRUNCATE TABLE #SingleStoredProcResultSet;
	

	SET @tsql = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @tsql += N'EXEC ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName)
	
	--PRINT(@tsql);
	
	INSERT INTO #SingleStoredProcResultSet 
    ([is_hidden], [column_ordinal], [name], [is_nullable], [system_type_id], [system_type_name], [max_length], [precision], [scale], [collation_name], [user_type_id], 
     [user_type_database], [user_type_schema], [user_type_name], [assembly_qualified_type_name], [xml_collection_id], [xml_collection_database], [xml_collection_schema], 
     [xml_collection_name], [is_xml_document], [is_case_sensitive], [is_fixed_length_clr_type], [source_server], [source_database], [source_schema], [source_table], 
     [source_column], [is_identity_column], [is_part_of_unique_key], [is_updateable], [is_computed_column], [is_sparse_column_set], [ordinal_in_order_by_list], 
     [order_by_is_descending], [order_by_list_length], [error_number], [error_severity], [error_state], [error_message], [error_type], [error_type_desc])
    SELECT frs.[is_hidden], frs.[column_ordinal], frs.[name], frs.[is_nullable], frs.[system_type_id], frs.[system_type_name], frs.[max_length], frs.[precision], frs.[scale], 
        frs.[collation_name], frs.[user_type_id], frs.[user_type_database], frs.[user_type_schema], frs.[user_type_name], frs.[assembly_qualified_type_name], frs.[xml_collection_id], 
        frs.[xml_collection_database], frs.[xml_collection_schema], frs.[xml_collection_name], frs.[is_xml_document], frs.[is_case_sensitive], frs.[is_fixed_length_clr_type], 
        frs.[source_server], frs.[source_database], frs.[source_schema], frs.[source_table], frs.[source_column], frs.[is_identity_column], frs.[is_part_of_unique_key], 
        frs.[is_updateable], frs.[is_computed_column], frs.[is_sparse_column_set], frs.[ordinal_in_order_by_list], frs.[order_by_is_descending], frs.[order_by_list_length], 
        frs.[error_number], frs.[error_severity], frs.[error_state], frs.[error_message], frs.[error_type], frs.[error_type_desc]
    FROM sys.dm_exec_describe_first_result_set(@tsql, NULL, 1) frs;

    DECLARE @frsErrorNumber INT;
    DECLARE @frsErrorSeverity INT;
    DECLARE @frsErrorState INT;
    DECLARE @frsErrorMessage NVARCHAR(MAX);
    DECLARE @frsErrorType INT;
    DECLARE @frsErrorTypeDesc NVARCHAR(60);

    DECLARE	@returnValue int,
        @spErrorMessage nvarchar(4000);
    
    SELECT @frsErrorNumber=frs.[error_number], @frsErrorSeverity=frs.[error_severity], @frsErrorState=frs.[error_state], @frsErrorMessage=frs.[error_message], 
        @frsErrorType=frs.[error_type], @frsErrorTypeDesc=frs.[error_type_desc]
    FROM #SingleStoredProcResultSet frs;

    IF @frsErrorType IS NOT NULL AND @frsErrorType IN (@DFRS_ERR_TEMPORARY_TABLE, @DFRS_ERR_DYNAMIC_SQL, @DFRS_ERR_RECURSION, @DFRS_ERR_EXTENDED_PROCEDURE)
    BEGIN
        PRINT(N'SP: ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName));
        PRINT(N'Cannot determine result set');
        PRINT(N'sys.dm_exec_describe_first_result_set returned error #' + LOWER(@frsErrorType)+ N': ' + ISNULL(@frsErrorTypeDesc, N'<NULL>'));
        PRINT(N'Trying to get result set from a modified temporary copy of the stored procedure');
        
        EXEC @returnValue = [Parser].[TryDescribeFirstResultSetWorkaround] @projectId, @dbId,	@langId, @spId, @errorMessage = @spErrorMessage OUTPUT;
        IF @returnValue<>@RC_OK
        BEGIN
            PRINT(N'Workaround failed: ' + LOWER(@returnValue) +': ' +ISNULL(@spErrorMessage, '<NULL>'));
            SELECT * FROM #SingleStoredProcResultSet;
        END
        ELSE
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM #SingleStoredProcResultSet)
            BEGIN
                SELECT @frsErrorNumber=NULL, @frsErrorSeverity=NULL, @frsErrorState=NULL, @frsErrorMessage=NULL, @frsErrorMessage=NULL, @frsErrorType=NULL, @frsErrorTypeDesc=NULL;
            END
            ELSE
            BEGIN
                SELECT @frsErrorNumber=frs.[error_number], @frsErrorSeverity=frs.[error_severity], @frsErrorState=frs.[error_state], @frsErrorMessage=frs.[error_message], 
                    @frsErrorType=frs.[error_type], @frsErrorTypeDesc=frs.[error_type_desc]
                FROM #SingleStoredProcResultSet frs;
            END
        END
    END

    IF @frsErrorType IS NOT NULL
    BEGIN
        PRINT(N'SP: ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName));
        PRINT(N'Cannot determine result set');
        PRINT(N'sys.dm_exec_describe_first_result_set returned error #' + LOWER(@frsErrorType)+ N': ' + ISNULL(@frsErrorTypeDesc, N'<NULL>'));
        PRINT(N'ErrorNumber: ' + ISNULL(LOWER(@frsErrorNumber), N'<NULL>') + N'; ErrorSeverity: ' + ISNULL(LOWER(@frsErrorSeverity), N'<NULL>') 
            + N'; ErrorState: ' + ISNULL(LOWER(@frsErrorState), N'<NULL>') + + N'; ErrorMessage: ' + ISNULL(LOWER(@frsErrorMessage), N'<NULL>'));  
        UPDATE #StoredProc
        SET [HasUnknownResultSet]=1
        WHERE [Id]=@spId;
    END
    ELSE
    BEGIN
	    /*
	     * Join is with local sys.types view, so we can only use system types, not user defined types.	 
	     */

		--SELECT * FROM #SingleStoredProcResultSet;
	
	    INSERT INTO #StoredProcResultSet
	    ([StoredProcId], [ColumnOrdinal], [Name], [IsNullable], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [EnumId])
	    SELECT @spId, rs.[column_ordinal], rs.[name], rs.[is_nullable], st.[name], SCHEMA_NAME(st.[schema_id]), rs.[max_length], rs.[precision], rs.[scale], ISNULL(e.[EnumId], ee.[Id])
	    FROM #SingleStoredProcResultSet rs
	    JOIN sys.types st ON st.[system_type_id]=rs.[system_type_id] AND st.[user_type_id]=rs.[system_type_id]
	    LEFT JOIN #EnumForeignKey e 
	    ON @mapEnums=1 AND rs.[source_server] IS NULL AND rs.[source_database]=@dbName AND rs.[source_schema]=e.[ForeignSchema] AND rs.[source_table]=e.[ForeignTable] AND rs.[source_column]=e.[ForeignColumn]
		LEFT JOIN #Enum ee
		ON @mapEnums=1 AND rs.[source_server] IS NULL AND rs.[source_database]=@dbName AND rs.[source_schema]=ee.[Schema] AND rs.[source_table]=ee.[Table] AND rs.[source_column]=ee.[ValueColumn]
	    WHERE rs.[is_hidden]=0
	    ORDER BY rs.[column_ordinal];
	END    
END
GO
PRINT N'Creating Procedure [Internal].[GenerateCode]...';


GO
CREATE PROCEDURE [Internal].[GenerateCode]
    @projectId NVARCHAR(200),
	@dbId SMALLINT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
	DECLARE @RC_DB_ERROR INT = 1;
	DECLARE @RC_INTERNAL_ERROR INT = 2;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 3;
    
    SELECT @rc = @RC_OK, @errorMessage = NULL;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

    DECLARE @OPT_GEN_ENUMS SMALLINT = 1;
    DECLARE @OPT_GEN_RESULT_TYPES SMALLINT = 2;
    DECLARE @OPT_GEN_TVP_TYPES SMALLINT = 4;
    DECLARE @OPT_GEN_SP_WRAPPERS SMALLINT = 8;

    DECLARE @C_PASCAL_CASE TINYINT = 1;
    DECLARE @C_CAMEL_CASE TINYINT = 2;
    DECLARE @C_SNAKE_CASE TINYINT = 3;
    DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
    DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

    DECLARE @NT_CLASS TINYINT = 1;
    DECLARE @NT_METHOD TINYINT = 2;
    DECLARE @NT_PROPERTY TINYINT = 3;
    DECLARE @NT_FIELD TINYINT = 4;
    DECLARE @NT_PARAMETER TINYINT = 5;
    DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
    DECLARE @NT_TUPLE_FIELD TINYINT = 7;
    DECLARE @NT_ENUM TINYINT = 8;
    DECLARE @NT_ENUM_MEMBER TINYINT = 9;

	DECLARE @NS_TABLE_NAME TINYINT = 1;
	DECLARE @NS_STORED_PROC_NAME TINYINT = 2;
	DECLARE @NS_TABLE_TYPE_NAME TINYINT = 3;

    DECLARE @langId TINYINT;
    
	SELECT @langId=[LanguageId]  FROM [dbo].[Project] WHERE [Id]=@projectId;

    IF @langId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(LOWER(@projectId), '<NULL>');
        RETURN @rc;
    END;

    IF @dbId IS NULL 
    BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage='Unknown database: ' + ISNULL(LOWER(@dbId), '<NULL>')
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
    END;

    DROP TABLE IF EXISTS #Enum;
    CREATE TABLE #Enum
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [Schema] NVARCHAR(128) NOT NULL,
        [Table] NVARCHAR(128) NOT NULL,        
        [NameColumn] NVARCHAR(128) NOT NULL,
        [ValueColumn] NVARCHAR(128) NOT NULL,
        [EnumName] NVARCHAR(200) NULL,
        [ValueType] NVARCHAR(128) NOT NULL,
        [IsSetOfFlags] BIT NOT NULL DEFAULT (0),
        UNIQUE ([Schema], [Table])
    );

    DROP TABLE IF EXISTS #EnumVal;
    CREATE TABLE #EnumVal
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [EnumId] INT NOT NULL,        
        [Name] VARCHAR(200) NOT NULL,
        [Value] BIGINT NOT NULL,     
		[TempName] VARCHAR(200) NULL,
        UNIQUE ([EnumId], [Name]),
        UNIQUE ([EnumId], [Value]),
		UNIQUE ([EnumId], [TempName], [Value])
    );

    DROP TABLE IF EXISTS #EnumForeignKey;
    CREATE TABLE #EnumForeignKey
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [EnumId] INT NOT NULL,
        [ForeignSchema] NVARCHAR(128) NOT NULL,
        [ForeignTable] NVARCHAR(128) NOT NULL,
        [ForeignColumn] NVARCHAR(128) NOT NULL,        
        UNIQUE ([EnumId], [ForeignSchema], [ForeignTable], [ForeignColumn]),
        UNIQUE ([ForeignSchema], [ForeignTable], [ForeignColumn])        
    );

    DROP TABLE IF EXISTS #StoredProc;
    CREATE TABLE #StoredProc 
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [Schema] NVARCHAR(128) NOT NULL, 
        [Name] NVARCHAR(128) NOT NULL,
        [WrapperName] NVARCHAR(200) NULL,
        [HasResultSet] BIT NOT NULL DEFAULT (0),
        [HasUnknownResultSet] BIT NOT NULL DEFAULT (0),
        [ResultType] NVARCHAR(200) NOT NULL DEFAULT(N'int'),
        [LanguageOptionsReset] BIGINT NULL,
        [LanguageOptionsSet] BIGINT NULL,
        UNIQUE ([Schema], [Name])
    );

    DROP TABLE IF EXISTS #StoredProcParam;
    CREATE TABLE #StoredProcParam
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL,
        [ParamId] INT NOT NULL, 
        [Name] NVARCHAR(128) NOT NULL, 
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL, 
        [IsOutput] BIT NOT NULL, 
        [IsReadOnly] BIT NOT NULL, 
        [IsTypeUserDefined] BIT NOT NULL, 
        [IsTableType] BIT NOT NULL,
        [EnumId] INT NULL,
        [ParamName]  NVARCHAR(200) NULL,
        UNIQUE ([StoredProcId], [ParamId]),
        UNIQUE ([StoredProcId], [Name])
    );

    DROP TABLE IF EXISTS #SingleStoredProcResultSet;
    CREATE TABLE #SingleStoredProcResultSet (
        [is_hidden] BIT NULL,
        [column_ordinal] INT NULL,
        [name] SYSNAME NULL,
        [is_nullable] BIT NULL,
        [system_type_id] INT NULL,
        [system_type_name] NVARCHAR(256) NULL,
        [max_length] SMALLINT NULL,
        [precision] TINYINT NULL,
        [scale] TINYINT NULL,
        [collation_name] SYSNAME NULL,
        [user_type_id] INT NULL,
        [user_type_database] SYSNAME NULL,
        [user_type_schema] SYSNAME NULL,
        [user_type_name] SYSNAME NULL,
        [assembly_qualified_type_name] NVARCHAR(4000),
        [xml_collection_id] INT NULL,
        [xml_collection_database] SYSNAME NULL,
        [xml_collection_schema] SYSNAME NULL,
        [xml_collection_name] SYSNAME NULL,
        [is_xml_document] BIT NULL,
        [is_case_sensitive] BIT NULL,
        [is_fixed_length_clr_type] BIT NULL,
        [source_server] SYSNAME NULL,
        [source_database] SYSNAME NULL,
        [source_schema] SYSNAME NULL,
        [source_table] SYSNAME NULL,
        [source_column] SYSNAME NULL,
        [is_identity_column] BIT NULL,
        [is_part_of_unique_key] BIT NULL,
        [is_updateable] BIT NULL,
        [is_computed_column] BIT NULL,
        [is_sparse_column_set] BIT NULL,
        [ordinal_in_order_by_list] SMALLINT NULL,
        [order_by_list_length] SMALLINT NULL,
        [order_by_is_descending] SMALLINT NULL,
        /*
        [tds_type_id] INT NOT NULL,
        [tds_length] INT NOT NULL,
        [tds_collation_id] INT NULL,
        [tds_collation_sort_id] TINYINT NULL
        */
        [error_number] INT NULL,
        [error_severity] INT NULL,
        [error_state] INT NULL,
        [error_message] NVARCHAR(MAX) NULL,
        [error_type] INT NULL,
        [error_type_desc] NVARCHAR(60) NULL
    );

    DROP TABLE IF EXISTS #StoredProcResultSet;
    CREATE TABLE #StoredProcResultSet (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL,
        [ColumnOrdinal] INT NOT NULL,
        [Name] SYSNAME NULL,
        [IsNullable] BIT NOT NULL,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL,
        [EnumId] INT NULL,
		[PropertyName] NVARCHAR(200) NULL,
        UNIQUE ([StoredProcId], [ColumnOrdinal]),		
        UNIQUE ([StoredProcId], [PropertyName], [ColumnOrdinal])
    );

    DROP TABLE IF EXISTS #StoredProcResultType;
    CREATE TABLE #StoredProcResultType
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL UNIQUE,
        [Name] NVARCHAR(200) NOT NULL UNIQUE
    );

    DROP TABLE IF EXISTS #TableType;
    CREATE TABLE #TableType
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL,
        [Name] NVARCHAR(200) NOT NULL UNIQUE,
        UNIQUE ([SqlType], [SqlTypeSchema])
    );

    DROP TABLE IF EXISTS #TableTypeColumn;
    CREATE TABLE #TableTypeColumn
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TableTypeId] INT NOT NULL,
        [ColumnId] INT NOT NULL,
        [ColumnNumber] INT NOT NULL,
        [Name] SYSNAME NULL,
        [IsNullable] BIT NOT NULL,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL,
        [IsIdentity] BIT NOT NULL,
        [EnumId] INT NULL,
        [PropertyName] NVARCHAR(200) NULL
    );

    DECLARE    @retVal int;
    
    
    EXEC @retVal = [Internal].[GetEnums] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END
	DECLARE @hasDuplicates BIT = 0;
	DECLARE @dupNo INT = 1;

    UPDATE #Enum SET [EnumName]=[Internal].[GetNameEx](@projectId, @NT_ENUM, @NS_TABLE_NAME, [Table], [Schema]);
	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #Enum e1 JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]>e2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE e2
		SET e2.[EnumName] = [Internal].[GetName](@projectId, @NT_ENUM, e2.[EnumName] + LOWER(@dupNo), NULL)
		FROM #Enum e1 
		JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]<e2.[Id]
		LEFT JOIN #Enum ex ON e1.[EnumName]=ex.[EnumName] AND e1.[Id]>ex.[Id]
		WHERE ex.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #Enum e1 JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]>e2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    DECLARE @id INT = (SELECT MIN([Id]) FROM #Enum);
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetEnumValues] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END

        EXEC @retVal = [Internal].[GetEnumForeignKeys] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        

        SELECT @id = MIN([Id]) FROM #Enum WHERE [Id]>@id;
    END


	UPDATE #EnumVal SET [TempName]=[Internal].[GetName](@projectId, @NT_ENUM_MEMBER, [Name], NULL);
	
	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #EnumVal v1 JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]>v2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE v2
		SET v2.[TempName] = [Internal].[GetName](@projectId, @NT_ENUM_MEMBER, v2.[TempName] + LOWER(@dupNo), NULL)
		FROM #EnumVal v1 
		JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]<v2.[Id]
		LEFT JOIN #EnumVal vx ON v1.[EnumId]=vx.[EnumId] AND v1.[TempName]=vx.[TempName] AND v1.[Id]>vx.[Id]
		WHERE vx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #EnumVal v1 JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]>v2.[Id]) THEN 1 ELSE 0 END;		
		SET @dupNo += 1;
	END

	UPDATE #EnumVal SET [Name]=[TempName];

    /*
    SELECT e.[Schema], e.[Table], e.[EnumName], fk.*
    FROM #Enum e
    JOIN #EnumForeignKey fk ON fk.[EnumId]=e.[Id]
    ORDER BY e.[Id], fk.[Id];
    */

    EXEC @retVal = [Internal].[GetStoredProcedures] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

    SELECT @id=MIN([Id]) FROM #StoredProc;
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetStoredProcParams] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        
        EXEC @retVal = [Internal].[GetStoredProcResultSet] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END

        SELECT @id = MIN([Id]) FROM #StoredProc WHERE [Id]>@id;
    END

    UPDATE #StoredProc SET [WrapperName]=[Internal].[GetNameEx](@projectId, @NT_METHOD, @NS_STORED_PROC_NAME, [Name], [Schema]);

	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #StoredProc p1 JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE p2
		SET p2.[WrapperName] = [Internal].[GetName](@projectId, @NT_METHOD, p2.[WrapperName] + LOWER(@dupNo), NULL)
		FROM #StoredProc p1 
		JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]
		LEFT JOIN #StoredProc px ON p1.[WrapperName]=px.[WrapperName] AND p1.[Id]>px.[Id]
		WHERE px.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #StoredProc p1 JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END


    UPDATE sp
    SET sp.[HasResultSet]=1, sp.[ResultType]=[Internal].[GetName](@projectId, @NT_CLASS, sp.[WrapperName] + N'Result', NULL)
    FROM #StoredProc sp
    WHERE EXISTS (SELECT 1 FROM #StoredProcResultSet rs WHERE rs.[StoredProcId]=sp.[Id]);

    UPDATE sp
    SET sp.[HasResultSet]=1, sp.[ResultType]=N'dynamic'
    FROM #StoredProc sp
    WHERE sp.[HasResultSet]=0 AND sp.[HasUnknownResultSet]=1;


	UPDATE rs
	SET rs.[PropertyName]=[Internal].[GetName](@projectId, @NT_PROPERTY, rs.[Name], NULL)
	FROM #StoredProcResultSet rs;

	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #StoredProcResultSet rs1 JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE rs2
		SET rs2.[PropertyName] = [Internal].[GetName](@projectId, @NT_PROPERTY, rs2.[PropertyName] + LOWER(@dupNo), NULL)
		FROM #StoredProcResultSet rs1 
		JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
		LEFT JOIN #StoredProcResultSet rsx ON rs1.[StoredProcId]=rsx.[StoredProcId] AND rs1.[PropertyName]=rsx.[PropertyName] AND rs1.[Id]>rsx.[Id]		
		WHERE rsx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #StoredProcResultSet rs1 JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    
    INSERT INTO #StoredProcResultType ([StoredProcId], [Name])
    SELECT [Id], [ResultType]
    FROM #StoredProc
    WHERE [HasResultSet]=1 AND [HasUnknownResultSet]=0;

    UPDATE #StoredProcParam SET [ParamName]=[Internal].[GetName](@projectId, @NT_PARAMETER, [Name], NULL);
	
	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #StoredProcParam p1 JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE p2
		SET p2.[ParamName] = [Internal].[GetName](@projectId, @NT_PARAMETER, p2.[ParamName] + LOWER(@dupNo), NULL)
		FROM #StoredProcParam p1 
		JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
		LEFT JOIN #StoredProcParam px ON p1.[StoredProcId]=px.[StoredProcId] AND p1.[ParamName]=px.[ParamName] AND p1.[Id]>px.[Id]		
		WHERE px.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #StoredProcParam p1 JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END


    INSERT INTO #TableType ([SqlType], [SqlTypeSchema], [Name])
    SELECT DISTINCT spp.[SqlType], spp.[SqlTypeSchema], [Internal].[GetNameEx](@projectId, @NT_CLASS, @NS_TABLE_TYPE_NAME, spp.[SqlType], spp.[SqlTypeSchema])
    FROM #StoredProcParam spp
    WHERE spp.[IsTypeUserDefined]=1 AND spp.IsTableType=1;

	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #TableType t1 JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE t2
		SET t2.[Name] = [Internal].[GetName](@projectId, @NT_CLASS, t2.[Name] + LOWER(@dupNo), NULL)
		FROM #TableType t1 
		JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]
		LEFT JOIN #TableType tx ON t1.[Name]=tx.[Name] AND t1.[Id]>tx.[Id]
		WHERE tx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #TableType t1 JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    SELECT @id=MIN([Id]) FROM #TableType;
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetTableTypeColumns] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        
        SELECT @id = MIN([Id]) FROM #TableType WHERE [Id]>@id;
    END

    UPDATE #TableTypeColumn
    SET [PropertyName]=[Internal].[GetName](@projectId, @NT_PROPERTY, [Name], NULL);

	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #TableTypeColumn c1 JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE c2
		SET c2.[PropertyName] = [Internal].[GetName](@projectId, @NT_PROPERTY, c2.[PropertyName] + LOWER(@dupNo), NULL)
		FROM #TableTypeColumn c1 
		JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
		LEFT JOIN #TableTypeColumn cx ON c1.[TableTypeId]=cx.[TableTypeId] AND c1.[PropertyName]=cx.[PropertyName] AND c1.[Id]>cx.[Id]		
		WHERE cx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #TableTypeColumn c1 JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    --SELECT * FROM #Enum ORDER BY [Id];
    --SELECT * FROM #EnumVal ORDER BY [Id];
    --SELECT * FROM #StoredProc ORDER BY [Id];
    --SELECT * FROM #StoredProcParam ORDER BY [Id];
    --SELECT * FROM #StoredProcResultSet ORDER BY [Id];
    --SELECT * FROM #TableType;
    --SELECT * FROM #TableTypeColumn ORDER BY [Id];

    EXECUTE @retVal = [Internal].[GenerateStartCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

    
    SELECT @id=MIN([Id]) FROM #Enum;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateEnumCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #Enum WHERE [Id] > @id;
    END
    

    
    SELECT @id=MIN([Id]) FROM #StoredProcResultType;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateResultTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @rtId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #StoredProcResultType WHERE [Id] > @id;
    END

	SELECT @id=MIN([Id]) FROM #TableType;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateTableTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #TableType WHERE [Id] > @id;
    END

    SELECT @id=MIN([Id]) FROM #StoredProc;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateStoredProcWrapperCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #StoredProc WHERE [Id] > @id;
    END
    
    EXECUTE @retVal = [Internal].[GenerateEndCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END
        
    DROP TABLE IF EXISTS #Enum;
    DROP TABLE IF EXISTS #EnumVal;
    DROP TABLE IF EXISTS #StoredProc;
    DROP TABLE IF EXISTS #StoredProcParam;
    DROP TABLE IF EXISTS #SingleStoredProcResultSet;
    DROP TABLE IF EXISTS #EnumForeignKey;
    DROP TABLE IF EXISTS #StoredProcResultType;
    DROP TABLE IF EXISTS #TableType;
    DROP TABLE IF EXISTS #TableTypeColumn;

    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Project].[GenerateCode]...';


GO
CREATE PROCEDURE [Project].[GenerateCode]
    @projectName NVARCHAR(200),
    @errorMessage NVARCHAR(2000) OUTPUT,
    @databaseName NVARCHAR(128) = NULL,
    @codeGenOptions VARCHAR(1000) = NULL
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 1;
    DECLARE @RC_ERR_UNKNOWN_DB INT = 2;

    SELECT @rc = @RC_OK, @errorMessage = NULL;

    DROP TABLE IF EXISTS #Output;

    DECLARE @projectId SMALLINT;
    DECLARE @langId TINYINT;
    
	SELECT @projectId=[Id], @langId=[LanguageId], @databaseName=ISNULL(@databaseName, [DefaultDatabase]) FROM [dbo].[Project] WHERE [Name]=@projectName;

    IF @projectId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(@projectName, '<NULL>');
        RETURN @rc;
    END;

    DECLARE @dbId SMALLINT = DB_ID(@databaseName);

    IF @dbId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_DB, @errorMessage = 'Unknown database: ' + ISNULL(@databaseName, '<NULL>')
        RETURN @rc;
    END;

    DECLARE    @retVal int;
    
    CREATE TABLE #Output
	(
		[Id] INT IDENTITY(1,1) PRIMARY KEY,
		[CodePartId] TINYINT NULL,     -- for now mustr be NULLable, untill we would fix all [Internal].[Generate*Code] SPs
		[Schema] NVARCHAR(128) NULL,    -- Optional: e.g., for grouping (Enums, TVPs)
		[Text] NVARCHAR(MAX) NOT NULL
	);

    
    EXECUTE @retVal = [Internal].[GenerateCode] @projectId = @projectId, @dbId = @dbId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

	SELECT [Text]
    FROM #Output
    ORDER BY [Id];
    
    DROP TABLE IF EXISTS #Output;
    
    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
PRINT N'Creating Procedure [Toolkit].[GenerateCode]...';


GO
CREATE PROCEDURE [Toolkit].[GenerateCode]
    @projectId SMALLINT,
	@databaseName NVARCHAR(128),
	@loggingLevelId TINYINT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 1;
    DECLARE @RC_ERR_UNKNOWN_DB INT = 2;

    SELECT @rc = @RC_OK, @errorMessage = NULL;

    DROP TABLE IF EXISTS #Output;

    DECLARE @OPT_GEN_ENUMS SMALLINT = 1;
    DECLARE @OPT_GEN_RESULT_TYPES SMALLINT = 2;
    DECLARE @OPT_GEN_TVP_TYPES SMALLINT = 4;
    DECLARE @OPT_GEN_SP_WRAPPERS SMALLINT = 8;

    DECLARE @langId TINYINT;
    
    SELECT @langId=[LanguageId], @databaseName=ISNULL(@databaseName, [DefaultDatabase]) 
	FROM [dbo].[Project] 
	WHERE [Id]=@projectId;

    IF @projectId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(LOWER(@projectId), '<NULL>');
        RETURN @rc;
    END;

    DECLARE @dbId SMALLINT = DB_ID(@databaseName);

    IF @dbId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_DB, @errorMessage = 'Unknown database: ' + ISNULL(@databaseName, '<NULL>')
        RETURN @rc;
    END;

    DECLARE @retVal int;
    
    CREATE TABLE #Output
	(
		[Id] INT IDENTITY(1,1) PRIMARY KEY,
		[CodePartId] TINYINT NOT NULL,
		[Schema] NVARCHAR(128) NULL,    -- Optional: e.g., for grouping (Enums, TVPs)
		[Text] NVARCHAR(MAX) NOT NULL
	);

    
    EXECUTE @retVal = [Internal].[GenerateCode] @projectId = @projectId, @dbId = @dbId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

	SELECT o.[Id], cp.[Id] [CodePartId], o.[Schema], o.[Text]
    FROM #Output o
	JOIN [Enum].[CodePart] cp ON cp.[Id]=o.[CodePartId]
    ORDER BY o.[Id];
    
    DROP TABLE IF EXISTS #Output;
    
    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
/*
Post-Deployment Script							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- table [Enum].[Status]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=1) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (1, N'Active');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=2) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (2, N'Experimental');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=3) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (3, N'Deprecated');


-- table [Enum].[Language]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Language] WHERE [Id]=1) 
INSERT INTO [Enum].[Language] ([Id], [Name], [Code], [StatusId]) 
VALUES (1, N'c#', N'CSharp', 1);


-- table [Enum].[ClassAccess]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=1) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (1, N'public');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=2) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (2, N'protected');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=3) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (3, N'private');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=4) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (4, N'internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=5) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (5, N'protected internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=6) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (6, N'private protected');


-- table [Enum].[Casing]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=1) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (1, N'PascalCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=2) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (2, N'CamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=3) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (3, N'SnakeCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=4) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (4, N'UnderscoreCamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=5) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (5, N'UpperSnakeCase');


-- table [Enum].[ParamEnumMapping]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=1) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (1, N'ExplicitOnly');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=2) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (2, N'EnumName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=3) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (3, N'EnumNameWithId');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=4) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (4, N'EnumNameWithOrWithoutId');


-- table [Enum].[TemplateType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=1) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (1, N'StartComment');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=2) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (2, N'End');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=3) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (3, N'EnumStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=4) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (4, N'EnumEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=5) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (5, N'EnumEntry');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=6) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (6, N'ResultTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=7) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (7, N'ResultTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=8) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (8, N'ResultTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=10) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (10, N'WrapperStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=11) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (11, N'WrapperEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=12) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (12, N'WrapperPrep');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=13) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (13, N'WrapperExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=14) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (14, N'WrapperParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=15) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (15, N'WrapperParamPreExecInput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=16) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (16, N'WrapperParamPreExecOutput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=17) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (17, N'WrapperExecRS');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=19) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (19, N'WrapperParamPostExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=20) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (20, N'WrapperStart2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=21) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (21, N'WrapperReturnParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=22) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (22, N'WrapperEnd2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=23) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (23, N'WrapperReturnParamDec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=24) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (24, N'TableTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=25) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (25, N'TableTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=26) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (26, N'TableTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=27) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (27, N'WrapperParamPreExecTableType');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=28) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (28, N'TableTypeDtStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=29) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (29, N'TableTypeDtEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=30) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (30, N'TableTypeDtColumn');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=31) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (31, N'TableTypeDtRowsStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=32) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (32, N'TableTypeDtRowsEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=33) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (33, N'TableTypeDtRow');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=34) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (34, N'TableTypeDtColumnAdd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=35) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (35, N'TableTypeDtColumnMaxLen');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=36) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (36, N'TableTypeDtRowNull');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=37) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (37, N'StartUsing');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=38) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (38, N'StartClass');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=39) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (39, N'StartCommentTool');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=40) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (40, N'StartCommentEnv');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=41) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (41, N'StartCommentEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=42) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (42, N'StaticCtorEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=43) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (43, N'RsMappingSetup');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=44) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (44, N'TableTypeDtColumnIdentity');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=45) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (45, N'TableTypeDtColumnPrecisionScale');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=46) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (46, N'WrapperExecRsRv');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=47) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (47, N'EnumStartFlag');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=48) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (48, N'WrapperEnumStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=49) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (49, N'WrapperEnumEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=50) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (50, N'WrapperEnumItem');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=51) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (51, N'StartClassBootstrap');


-- table [Enum].[NameType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=1) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (1, N'Class');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=2) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (2, N'Method');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=3) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (3, N'Property');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=4) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (4, N'Field');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=5) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (5, N'Parameter');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=6) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (6, N'LocalVariable');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=7) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (7, N'TupleField');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=8) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (8, N'Enum');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=9) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (9, N'EnumMember');


-- table: [Static].[DataTypeMap]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'tinyint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'tinyint', N'byte', N'SqlDbType.TinyInt', N'DbType.Byte', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallint', N'short', N'SqlDbType.SmallInt', N'DbType.Int16', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'int') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'int', N'int', N'SqlDbType.Int', N'DbType.Int32', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bigint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bigint', N'long', N'SqlDbType.BigInt', N'DbType.Int64', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varchar', N'string', N'SqlDbType.VarChar', N'DbType.AnsiString', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'char') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'char', N'string', N'SqlDbType.Char', N'DbType.AnsiStringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nvarchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nvarchar', N'string', N'SqlDbType.NVarChar', N'DbType.String', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nchar', N'string', N'SqlDbType.NChar', N'DbType.StringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'date') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'date', N'DateOnly', N'SqlDbType.Date', N'DbType.Date', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'time') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'time', N'TimeOnly', N'SqlDbType.Time', N'DbType.Time', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime2') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime2', N'DateTime', N'SqlDbType.DateTime2', N'DbType.DateTime2', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetimeoffset') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetimeoffset', N'DateTimeOffset', N'SqlDbType.DateTimeOffset', N'DbType.DateTimeOffset', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smalldatetime') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smalldatetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'real') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'real', N'float', N'SqlDbType.Real', N'DbType.Single', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'float') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'float', N'double', N'SqlDbType.Float', N'DbType.Double', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'money') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'money', N'decimal', N'SqlDbType.Money', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'decimal') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'decimal', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'numeric') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'numeric', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallmoney') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallmoney', N'decimal', N'SqlDbType.SmallMoney', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bit') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bit', N'bool', N'SqlDbType.Bit', N'DbType.Boolean', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varbinary') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varbinary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'binary') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'binary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'uniqueidentifier') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'uniqueidentifier', N'Guid', N'SqlDbType.UniqueIdentifier', N'DbType.Guid', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'sql_variant') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'sql_variant', N'object', N'SqlDbType.Variant', N'DbType.Object', 1, 0, 0, 0);


-- table: [Static].[LanguageNameCasing]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=1) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=2) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 2, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=3) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 3, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=4) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 4, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=5) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 5, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=6) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 6, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=7) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 7, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=8) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 8, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=9) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 9, 1);


-- table [Enum].[NameMatch]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=1) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (1, N'ExactMatch');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=2) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (2, N'Prefix');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=3) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (3, N'Suffix');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=4) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (4, N'Like');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=255) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (255, N'Any');


-- table [Enum].[NameSource]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=1) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (1, N'TableName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=2) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (2, N'StoredProcName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=3) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (3, N'TableTypeName');


-- table [Enum].[NamePartType]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=1) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (1, N'TableNamePreffix', 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=2) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (2, N'TableNameSuffix', 1, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=3) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (3, N'StoredProcNamePrefix', 2, 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=4) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (4, N'StoredProcNameSuffix', 2, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=5) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (5, N'TableTypeNamePrefix', 3, 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=6) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (6, N'TableTypeNameSuffix', 3, 0, 1);


-- table [Enum].[ToolkitResponseCode]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=0) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (0, N'Ok', N'Operation completed successfully.', 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1, N'DbError', N'An unexpected database error occured.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=2) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (2, N'InternalError', N'An unexpected internal error occurred.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=3) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (3, N'UnknownProject', N'The specified project does not exist.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=4) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (4, N'InvalidDefaultDatabase', N'The provided default database is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=11) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (11, N'InvalidSchema', N'The provided schema is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=12) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (12, N'InvalidEnumPattern', N'Invalid enum name match pattern.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=13) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (13, N'InvalidProcPattern', N'Invalid stored procedure name match pattern.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=14) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (14, N'InvalidClassAccess', N'Invalid class access.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=15) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (15, N'InvalidLanguage', N'Invalid programming language.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=16) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (16, N'InvalidParamEnumMapping', N'Invalid enum mapping for parameters.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=17) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (17, N'InvalidDatabase', N'The provided database is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=18) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (18, N'UnknownEnum', N'Unknown enum', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=19) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (19, N'UnknownResultType', N'Unknown result type', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=20) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (20, N'UnknownTableType', N'Unknown table type', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=21) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (21, N'UnknownStoredProcedure', N'Unknown stored procedure', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=22) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (22, N'DuplicateProject', N'Project with provided name already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=23) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (23, N'NamePatternNotProvided', N'Name pattern must be provided', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=24) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (24, N'DuplicateEnumMapping', N'Project enum mapping already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=25) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (25, N'DuplicateStoredProcMapping', N'Project stored procedures mapping already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=26) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (26, N'UnexpectedEscChar', N'Unexpected escape character', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=27) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (27, N'SchemaNotProvided', N'Name pattern must be provided', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=28) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (28, N'UnknownStoredProcMapping', N'Stored procedure mapping not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=29) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (29, N'UnknownEnumMapping', N'Enum mapping not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=30) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (30, N'InvalidNamePartType', N'Invalid name part type.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=31) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (31, N'UnknownNameNormalization', N'The specified name normalization entry does not exist for this project.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1000) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1000, N'CliUnhandledException', N'Unexpected application error', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1001) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1001, N'CliFileWriteError', N'Failed to write to output file', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1002) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1002, N'CliInvalidArguments', N'Invalid command-line arguments', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1003) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1003, N'CliInteractiveNotAllowed', N'Prompt attempted in non-interactive mode', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1004) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1004, N'CliMissingConnection', N'Named connection not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1005) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1005, N'CliMissingProject', N'Project not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1006) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1006, N'CliCodeGenerationFailed', N'Code generation failed', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1007) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1007, N'CliMissingParameter', N'Missing command parameter', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1008) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1008, N'CliNoItemsAvailable', N'No selectable items available in CLI prompt', 0);


-- table [Enum].[CodePart]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=1) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (1, N'H', N'CodeHeader');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=2) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (2, N'B', N'CodeBootstrap');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=3) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (3, N'E', N'Enums');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=4) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (4, N'R', N'ResultTypes');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=5) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (5, N'T', N'TvpTypes');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=6) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (6, N'W', N'SpWrappers');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=7) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (7, N'Z', N'CodeEnd');


-- table [Enum].[LoggingLevel]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=1) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (1, N'E', N'Error');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=2) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (2, N'W', N'Warning');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=3) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (3, N'I', N'Info');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=4) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (4, N'D', N'Debug');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=5) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (5, N'T', N'Trace');



-- Completion time: 2025-07-05T16:28:58.8623960+01:00

-- table [Static].[LanguageOption]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='GenerateStaticClass')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'GenerateStaticClass', 0x0000000000000001, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='TreatOutputParamsAsInputOutput')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'TreatOutputParamsAsInputOutput', 0x0000000000000002, 1);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='CaptureReturnValueForResultSetStoredProcedures')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'CaptureReturnValueForResultSetStoredProcedures', 0x0000000000000004, 1);
END;


IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='OutputMinimalEnvInfo')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'OutputMinimalEnvInfo', 0x0000000000000008, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='OutputMinimalToolInfo')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'OutputMinimalToolInfo', 0x0000000000000010, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId]=1 AND [Name]='TargetClassicDotNet')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (1, 'TargetClassicDotNet', 0x0000000000010000, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId]=1 AND [Name]='UseSyncWrappers')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (1, 'UseSyncWrappers', 0x0000000000020000, 1);
END;



-- Completion time: 2025-07-05T15:59:22.4522379+01:00

DROP TABLE IF EXISTS #Template;
GO

CREATE TABLE #Template
(
    [Id] [smallint] IDENTITY(1,1) NOT NULL PRIMARY KEY,
    [LanguageId] [tinyint] NOT NULL,
    [TypeId] [tinyint] NOT NULL,
    [LanguageOptions] BIGINT NOT NULL DEFAULT(0),
    [Template] [nvarchar](4000) NOT NULL,
    UNIQUE ([LanguageId], [TypeId], [LanguageOptions])
);
GO

DECLARE @langId TINYINT = (SELECT [Id] FROM [Enum].[Language] WHERE [Name] = 'c#');

DECLARE @TT_START_COMMENT TINYINT = 1;
DECLARE @TT_END TINYINT = 2;
DECLARE @TT_ENUM_START TINYINT = 3;
DECLARE @TT_ENUM_END TINYINT = 4;
DECLARE @TT_ENUM_ENTRY TINYINT = 5;
DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;
DECLARE @TT_WRAPPER_START TINYINT = 10;
DECLARE @TT_WRAPPER_END TINYINT = 11;
DECLARE @TT_WRAPPER_PREP TINYINT = 12;
DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
DECLARE @TT_WRAPPER_START2 TINYINT = 20;
DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
DECLARE @TT_WRAPPER_END2 TINYINT = 22;
DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;
DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;
DECLARE @TT_START_USING TINYINT = 37;
DECLARE @TT_START_CLASS TINYINT = 38;
DECLARE @TT_START_COMMENT_TOOL TINYINT = 39;
DECLARE @TT_START_COMMENT_ENV TINYINT = 40;
DECLARE @TT_START_COMMENT_END TINYINT = 41;
DECLARE @TT_STATIC_CTOR_END TINYINT = 42;
DECLARE @TT_RS_MAPPING_SETUP TINYINT = 43;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_IDENTITY TINYINT = 44;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE TINYINT = 45;
DECLARE @TT_WRAPPER_EXEC_RS_RV TINYINT = 46;
DECLARE @TT_ENUM_START_FLAG TINYINT = 47;
DECLARE @TT_WRAPPER_ENUM_START TINYINT = 48;
DECLARE @TT_WRAPPER_ENUM_END TINYINT = 49;
DECLARE @TT_WRAPPER_ENUM_ITEM TINYINT = 50;
DECLARE @TT_START_CLASS_BOOTSTRAP TINYINT = 51;

DECLARE @LO_GENERATE_STATIC_CLASS BIGINT = 1;
DECLARE @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT BIGINT = 2;
DECLARE @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES BIGINT = 4;
DECLARE @LO_OUTPUT_MINIMAL_ENV_INFO BIGINT = 8;
DECLARE @LO_OUTPUT_MINIMAL_TOOL_INFO BIGINT = 16;
DECLARE @LO_TARGET_CLASSIC_DOT_NET BIGINT = 65536;
DECLARE @LO_USE_SYNC_WRAPPERS BIGINT = 131072;

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT, 
N'// <auto-generated>
//     This code was generated by a tool.
//
//     Project name:    @{ProjectName}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_ENV, 
N'//     Source database: @{Database}
//     Source server:   @{ServerName}
//     Source instance: @{InstanceName}
//     Database user:   @{DbUser}
//     Timestamp:       @{Timestamp}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_COMMENT_ENV, @LO_OUTPUT_MINIMAL_ENV_INFO, 
N'//     Source database: @{Database}
//     Timestamp:       @{Timestamp}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_TOOL, 
N'//     Tool name:       @{ToolName}
//     Tool database:   @{ToolDatabase}
//     Tool version:    @{ToolVersion}
//     Tool URL:        @{ToolUrl}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_COMMENT_TOOL, @LO_OUTPUT_MINIMAL_TOOL_INFO, 
N'//     Tool name:       @{ToolName}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_END, 
N'//
//     Changes to this file may cause incorrect behavior 
//     and will be lost if the code is regenerated.
// </auto-generated>
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_USING,
N'using System.Data;
using System.Data.Common;
using System.Threading;
using Microsoft.Data.SqlClient;
using Microsoft.Data.SqlClient.Server;
using Dapper;
');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_USING, @LO_TARGET_CLASSIC_DOT_NET,
N'using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SqlServer.Server;
using Dapper;
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_USING, @LO_TARGET_CLASSIC_DOT_NET | @LO_USE_SYNC_WRAPPERS,
N'using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SqlServer.Server;
using Dapper;
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_CLASS,
N'namespace @{NamespaceName}
{
    @{ClassAccess} partial class @{ClassName}
    {
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_CLASS, @LO_GENERATE_STATIC_CLASS,
N'namespace @{NamespaceName}
{
    @{ClassAccess} static partial class @{ClassName}
    {        
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_CLASS_BOOTSTRAP,
N'
        public string ConnectionString { get; set; }

        public int DefaultCommandTimeoutSec { get; set; } = 30;
        
        public @{ClassName}(string connectionString = null)
        {
            ConnectionString = connectionString;
        }

        protected virtual DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }

        [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
        public class ColumnAttribute : Attribute
        {
            public string Name { get; set; }
        }

        public class WrapperSettings
        {
            public int? CommandTimeoutSec { get; set; } = null;
        }

        public Dictionary<StoredProcedureWrapper, WrapperSettings> StoredProcedureWrapperSettings { get; private set; } = new Dictionary<StoredProcedureWrapper, WrapperSettings>();

        public void SetCommandTimeout(StoredProcedureWrapper wrapper, int commandTimeoutSec)
        {
            if (!StoredProcedureWrapperSettings.ContainsKey(wrapper))
            {
                StoredProcedureWrapperSettings[wrapper] = new WrapperSettings();
            }
            StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec = commandTimeoutSec;
        }

        public int GetCommandTimeout(StoredProcedureWrapper wrapper)
        {
            if (StoredProcedureWrapperSettings.ContainsKey(wrapper) && StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.HasValue)
            {
                return StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.Value;
            }
            return DefaultCommandTimeoutSec;
        }

        static @{ClassName}()
        {
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_CLASS_BOOTSTRAP, @LO_GENERATE_STATIC_CLASS,
N'
        public static string ConnectionString { get; set; }

        public static int DefaultCommandTimeoutSec { get; set; } = 30;
        
        private static DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }

        [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
        public class ColumnAttribute : Attribute
        {
            public string Name { get; set; }
        }

        public class WrapperSettings
        {
            public int? CommandTimeoutSec { get; set; } = null;
        }

        public static Dictionary<StoredProcedureWrapper, WrapperSettings> StoredProcedureWrapperSettings { get; private set; } = new Dictionary<StoredProcedureWrapper, WrapperSettings>();

        public static void SetCommandTimeout(StoredProcedureWrapper wrapper, int commandTimeoutSec)
        {
            if (!StoredProcedureWrapperSettings.ContainsKey(wrapper))
            {
                StoredProcedureWrapperSettings[wrapper] = new WrapperSettings();
            }
            StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec = commandTimeoutSec;
        }

        public static int GetCommandTimeout(StoredProcedureWrapper wrapper)
        {
            if (StoredProcedureWrapperSettings.ContainsKey(wrapper) && StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.HasValue)
            {
                return StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.Value;
            }
            return DefaultCommandTimeoutSec;
        }
        
        static @{ClassName}()
        {
');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_STATIC_CTOR_END, 
N'        }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RS_MAPPING_SETUP, 
N'            SqlMapper.SetTypeMap(
                typeof(@{RsType}),
                new CustomPropertyTypeMap(
                    typeof(@{RsType}),
                    (type, columnName) =>
                        type.GetProperties().FirstOrDefault(prop =>
                            prop.GetCustomAttributes(false)
                                .OfType<ColumnAttribute>()
                                .Any(attr => attr.Name == columnName))));
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_END, 
N'
    }
}
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_START, 
N'
        @{EnumAccess} enum @{EnumName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_END, 
N'        }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_ITEM, N'            @{Name}@{Sep}');



INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_START, 
N'
        // Source table: @{EnumSchema}.@{EnumTable}
        @{EnumAccess} enum @{EnumName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_START_FLAG, 
N'
        // Source table: @{EnumSchema}.@{EnumTable}
        [Flags]
        @{EnumAccess} enum @{EnumName}
        {');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_ENTRY, N'            @{Name} = @{Value}@{Sep}');





INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_START, 
N'
        // Result type for a stored procedure: @{SpSchema}.@{SpName}
        @{ClassAccess} partial class @{ClassName}
        {');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_PROPERTY, 
N'            [Column(Name="@{ColumnName}")]
            @{PropertyAccess} @{Type} @{Name} { get; set; }');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START, 
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} async Task<@{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_GENERATE_STATIC_CLASS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} static async Task<@{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_USE_SYNC_WRAPPERS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} @{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_GENERATE_STATIC_CLASS | @LO_USE_SYNC_WRAPPERS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} static @{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START2, 
N'        @{TupleEnd}> @{WrapperName}Async(');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START2, @LO_USE_SYNC_WRAPPERS,
N'        @{TupleEnd} @{WrapperName}(');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PREP, 
N'            CancellationToken cancellationToken = default
        )
        {
            @{ResultType} @{ResultVarName};
            var p = new DynamicParameters();
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PREP, @LO_USE_SYNC_WRAPPERS, 
N'        )
        {
            @{ResultType} @{ResultVarName};
            var p = new DynamicParameters();
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC, N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                await connection.ExecuteAsync(command);
                connection.Close();
            }
            @{ResultVarName} = p.Get<@{ResultType}>("@returnValue");
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS, N'
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                var queryResult = await connection.QueryAsync<@{ResultTypeSingle}>(command);
                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS_RV, N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);

            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                var queryResult = await connection.QueryAsync<@{ResultTypeSingle}>(command);
                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
            var @{RetValVarName} = p.Get<int>("@returnValue");
');



INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC, @LO_USE_SYNC_WRAPPERS, 
N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            
            using (var connection = GetDbConnection())
            {
                connection.Open();
                connection.Execute("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);
                connection.Close();
            }
            @{ResultVarName} = p.Get<@{ResultType}>("@returnValue");
');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS, @LO_USE_SYNC_WRAPPERS,
N'
            using (var connection = GetDbConnection())
            {
                connection.Open();

                var queryResult = connection.Query<@{ResultTypeSingle}>("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);

                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS_RV, @LO_USE_SYNC_WRAPPERS,
N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            using (var connection = GetDbConnection())
            {
                connection.Open();

                var queryResult = connection.Query<@{ResultTypeSingle}>("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);

                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
            var @{RetValVarName} = p.Get<int>("@returnValue");
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END, 
N'            return @{TupleStart}
                @{ResultVarName}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END2, 
N'            @{TupleEnd};
        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM, N'            @{Type} @{ParamName}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM, N'                @{ParamName}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM_DEC, N'            @{Type} @{ParamName}@{Sep}');



INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_INPUT, N'            p.Add("@{Name}", @{TypeCast}@{ParamName});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT, N'            p.Add("@{Name}", null, @{DbType}, ParameterDirection.Output, @{Size}, @{Precision}, @{Scale});');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT, @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT, 
N'            p.Add("@{Name}", @{ParamName}, @{DbType}, ParameterDirection.InputOutput, @{Size}, @{Precision}, @{Scale});');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE, N'
            var @{DtName} = @{TableType}.ToSqlDataRecords(@{ParamName});            
            p.Add("@{Name}", @{DtName}.AsTableValuedParameter("@{TvpName}"));
            ');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_POST_EXEC, N'            var @{ParamName} = @{TypeCast}p.Get<@{Type}>("@{Name}");');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_POST_EXEC, @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT, N'            @{ParamName} = @{TypeCast}p.Get<@{Type}>("@{Name}");');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_START, 
N'
        // Table type: @{TtSchema}.@{TtName}
        @{ClassAccess} partial class @{ClassName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_PROPERTY, N'            @{PropertyAccess} @{Type} @{Name} { get; set; }');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_START, 
N'
            public static IEnumerable<SqlDataRecord> ToSqlDataRecords(IEnumerable<@{ClassName}> records)        
            {
                var table = new List<SqlDataRecord>();
                var columns = new SqlMetaData[@{NumberOfColumns}];                
                SqlMetaData column;
                SqlDataRecord row;
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_END, 
N'                return table;
            }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, @{MaxLength});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_IDENTITY, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, true, false, SortOrder.Unspecified, -1);');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, @{Precision}, @{Scale});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_ADD, 
N'                columns[@{ColumnNumber}] = column;
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_START, 
N'                foreach (var record in records)
                {
                    row = new SqlDataRecord(columns);');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_END, 
N'                    table.Add(row);  
                }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW, 
N'                row.SetValue(@{ColumnNumber}, @{Cast}record.@{Name});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW_NULL, 
N'                row.SetValue(@{ColumnNumber}, (object)(@{Cast}record.@{Name}) ?? DBNull.Value);');


GO



UPDATE xt
SET xt.[Template]=t.[Template]
FROM #Template t
JOIN [Static].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId] AND t.[LanguageOptions]=xt.[LanguageOptions]

GO

INSERT INTO [Static].[Template]
([LanguageId], [TypeId], [LanguageOptions], [Template])
SELECT 
t.[LanguageId], t.[TypeId], t.[LanguageOptions], t.[Template]
FROM #Template t
LEFT JOIN [Static].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId] AND t.[LanguageOptions]=xt.[LanguageOptions]
WHERE xt.[Id] IS NULL;
GO

DROP TABLE IF EXISTS #Template;
GO


-- table [ParserEnum].[TSqlSequenceType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (1, N'Normal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (2, N'AnyStatement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (3, N'BlockStatement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (4, N'SequenceOfStatements');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (5, N'TwoPartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (6, N'ThreePartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (7, N'MoreTokens');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (8, N'Label');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (9, N'BeginBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (10, N'EndBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (11, N'SequenceInParentheses');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (12, N'FourPartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (13, N'ScalarExpression');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (14, N'OutputClause');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (15, N'CaseExpression');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (16, N'VarAssign');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (17, N'SpNumber');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (18, N'IdentifierDot');


-- table [ParserEnum].[TSqlBlockType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (1, N'RegularBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (2, N'TryBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (3, N'CatchBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (4, N'AtomicBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (5, N'CaseBlock');


-- table [ParserEnum].[TSqlStatementPart]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (1, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (2, N'StartOfParameterList');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (3, N'Definition');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (4, N'ChildStatement');


-- table [ParserEnum].[TokenType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=0) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (0, N'None');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (1, N'Whitespace');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (2, N'Comment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (3, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (4, N'Keyword');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (5, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (6, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (7, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (8, N'Literal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=255) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (255, N'Unknown');


-- table [ParserEnum].[TSqlKeyword]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (1, N'ADD');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (2, N'ALL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (3, N'ALTER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (4, N'AND');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (5, N'ANY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (6, N'AS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (7, N'ASC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (8, N'AUTHORIZATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (9, N'BACKUP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (10, N'BEGIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (11, N'BETWEEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (12, N'BREAK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (13, N'BROWSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (14, N'BULK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (15, N'BY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (16, N'CASCADE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (17, N'CASE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (18, N'CHECK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=19) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (19, N'CHECKPOINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=20) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (20, N'CLOSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=21) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (21, N'CLUSTERED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=22) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (22, N'COALESCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=23) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (23, N'COLLATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=24) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (24, N'COLUMN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=25) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (25, N'COMMIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=26) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (26, N'COMPUTE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=27) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (27, N'CONSTRAINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=28) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (28, N'CONTAINS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=29) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (29, N'CONTAINSTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=30) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (30, N'CONTINUE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=31) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (31, N'CONVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=32) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (32, N'CREATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=33) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (33, N'CROSS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=34) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (34, N'CURRENT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=35) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (35, N'CURRENT_DATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=36) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (36, N'CURRENT_TIME');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=37) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (37, N'CURRENT_TIMESTAMP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=38) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (38, N'CURRENT_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=39) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (39, N'CURSOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=40) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (40, N'DATABASE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=41) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (41, N'DBCC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=42) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (42, N'DEALLOCATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=43) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (43, N'DECLARE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=44) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (44, N'DEFAULT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=45) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (45, N'DELETE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=46) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (46, N'DENY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=47) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (47, N'DESC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=48) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (48, N'DISK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=49) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (49, N'DISTINCT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=50) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (50, N'DISTRIBUTED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=51) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (51, N'DOUBLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=52) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (52, N'DROP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=53) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (53, N'DUMP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=54) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (54, N'ELSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=55) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (55, N'END');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=56) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (56, N'ERRLVL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=57) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (57, N'ESCAPE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=58) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (58, N'EXCEPT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=59) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (59, N'EXEC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=60) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (60, N'EXECUTE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=61) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (61, N'EXISTS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=62) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (62, N'EXIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=63) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (63, N'EXTERNAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=64) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (64, N'FETCH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=65) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (65, N'FILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=66) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (66, N'FILLFACTOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=67) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (67, N'FOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=68) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (68, N'FOREIGN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=69) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (69, N'FREETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=70) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (70, N'FREETEXTTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=71) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (71, N'FROM');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=72) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (72, N'FULL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=73) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (73, N'FUNCTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=74) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (74, N'GOTO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=75) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (75, N'GRANT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=76) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (76, N'GROUP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=77) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (77, N'HAVING');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=78) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (78, N'HOLDLOCK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=79) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (79, N'IDENTITY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=80) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (80, N'IDENTITY_INSERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=81) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (81, N'IDENTITYCOL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=82) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (82, N'IF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=83) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (83, N'IN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=84) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (84, N'INDEX');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=85) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (85, N'INNER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=86) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (86, N'INSERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=87) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (87, N'INTERSECT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=88) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (88, N'INTO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=89) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (89, N'IS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=90) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (90, N'JOIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=91) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (91, N'KEY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=92) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (92, N'KILL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=93) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (93, N'LEFT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=94) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (94, N'LIKE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=95) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (95, N'LINENO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=96) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (96, N'LOAD');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=97) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (97, N'MERGE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=98) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (98, N'NATIONAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=99) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (99, N'NOCHECK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=100) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (100, N'NONCLUSTERED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=101) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (101, N'NOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=102) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (102, N'NULL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=103) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (103, N'NULLIF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=104) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (104, N'OF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=105) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (105, N'OFF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=106) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (106, N'OFFSETS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=107) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (107, N'ON');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=108) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (108, N'OPEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=109) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (109, N'OPENDATASOURCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=110) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (110, N'OPENQUERY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=111) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (111, N'OPENROWSET');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=112) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (112, N'OPENXML');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=113) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (113, N'OPTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=114) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (114, N'OR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=115) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (115, N'ORDER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=116) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (116, N'OUTER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=117) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (117, N'OVER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=118) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (118, N'PERCENT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=119) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (119, N'PIVOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=120) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (120, N'PLAN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=121) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (121, N'PRECISION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=122) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (122, N'PRIMARY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=123) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (123, N'PRINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=124) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (124, N'PROC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=125) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (125, N'PROCEDURE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=126) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (126, N'PUBLIC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=127) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (127, N'RAISERROR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=128) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (128, N'READ');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=129) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (129, N'READTEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=130) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (130, N'RECONFIGURE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=131) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (131, N'REFERENCES');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=132) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (132, N'REPLICATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=133) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (133, N'RESTORE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=134) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (134, N'RESTRICT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=135) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (135, N'RETURN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=136) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (136, N'REVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=137) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (137, N'REVOKE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=138) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (138, N'RIGHT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=139) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (139, N'ROLLBACK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=140) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (140, N'ROWCOUNT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=141) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (141, N'ROWGUIDCOL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=142) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (142, N'RULE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=143) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (143, N'SAVE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=144) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (144, N'SCHEMA');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=145) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (145, N'SECURITYAUDIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=146) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (146, N'SELECT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=147) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (147, N'SEMANTICKEYPHRASETABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=148) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (148, N'SEMANTICSIMILARITYDETAILSTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=149) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (149, N'SEMANTICSIMILARITYTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=150) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (150, N'SESSION_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=151) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (151, N'SET');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=152) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (152, N'SETUSER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=153) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (153, N'SHUTDOWN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=154) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (154, N'SOME');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=155) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (155, N'STATISTICS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=156) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (156, N'SYSTEM_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=157) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (157, N'TABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=158) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (158, N'TABLESAMPLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=159) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (159, N'TEXTSIZE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=160) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (160, N'THEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=161) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (161, N'TO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=162) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (162, N'TOP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=163) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (163, N'TRAN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=164) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (164, N'TRANSACTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=165) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (165, N'TRIGGER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=166) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (166, N'TRUNCATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=167) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (167, N'TRY_CONVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=168) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (168, N'TSEQUAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=169) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (169, N'UNION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=170) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (170, N'UNIQUE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=171) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (171, N'UNPIVOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=172) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (172, N'UPDATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=173) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (173, N'UPDATETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=174) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (174, N'USE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=175) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (175, N'USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=176) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (176, N'VALUES');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=177) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (177, N'VARYING');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=178) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (178, N'VIEW');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=179) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (179, N'WAITFOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=180) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (180, N'WHEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=181) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (181, N'WHERE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=182) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (182, N'WHILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=183) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (183, N'WITH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=184) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (184, N'WITHIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=185) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (185, N'WRITETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=186) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (186, N'ATOMIC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=187) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (187, N'CONVERSATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=188) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (188, N'DIALOG');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=189) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (189, N'CATCH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=190) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (190, N'TRY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=191) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (191, N'THROW');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=192) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (192, N'FILETABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=193) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (193, N'OUTPUT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=194) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (194, N'LOGIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=195) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (195, N'AT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=196) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (196, N'DATA_SOURCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=197) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (197, N'RECOMPILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=198) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (198, N'RESULT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=199) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (199, N'SETS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=200) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (200, N'UNDEFINED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=201) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (201, N'NONE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=32767) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (32767, N'<MORE_THAN_ONE>');


-- table [ParserEnum].[CharType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=0) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (0, N'Unknown');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (1, N'Letter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (2, N'UnicodeLetter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (3, N'Digit');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (4, N'UnicodeDigit');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (5, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (6, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (7, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (8, N'Special');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (9, N'Whitespace');


-- table [ParserEnum].[TSqlSeqElementType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (1, N'Keyword');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (2, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (3, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (4, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (5, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (6, N'Statement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (7, N'SequenceOfStatements');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (8, N'Block');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (9, N'LiteralString');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (10, N'Sequence');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (11, N'End');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (12, N'LiteralInt');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (13, N'VariableName');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (14, N'SpecialSequence');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (15, N'Literal');


-- table [ParserEnum].[TokenSubtype]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (1, 2, N'SingleLineComment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (2, 2, N'MultiLineComment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (3, 3, N'RegularIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (4, 3, N'IdentifierInBrackets');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (5, 3, N'IdentifierInDoubleQuotes');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (6, 8, N'String');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (7, 8, N'UnicodeString');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (8, 8, N'Integer');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (9, 8, N'Decimal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (10, 8, N'Money');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (11, 8, N'Real');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (12, 8, N'Binary');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (13, 6, N'Comma');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (14, 6, N'Semicolon');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (15, 6, N'Period');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (16, 4, N'VariableName');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (17, 7, N'UnaryOperator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (18, 7, N'BinaryOperator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=19) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (19, 7, N'UnaryOrBinaryOperator');


-- table [Parser].[Operator]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=1) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (1, 'BT_NOT', '~', 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=2) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (2, 'MUL', '*', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=3) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (3, 'DIV', '/', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=4) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (4, 'MOD', '%', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=5) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (5, 'ADD', '+', 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=6) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (6, 'SUB', '-', 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=7) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (7, 'BT_AND', '&', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=8) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (8, 'BT_XOR', '^', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=9) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (9, 'BT_OR', '|', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=10) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (10, 'EQ', '=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=11) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (11, 'GT', '>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=12) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (12, 'LT', '<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=13) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (13, 'GE', '>=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=14) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (14, 'LE', '<=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=15) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (15, 'NE', '<>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=16) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (16, 'NE2', '!=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=17) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (17, 'NGT', '!>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=18) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (18, 'NLT', '!<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=19) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (19, 'ADD_ASSIGN', '+=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=20) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (20, 'SUB_ASSIGN', '-=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=21) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (21, 'MUL_ASSIGN', '*=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=22) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (22, 'DIV_ASSIGN', '/=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=23) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (23, 'MOD_ASSIGN', '%=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=24) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (24, 'BT_AND_ASSIGN', '&=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=25) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (25, 'BT_XOR_ASSIGN', '^=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=26) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (26, 'BT_OR_ASSIGN', '|=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=27) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (27, 'SCOPE', '::', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=28) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (28, 'NOT', 'NOT', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=29) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (29, 'AND', 'AND', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=30) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (30, 'ALL', 'ALL', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=31) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (31, 'ANY', 'ANY', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=32) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (32, 'BETWEEN', 'BETWEEN', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=33) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (33, 'IN', 'IN', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=34) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (34, 'LIKE', 'LIKE', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=35) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (35, 'OR', 'OR', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=36) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (36, 'SOME', 'SOME', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=37) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (37, 'EXISTS', 'EXISTS', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=38) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (38, 'BT_SHL', '<<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=39) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (39, 'BT_SHR', '>>', 0, 1);



-- Completion time: 2025-07-05T16:03:47.0047302+01:00

GO
IF NOT EXISTS (SELECT 1 FROM [Static].[Number])
BEGIN
	PRINT(N'Populating table [Static].[Number]. This may take a while...');
	-- https://www.sommarskog.se/Short%20Stories/table-of-numbers.html#creatingnumbers
	WITH L0 AS (SELECT 1 AS c UNION ALL SELECT 1),
     L1   AS (SELECT 1 AS c FROM L0 AS A, L0 AS B),
     L2   AS (SELECT 1 AS c FROM L1 AS A, L1 AS B),
     L3   AS (SELECT 1 AS c FROM L2 AS A, L2 AS B),
     L4   AS (SELECT 1 AS c FROM L3 AS A, L3 AS B),
     L5   AS (SELECT 1 AS c FROM L4 AS A, L4 AS B),
     Nums AS (SELECT row_number() OVER(ORDER BY c) AS n FROM L5)
	INSERT INTO [Static].[Number] ([N])
	SELECT n-1 
	FROM  Nums 
	WHERE n <= 1000001;
END
GO
IF NOT EXISTS (SELECT 1 FROM [Parser].[CharTypeMap])
BEGIN
	PRINT(N'Populating table [Parser].[CharTypeMap]...');
	INSERT INTO [Parser].[CharTypeMap]([Char], [TypeId])
	SELECT CHAR(n.[N]), [Parser].[GetCharType](CHAR(n.[N]))
	FROM [Static].[Number] n
	WHERE n.[N] BETWEEN 1 AND 127 AND [Parser].[GetCharType](CHAR(n.[N]))<>0;
END
GO

GO

DECLARE @KW_ADD SMALLINT = 1;
DECLARE @KW_ALL SMALLINT = 2;
DECLARE @KW_ALTER SMALLINT = 3;
DECLARE @KW_AND SMALLINT = 4;
DECLARE @KW_ANY SMALLINT = 5;
DECLARE @KW_AS SMALLINT = 6;
DECLARE @KW_ASC SMALLINT = 7;
DECLARE @KW_AUTHORIZATION SMALLINT = 8;
DECLARE @KW_BACKUP SMALLINT = 9;
DECLARE @KW_BEGIN SMALLINT = 10;
DECLARE @KW_BETWEEN SMALLINT = 11;
DECLARE @KW_BREAK SMALLINT = 12;
DECLARE @KW_BROWSE SMALLINT = 13;
DECLARE @KW_BULK SMALLINT = 14;
DECLARE @KW_BY SMALLINT = 15;
DECLARE @KW_CASCADE SMALLINT = 16;
DECLARE @KW_CASE SMALLINT = 17;
DECLARE @KW_CHECK SMALLINT = 18;
DECLARE @KW_CHECKPOINT SMALLINT = 19;
DECLARE @KW_CLOSE SMALLINT = 20;
DECLARE @KW_CLUSTERED SMALLINT = 21;
DECLARE @KW_COALESCE SMALLINT = 22;
DECLARE @KW_COLLATE SMALLINT = 23;
DECLARE @KW_COLUMN SMALLINT = 24;
DECLARE @KW_COMMIT SMALLINT = 25;
DECLARE @KW_COMPUTE SMALLINT = 26;
DECLARE @KW_CONSTRAINT SMALLINT = 27;
DECLARE @KW_CONTAINS SMALLINT = 28;
DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
DECLARE @KW_CONTINUE SMALLINT = 30;
DECLARE @KW_CONVERT SMALLINT = 31;
DECLARE @KW_CREATE SMALLINT = 32;
DECLARE @KW_CROSS SMALLINT = 33;
DECLARE @KW_CURRENT SMALLINT = 34;
DECLARE @KW_CURRENT_DATE SMALLINT = 35;
DECLARE @KW_CURRENT_TIME SMALLINT = 36;
DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
DECLARE @KW_CURRENT_USER SMALLINT = 38;
DECLARE @KW_CURSOR SMALLINT = 39;
DECLARE @KW_DATABASE SMALLINT = 40;
DECLARE @KW_DBCC SMALLINT = 41;
DECLARE @KW_DEALLOCATE SMALLINT = 42;
DECLARE @KW_DECLARE SMALLINT = 43;
DECLARE @KW_DEFAULT SMALLINT = 44;
DECLARE @KW_DELETE SMALLINT = 45;
DECLARE @KW_DENY SMALLINT = 46;
DECLARE @KW_DESC SMALLINT = 47;
DECLARE @KW_DISK SMALLINT = 48;
DECLARE @KW_DISTINCT SMALLINT = 49;
DECLARE @KW_DISTRIBUTED SMALLINT = 50;
DECLARE @KW_DOUBLE SMALLINT = 51;
DECLARE @KW_DROP SMALLINT = 52;
DECLARE @KW_DUMP SMALLINT = 53;
DECLARE @KW_ELSE SMALLINT = 54;
DECLARE @KW_END SMALLINT = 55;
DECLARE @KW_ERRLVL SMALLINT = 56;
DECLARE @KW_ESCAPE SMALLINT = 57;
DECLARE @KW_EXCEPT SMALLINT = 58;
DECLARE @KW_EXEC SMALLINT = 59;
DECLARE @KW_EXECUTE SMALLINT = 60;
DECLARE @KW_EXISTS SMALLINT = 61;
DECLARE @KW_EXIT SMALLINT = 62;
DECLARE @KW_EXTERNAL SMALLINT = 63;
DECLARE @KW_FETCH SMALLINT = 64;
DECLARE @KW_FILE SMALLINT = 65;
DECLARE @KW_FILLFACTOR SMALLINT = 66;
DECLARE @KW_FOR SMALLINT = 67;
DECLARE @KW_FOREIGN SMALLINT = 68;
DECLARE @KW_FREETEXT SMALLINT = 69;
DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
DECLARE @KW_FROM SMALLINT = 71;
DECLARE @KW_FULL SMALLINT = 72;
DECLARE @KW_FUNCTION SMALLINT = 73;
DECLARE @KW_GOTO SMALLINT = 74;
DECLARE @KW_GRANT SMALLINT = 75;
DECLARE @KW_GROUP SMALLINT = 76;
DECLARE @KW_HAVING SMALLINT = 77;
DECLARE @KW_HOLDLOCK SMALLINT = 78;
DECLARE @KW_IDENTITY SMALLINT = 79;
DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
DECLARE @KW_IDENTITYCOL SMALLINT = 81;
DECLARE @KW_IF SMALLINT = 82;
DECLARE @KW_IN SMALLINT = 83;
DECLARE @KW_INDEX SMALLINT = 84;
DECLARE @KW_INNER SMALLINT = 85;
DECLARE @KW_INSERT SMALLINT = 86;
DECLARE @KW_INTERSECT SMALLINT = 87;
DECLARE @KW_INTO SMALLINT = 88;
DECLARE @KW_IS SMALLINT = 89;
DECLARE @KW_JOIN SMALLINT = 90;
DECLARE @KW_KEY SMALLINT = 91;
DECLARE @KW_KILL SMALLINT = 92;
DECLARE @KW_LEFT SMALLINT = 93;
DECLARE @KW_LIKE SMALLINT = 94;
DECLARE @KW_LINENO SMALLINT = 95;
DECLARE @KW_LOAD SMALLINT = 96;
DECLARE @KW_MERGE SMALLINT = 97;
DECLARE @KW_NATIONAL SMALLINT = 98;
DECLARE @KW_NOCHECK SMALLINT = 99;
DECLARE @KW_NONCLUSTERED SMALLINT = 100;
DECLARE @KW_NOT SMALLINT = 101;
DECLARE @KW_NULL SMALLINT = 102;
DECLARE @KW_NULLIF SMALLINT = 103;
DECLARE @KW_OF SMALLINT = 104;
DECLARE @KW_OFF SMALLINT = 105;
DECLARE @KW_OFFSETS SMALLINT = 106;
DECLARE @KW_ON SMALLINT = 107;
DECLARE @KW_OPEN SMALLINT = 108;
DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
DECLARE @KW_OPENQUERY SMALLINT = 110;
DECLARE @KW_OPENROWSET SMALLINT = 111;
DECLARE @KW_OPENXML SMALLINT = 112;
DECLARE @KW_OPTION SMALLINT = 113;
DECLARE @KW_OR SMALLINT = 114;
DECLARE @KW_ORDER SMALLINT = 115;
DECLARE @KW_OUTER SMALLINT = 116;
DECLARE @KW_OVER SMALLINT = 117;
DECLARE @KW_PERCENT SMALLINT = 118;
DECLARE @KW_PIVOT SMALLINT = 119;
DECLARE @KW_PLAN SMALLINT = 120;
DECLARE @KW_PRECISION SMALLINT = 121;
DECLARE @KW_PRIMARY SMALLINT = 122;
DECLARE @KW_PRINT SMALLINT = 123;
DECLARE @KW_PROC SMALLINT = 124;
DECLARE @KW_PROCEDURE SMALLINT = 125;
DECLARE @KW_PUBLIC SMALLINT = 126;
DECLARE @KW_RAISERROR SMALLINT = 127;
DECLARE @KW_READ SMALLINT = 128;
DECLARE @KW_READTEXT SMALLINT = 129;
DECLARE @KW_RECONFIGURE SMALLINT = 130;
DECLARE @KW_REFERENCES SMALLINT = 131;
DECLARE @KW_REPLICATION SMALLINT = 132;
DECLARE @KW_RESTORE SMALLINT = 133;
DECLARE @KW_RESTRICT SMALLINT = 134;
DECLARE @KW_RETURN SMALLINT = 135;
DECLARE @KW_REVERT SMALLINT = 136;
DECLARE @KW_REVOKE SMALLINT = 137;
DECLARE @KW_RIGHT SMALLINT = 138;
DECLARE @KW_ROLLBACK SMALLINT = 139;
DECLARE @KW_ROWCOUNT SMALLINT = 140;
DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
DECLARE @KW_RULE SMALLINT = 142;
DECLARE @KW_SAVE SMALLINT = 143;
DECLARE @KW_SCHEMA SMALLINT = 144;
DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
DECLARE @KW_SELECT SMALLINT = 146;
DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
DECLARE @KW_SESSION_USER SMALLINT = 150;
DECLARE @KW_SET SMALLINT = 151;
DECLARE @KW_SETUSER SMALLINT = 152;
DECLARE @KW_SHUTDOWN SMALLINT = 153;
DECLARE @KW_SOME SMALLINT = 154;
DECLARE @KW_STATISTICS SMALLINT = 155;
DECLARE @KW_SYSTEM_USER SMALLINT = 156;
DECLARE @KW_TABLE SMALLINT = 157;
DECLARE @KW_TABLESAMPLE SMALLINT = 158;
DECLARE @KW_TEXTSIZE SMALLINT = 159;
DECLARE @KW_THEN SMALLINT = 160;
DECLARE @KW_TO SMALLINT = 161;
DECLARE @KW_TOP SMALLINT = 162;
DECLARE @KW_TRAN SMALLINT = 163;
DECLARE @KW_TRANSACTION SMALLINT = 164;
DECLARE @KW_TRIGGER SMALLINT = 165;
DECLARE @KW_TRUNCATE SMALLINT = 166;
DECLARE @KW_TRY_CONVERT SMALLINT = 167;
DECLARE @KW_TSEQUAL SMALLINT = 168;
DECLARE @KW_UNION SMALLINT = 169;
DECLARE @KW_UNIQUE SMALLINT = 170;
DECLARE @KW_UNPIVOT SMALLINT = 171;
DECLARE @KW_UPDATE SMALLINT = 172;
DECLARE @KW_UPDATETEXT SMALLINT = 173;
DECLARE @KW_USE SMALLINT = 174;
DECLARE @KW_USER SMALLINT = 175;
DECLARE @KW_VALUES SMALLINT = 176;
DECLARE @KW_VARYING SMALLINT = 177;
DECLARE @KW_VIEW SMALLINT = 178;
DECLARE @KW_WAITFOR SMALLINT = 179;
DECLARE @KW_WHEN SMALLINT = 180;
DECLARE @KW_WHERE SMALLINT = 181;
DECLARE @KW_WHILE SMALLINT = 182;
DECLARE @KW_WITH SMALLINT = 183;
DECLARE @KW_WITHIN SMALLINT = 184;
DECLARE @KW_WRITETEXT SMALLINT = 185;
DECLARE @KW_ATOMIC SMALLINT = 186;
DECLARE @KW_CONVERSATION SMALLINT = 187;
DECLARE @KW_DIALOG SMALLINT = 188;
DECLARE @KW_CATCH SMALLINT = 189;
DECLARE @KW_TRY SMALLINT = 190;
DECLARE @KW_THROW SMALLINT = 191;
DECLARE @KW_FILETABLE SMALLINT = 192;
DECLARE @KW_OUTPUT SMALLINT = 193;
DECLARE @KW_LOGIN SMALLINT = 194;
DECLARE @KW_AT SMALLINT = 195;
DECLARE @KW_DATA_SOURCE SMALLINT = 196;
DECLARE @KW_RECOMPILE SMALLINT = 197;
DECLARE @KW_RESULT SMALLINT = 198;
DECLARE @KW_SETS SMALLINT = 199;
DECLARE @KW_UNDEFINED SMALLINT = 200;
DECLARE @KW_NONE SMALLINT = 201;
DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;


DECLARE @ST_CREATE_PROCEDURE SMALLINT = 1;
DECLARE @ST_CREATE_TABLE SMALLINT = 2;
DECLARE @ST_EXEC SMALLINT = 3;
DECLARE @ST_SELECT SMALLINT = 4;
DECLARE @ST_INSERT SMALLINT = 5;
DECLARE @ST_UPDATE SMALLINT = 6;
DECLARE @ST_DELETE SMALLINT = 7;
DECLARE @ST_DECLARE SMALLINT = 8;
DECLARE @ST_SET SMALLINT = 9;

DECLARE @ST_TRUNCATE_TABLE SMALLINT = 10;
DECLARE @ST_DROP_TABLE SMALLINT = 11;

DECLARE @ST_BEGIN_TRANSACTION SMALLINT = 20;
DECLARE @ST_BEGIN_DISTRIBUTED_TRANSACTION SMALLINT = 21;
DECLARE @ST_COMMIT SMALLINT = 23;
DECLARE @ST_ROLLBACK SMALLINT = 24;

DECLARE @ST_IF SMALLINT = 31;
DECLARE @ST_WHILE SMALLINT = 32;
DECLARE @ST_CONTINUE SMALLINT = 33;
DECLARE @ST_BREAK SMALLINT = 34;
DECLARE @ST_THROW SMALLINT = 35;
DECLARE @ST_RAISERROR SMALLINT = 36;
DECLARE @ST_PRINT SMALLINT = 37;
DECLARE @ST_RETURN SMALLINT = 38;

-- DECLARE @ST_BEGIN_DIALOG SMALLINT = 101;
-- DECLARE @ST_BEGIN_CONVERSATION_TIMER SMALLINT = 102;


--DECLARE @ST_BEGIN_ATOMIC SMALLINT = 11;
--DECLARE @ST_BEGIN_TRY SMALLINT = 12;
--DECLARE @ST_BEGIN_CATCH SMALLINT = 13;


DECLARE @ET_KEYWORD TINYINT = 1;
DECLARE @ET_IDENTIFIER TINYINT = 2;
DECLARE @ET_OPERATOR TINYINT = 3;
DECLARE @ET_SEPARATOR TINYINT = 4;
DECLARE @ET_DELIMITER TINYINT = 5;
DECLARE @ET_STATEMENT TINYINT = 6;
DECLARE @ET_SEQUENCE_OF_STATEMENTS TINYINT = 7;
DECLARE @ET_BLOCK TINYINT = 8;
DECLARE @ET_LITERAL_STRING TINYINT = 9;
DECLARE @ET_SEQUENCE TINYINT = 10;
DECLARE @ET_END TINYINT = 11;
DECLARE @ET_LITERAL_INT TINYINT = 12;
DECLARE @ET_VARIABLE_NAME TINYINT = 13;
DECLARE @ET_SPECIAL_SEQUENCE TINYINT = 14;
DECLARE @ET_LITERAL TINYINT = 15;

DECLARE @SQT_NORMAL TINYINT = 1;
DECLARE @SQT_ANY_STATEMENT TINYINT = 2;
DECLARE @SQT_BLOCK_STATEMENT TINYINT = 3;
DECLARE @SQT_SEQUENCE_OF_STATEMENTS TINYINT = 4;
DECLARE @SQT_TWO_PART_IDENTIFIER TINYINT = 5;
DECLARE @SQT_THREE_PART_IDENTIFIER TINYINT = 6;
DECLARE @SQT_MORE_TOKENS TINYINT = 7;
DECLARE @SQT_LABEL TINYINT = 8;
DECLARE @SQT_BEGIN_BLOCK TINYINT = 9;
DECLARE @SQT_END_BLOCK TINYINT = 10;
DECLARE @SQT_SEQUENCE_IN_PARENTHESES TINYINT = 11;
DECLARE @SQT_FOUR_PART_IDENTIFIER TINYINT = 12;
DECLARE @SQT_SCALAR_EXPRESSION TINYINT = 13;
DECLARE @SQT_OUTPUT_CLAUSE TINYINT = 14;
DECLARE @SQT_CASE_EXPRESSION TINYINT = 15;
DECLARE @SQT_VAR_ASSIGN TINYINT = 16;
DECLARE @SQT_SP_NUMBER TINYINT = 17;
DECLARE @SQT_IDENTIFIER_DOT TINYINT = 18;


DECLARE @SP_IDENTIFIER TINYINT = 1;
DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
DECLARE @SP_DEFINITION TINYINT = 3;
DECLARE @SP_CHILD_STATEMENT TINYINT = 4;


DECLARE @TT_NONE TINYINT = 0;
DECLARE @TT_WHITESPACE TINYINT = 1;
DECLARE @TT_COMMENT TINYINT = 2;
DECLARE @TT_IDENTIFIER TINYINT = 3;
DECLARE @TT_KEYWORD TINYINT = 4;
DECLARE @TT_DELIMITER TINYINT = 5;
DECLARE @TT_SEPARATOR TINYINT = 6;
DECLARE @TT_OPERATOR TINYINT = 7;
DECLARE @TT_LITERAL TINYINT = 8;
DECLARE @TT_UNKNOWN TINYINT = 255;

DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
DECLARE @TST_STRING TINYINT = 6;
DECLARE @TST_UNICODE_STRING TINYINT = 7;
DECLARE @TST_INTEGER TINYINT = 8;
DECLARE @TST_DECIMAL TINYINT = 9;
DECLARE @TST_MONEY TINYINT = 10;
DECLARE @TST_REAL TINYINT = 11;
DECLARE @TST_BINARY TINYINT = 12;
DECLARE @TST_COMMA TINYINT = 13;
DECLARE @TST_SEMICOLON TINYINT = 14;
DECLARE @TST_PERIOD TINYINT = 15;
DECLARE @TST_VARIABLE_NAME TINYINT = 16;
DECLARE @TST_UNARY_OPERATOR TINYINT = 17;
DECLARE @TST_BINARY_OPERATOR TINYINT = 18;
DECLARE @TST_UNARY_OR_BINARY_OPERATOR TINYINT = 19;

DECLARE @OP_BT_NOT TINYINT = 1;
DECLARE @OP_MUL TINYINT = 2;
DECLARE @OP_DIV TINYINT = 3;
DECLARE @OP_MOD TINYINT = 4;
DECLARE @OP_ADD TINYINT = 5;
DECLARE @OP_SUB TINYINT = 6;
DECLARE @OP_BT_AND TINYINT = 7;
DECLARE @OP_BT_XOR TINYINT = 8;
DECLARE @OP_BT_OR TINYINT = 9;
DECLARE @OP_EQ TINYINT = 10;
DECLARE @OP_GT TINYINT = 11;
DECLARE @OP_LT TINYINT = 12;
DECLARE @OP_GE TINYINT = 13;
DECLARE @OP_LE TINYINT = 14;
DECLARE @OP_NE TINYINT = 15;
DECLARE @OP_NE2 TINYINT = 16;
DECLARE @OP_NGT TINYINT = 17;
DECLARE @OP_NLT TINYINT = 18;
DECLARE @OP_ADD_ASSIGN TINYINT = 19;
DECLARE @OP_SUB_ASSIGN TINYINT = 20;
DECLARE @OP_MUL_ASSIGN TINYINT = 21;
DECLARE @OP_DIV_ASSIGN TINYINT = 22;
DECLARE @OP_MOD_ASSIGN TINYINT = 23;
DECLARE @OP_BT_AND_ASSIGN TINYINT = 24;
DECLARE @OP_BT_XOR_ASSIGN TINYINT = 25;
DECLARE @OP_BT_OR_ASSIGN TINYINT = 26;
DECLARE @OP_SCOPE TINYINT = 27;
DECLARE @OP_NOT TINYINT = 28;
DECLARE @OP_AND TINYINT = 29;
DECLARE @OP_ALL TINYINT = 30;
DECLARE @OP_ANY TINYINT = 31;
DECLARE @OP_BETWEEN TINYINT = 32;
DECLARE @OP_IN TINYINT = 33;
DECLARE @OP_LIKE TINYINT = 34;
DECLARE @OP_OR TINYINT = 35;
DECLARE @OP_SOME TINYINT = 36;
DECLARE @OP_EXISTS TINYINT = 37;
DECLARE @OP_BT_SHL TINYINT = 38;
DECLARE @OP_BT_SHR TINYINT = 39;

DELETE FROM [Parser].[TSqlSeqElement];
DELETE FROM [Parser].[TSqlSequence];
DBCC CHECKIDENT ('[Parser].[TSqlSequence]', RESEED, 0);
DELETE FROM [ParserEnum].[TSqlStatementType];

ALTER SEQUENCE [Parser].[TSqlSeqEl]  
RESTART WITH 1;  


INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CREATE_PROCEDURE, 'CreateProcedure', @KW_CREATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CREATE_TABLE, 'CreateTable', @KW_CREATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_EXEC, 'Exec', @KW_MORE_THAN_ONE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DECLARE, 'Declare', @KW_DECLARE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_SET, 'Set', @KW_SET, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_SELECT, 'Select', @KW_SELECT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_INSERT, 'Insert', @KW_INSERT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_UPDATE, 'Update', @KW_UPDATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DELETE, 'Delete', @KW_DELETE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_TRANSACTION, 'BeginTran', @KW_BEGIN, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_DISTRIBUTED_TRANSACTION, 'BeginDistTran', @KW_BEGIN, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_COMMIT, 'Commit', @KW_COMMIT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_ROLLBACK, 'Rollback', @KW_ROLLBACK, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_TRUNCATE_TABLE, 'TruncateTable', @KW_TRUNCATE, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DROP_TABLE, 'DropTable', @KW_DROP, 0, 0, 0);


INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_IF, 'If', @KW_IF, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_WHILE, 'While', @KW_WHILE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CONTINUE, 'Continue', @KW_CONTINUE, 1, 1, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BREAK, 'Break', @KW_BREAK, 1, 1, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_THROW, 'Throw', @KW_THROW, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_RAISERROR, 'RaisError', @KW_RAISERROR, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_PRINT, 'Print', @KW_PRINT, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_RETURN, 'Return', @KW_RETURN, 0, 0, 0);

/*
INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_DIALOG, 'BeginDialog', @KW_BEGIN, 0, 0, 0);
*/


DECLARE @seqId SMALLINT;

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_statement>', @SQT_ANY_STATEMENT);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_statements>', @SQT_SEQUENCE_OF_STATEMENTS);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_block>', @SQT_BLOCK_STATEMENT);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<more_tokens>', @SQT_MORE_TOKENS);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<seq_in_parentheses>', @SQT_SEQUENCE_IN_PARENTHESES);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<case_expression>', @SQT_CASE_EXPRESSION);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<identifier_dot>', @SQT_IDENTIFIER_DOT);

SET @seqId=SCOPE_IDENTITY();

DECLARE @id INT;  

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_IDENTIFIER, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, NULL, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);



INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<two_part_identifier>', @SQT_TWO_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, @id + 1, NULL, NULL, @SQT_IDENTIFIER_DOT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_IDENTIFIER, @seqId, 0, @id + 2, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<three_part_identifier>', @SQT_THREE_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, NULL, NULL, NULL, @SQT_TWO_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_IDENTIFIER, @seqId, 0, @id + 3, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<four_part_identifier>', @SQT_FOUR_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_IDENTIFIER, @seqId, 0, @id + 3, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<scalar_expression>', @SQT_SCALAR_EXPRESSION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 20;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_LITERAL, @seqId, 1, @id + 15, @id + 1, NULL, NULL, @TT_LITERAL, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_IDENTIFIER, @seqId, 0, @id + 2, @id + 4, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_SEPARATOR, @seqId, 0, @id + 1, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 4, @id + 15, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 6, @KW_OVER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, @id + 15, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, @id + 7, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 7, @ET_OPERATOR, @seqId, 0, @id, @id + 8, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 8, @ET_OPERATOR, @seqId, 0, @id, @id + 9, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OR_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 9, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_CASE_EXPRESSION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 15, @ET_OPERATOR, @seqId, 0, @id, @id + 16, NULL, NULL, @TT_OPERATOR, @TST_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 16, @ET_OPERATOR, @seqId, 0, @id, @id + 17, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OR_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_KEYWORD, @seqId, 0, @id, @id + 18, @KW_AND, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 18, @ET_KEYWORD, @seqId, 0, @id, @id + 19, @KW_OR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 19, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<output_clause>', @SQT_OUTPUT_CLAUSE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_OUTPUT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SEQUENCE, @seqId, 0, @id + 2, NULL, NULL, NULL, @SQT_SCALAR_EXPRESSION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 3, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 3, @ET_IDENTIFIER, @seqId, 0, @id + 4, @id + 4, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 4, @ET_SEPARATOR, @seqId, 0, @id + 1, @id + 5, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 5, @ET_KEYWORD, @seqId, 0, @id + 6, @id + 8, @KW_INTO, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 6, @ET_IDENTIFIER, @seqId, 0, @id + 7, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 7, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 8, @id + 8, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<var_assign>', @SQT_VAR_ASSIGN);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_VARIABLE_NAME, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_OPERATOR, @seqId, 0, @id + 2, NULL, NULL, @OP_EQ);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sp_number>', @SQT_SP_NUMBER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;
-- 
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_SEPARATOR, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_SEPARATOR, @TST_SEMICOLON);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_LITERAL_INT, @seqId, 0, @id + 2, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);




-- https://learn.microsoft.com/en-us/sql/t-sql/statements/create-procedure-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('CreateProcedure', @ST_CREATE_PROCEDURE);

SET @seqId=SCOPE_IDENTITY();


EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

-- SELECT @id;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CREATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, @id + 3, @KW_OR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, NULL, @KW_ALTER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 4, @KW_PROC, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, NULL, @KW_PROCEDURE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SEQUENCE, @seqId, 0, @id + 6, NULL, NULL, NULL, @SQT_TWO_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Select', @ST_SELECT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_SELECT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

-- https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Insert', @ST_INSERT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 25;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_INSERT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, @id + 4, @KW_TOP, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 4, @KW_PERCENT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 5, @KW_INTO, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SEQUENCE, @seqId, 0, @id + 9, @id + 6, NULL, NULL, @SQT_FOUR_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_KEYWORD, @seqId, 0, @id + 8, @id + 7, @KW_OPENQUERY, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 7, @ET_KEYWORD, @seqId, 0, @id + 8, @id + 9, @KW_OPENROWSET, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 9, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 9, @ET_KEYWORD, @seqId, 0, @id + 10, @id + 11, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 10, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 11, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

-- ( column_list ) 
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 11, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 12, @id + 12, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

-- OUTPUT clause
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 12, @ET_SEQUENCE, @seqId, 0, @id + 13, @id + 13, NULL, NULL, @SQT_OUTPUT_CLAUSE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 13, @ET_KEYWORD, @seqId, 0, @id + 14, @id + 16, @KW_VALUES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 14, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 15, @ET_SEPARATOR, @seqId, 0, @id + 14, @id + 24, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 16, @ET_KEYWORD, @seqId, 0, @id + 17, @id + 18, @KW_DEFAULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_KEYWORD, @seqId, 0, @id + 24, NULL, @KW_VALUES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId], [TokenTypeId], [TokenSubtypeId], [StatementTypeId])
VALUES
(@id + 18, @ET_STATEMENT, @seqId, 0, @id + 24, @id + 19, NULL, NULL, NULL, @SP_CHILD_STATEMENT, NULL, NULL, @ST_SELECT);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId], [TokenTypeId], [TokenSubtypeId], [StatementTypeId])
VALUES
(@id + 19, @ET_STATEMENT, @seqId, 0, @id + 24, NULL, NULL, NULL, NULL, @SP_CHILD_STATEMENT, NULL, NULL, @ST_EXEC);




-- *****
-- SELECT
-- EXEC


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 24, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Update', @ST_UPDATE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_UPDATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Delete', @ST_DELETE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DELETE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


-- https://learn.microsoft.com/en-us/sql/t-sql/statements/truncate-table-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('TruncateTable', @ST_TRUNCATE_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_TRUNCATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 5, @KW_WITH, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 5, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);






INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('DropTable', @ST_DROP_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DROP, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 4, @KW_IF, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, NULL, @KW_EXISTS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SEQUENCE, @seqId, 0, @id + 5, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 5, @ET_SEPARATOR, @seqId, 0, @id + 4, @id + 6, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);



-- *****


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('CreateTable', @ST_CREATE_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CREATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 5, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, NULL, @KW_FILETABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 6, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

/*
[ ON { partition_scheme_name ( partition_column_name )
           | filegroup
           | "default" } ]
    [ TEXTIMAGE_ON { filegroup | "default" } ]
    [ FILESTREAM_ON { partition_scheme_name
           | filegroup
           | "default" } ]
*/

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_KEYWORD, @seqId, 0, @id + 7, @id + 8, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 7, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 8, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


-- https://learn.microsoft.com/en-us/sql/t-sql/language-elements/execute-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Exec', @ST_EXEC);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 35

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 2, @id + 1, @KW_EXEC, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 1, @id + 2, NULL, @KW_EXECUTE, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 3, @id + 12, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 8, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 6, @id + 5, @KW_LOGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 5, @ET_KEYWORD, @seqId, 0, @id + 6, NULL, @KW_USER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_OPERATOR, @seqId, 0, @id + 7, NULL, NULL, @OP_EQ);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 7, @ET_LITERAL_STRING, @seqId, 0, @id + 8, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 8, @ET_KEYWORD, @seqId, 0, @id + 9, @id + 34, @KW_AT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 9, @ET_KEYWORD, @seqId, 0, @id + 10, @id + 10, @KW_DATA_SOURCE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 10, @ET_IDENTIFIER, @seqId, 0, @id + 34, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 12, @ET_SEQUENCE, @seqId, 0, @id + 13, @id + 13, NULL, NULL, @SQT_VAR_ASSIGN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 13, @ET_VARIABLE_NAME, @seqId, 0, @id + 16, @id + 14, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 14, @ET_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_FOUR_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 15, @ET_SEQUENCE, @seqId, 0, @id + 16, @id + 16, NULL, NULL, @SQT_SP_NUMBER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 16, @ET_SEQUENCE, @seqId, 0, @id + 17, @id + 17, NULL, NULL, @SQT_VAR_ASSIGN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_LITERAL, @seqId, 0, @id + 21, @id + 18, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 18, @ET_VARIABLE_NAME, @seqId, 0, @id + 19, @id + 20, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 19, @ET_KEYWORD, @seqId, 0, @id + 21, @id + 21, @KW_OUTPUT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 20, @ET_KEYWORD, @seqId, 0, @id + 21, @id + 22, @KW_DEFAULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 21, @ET_SEPARATOR, @seqId, 0, @id + 16, @id + 22, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 22, @ET_KEYWORD, @seqId, 0, @id + 23, @id + 34, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 23, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 24, @KW_RECOMPILE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 24, @ET_KEYWORD, @seqId, 0, @id + 25, NULL, @KW_RESULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 25, @ET_KEYWORD, @seqId, 0, @id + 26, NULL, @KW_SETS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 26, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 27, @KW_UNDEFINED, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 27, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 28, @KW_NONE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 28, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 29, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 29, @ET_SEPARATOR, @seqId, 0, @id + 23, @id + 34, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 34, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Declare', @ST_DECLARE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DECLARE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Set', @ST_SET);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_SET, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('BeginTran', @ST_BEGIN_TRANSACTION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BEGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 2, @KW_TRAN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, NULL, @KW_TRANSACTION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('BeginDistTran', @ST_BEGIN_DISTRIBUTED_TRANSACTION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BEGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_DISTRIBUTED, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 3, @KW_TRAN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, NULL, @KW_TRANSACTION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Commit', @ST_COMMIT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_COMMIT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Rollback', @ST_ROLLBACK);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_ROLLBACK, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('If', @ST_IF);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_IF, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('While', @ST_WHILE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_WHILE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Continue', @ST_CONTINUE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 2

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CONTINUE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Break', @ST_BREAK);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 2

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BREAK, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Throw', @ST_THROW);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_THROW, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('RaisError', @ST_RAISERROR);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_RAISERROR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Print', @ST_PRINT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_PRINT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Return', @ST_RETURN);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_RETURN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

UPDATE [Parser].[TSqlSeqElement]
SET [TokenTypeId]=@TT_KEYWORD WHERE [TypeId]=@ET_KEYWORD AND ISNULL([TokenTypeId],@TT_NONE)<>@TT_KEYWORD;

GO


DECLARE @version VARCHAR(50) = '0.9.0';
DECLARE @apiLevel SMALLINT = 1;
DECLARE @minApiLevel SMALLINT = 1;
DECLARE @description NVARCHAR(500) = N'TigerWrap - new project name'

IF NOT EXISTS (SELECT 1 FROM [dbo].[SchemaVersion] WHERE [Version]=@version)
BEGIN
	INSERT INTO [dbo].[SchemaVersion] ([Version], [Description], [ApiLevel], [MinApiLevel])
	VALUES (@version, @description, @apiLevel, @minApiLevel);
END

GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [Enum].[Language] WITH CHECK CHECK CONSTRAINT [FK_Language_Status];

ALTER TABLE [Parser].[TSqlSequence] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSequence_TSqlSequenceType];

ALTER TABLE [Parser].[TSqlSequence] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSequence_TsqlStatementType];

ALTER TABLE [Parser].[CharTypeMap] WITH CHECK CHECK CONSTRAINT [FK_Parser_CharTypeMap_CharType];

ALTER TABLE [Parser].[TSqlSeqElement] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSeqElement_Operator];

ALTER TABLE [Parser].[TSqlSeqElement] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlKeyword];

ALTER TABLE [Parser].[TSqlSeqElement] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlSeqElementType];

ALTER TABLE [Parser].[TSqlSeqElement] WITH CHECK CHECK CONSTRAINT [FK_Parser_TSqlSeqElement_TSqlSequence];

ALTER TABLE [ParserEnum].[TokenSubtype] WITH CHECK CHECK CONSTRAINT [FK_ParserEnum_TokenSubtype_TokenType];

ALTER TABLE [ParserEnum].[TSqlStatementType] WITH CHECK CHECK CONSTRAINT [FK_ParserEnum_TSqlStatementType_TSqlKeyword];

ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_Casing];

ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_Language];

ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_NameType];

ALTER TABLE [Static].[DataTypeMap] WITH CHECK CHECK CONSTRAINT [FK_DataTypeMap_Language];

ALTER TABLE [Static].[LanguageOption] WITH CHECK CHECK CONSTRAINT [FK_LanguageOption_Language];

ALTER TABLE [Static].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_Language];

ALTER TABLE [Static].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_TemplateType];

ALTER TABLE [dbo].[Project] WITH CHECK CHECK CONSTRAINT [FK_Project_ClassAccess];

ALTER TABLE [dbo].[Project] WITH CHECK CHECK CONSTRAINT [FK_Project_Language];

ALTER TABLE [dbo].[Project] WITH CHECK CHECK CONSTRAINT [FK_Project_ParamEnumMapping];

ALTER TABLE [dbo].[ProjectEnum] WITH CHECK CHECK CONSTRAINT [FK_ProjectEnum_NameMatch];

ALTER TABLE [dbo].[ProjectEnum] WITH CHECK CHECK CONSTRAINT [FK_ProjectEnum_Project];

ALTER TABLE [dbo].[ProjectNameNormalization] WITH CHECK CHECK CONSTRAINT [FK_ProjectNameNormalization_NamePartType];

ALTER TABLE [dbo].[ProjectNameNormalization] WITH CHECK CHECK CONSTRAINT [FK_ProjectNameNormalization_Project];

ALTER TABLE [dbo].[ProjectStoredProc] WITH CHECK CHECK CONSTRAINT [FK_ProjectStoredProc_NameMatch];

ALTER TABLE [dbo].[ProjectStoredProc] WITH CHECK CHECK CONSTRAINT [FK_ProjectStoredProc_Project];


GO
PRINT N'Update complete.';


GO
