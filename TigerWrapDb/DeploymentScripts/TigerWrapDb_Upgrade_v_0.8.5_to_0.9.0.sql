/*
Deployment script for TigerWrapDb (upgreade from MsSqlProjectHelperDb v0.8.5 to v0.9.0)

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "MsSqlProjectHelperDb"
:setvar DefaultFilePrefix "MsSqlProjectHelperDb"
:setvar DefaultDataPath "C:\MsSQL\Data\"
:setvar DefaultLogPath "C:\MsSQL\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- note: uncomment below line only for generating upgrade script (and make sure the versions in the script below and in the version script are set up correctly
USE [$(DatabaseName)];
GO
PRINT N'Checking database version before upgrade...';
DECLARE @expectedName VARCHAR(50) = 'MsSqlProjectHelperDb';
DECLARE @expectedVersion VARCHAR(50) = '0.8.5';
DECLARE @newVersion VARCHAR(50) = '0.9.0';
SET XACT_ABORT ON;
BEGIN TRY
	EXEC('DECLARE @name VARCHAR(50) = [DbInfo].[GetName](); DECLARE @ver VARCHAR(50) = [DbInfo].[GetCurrentVersion](); ')
END TRY
BEGIN CATCH
	PRINT N'An error occured.'
	PRINT N'Upgrade is not possible.';
	PRINT N'Check if you are executing this script against proper database.';
	PRINT N'Expected database type:    ' + @expectedName;
	PRINT N'Expected database version: ' + @expectedVersion;
	SET NOEXEC ON;
END CATCH
DECLARE @name VARCHAR(50) = [DbInfo].[GetName]();
DECLARE @currentVersion VARCHAR(50) = [DbInfo].[GetCurrentVersion]();

IF @name<>@expectedName
BEGIN	
	PRINT N'Expected database type: ' + @expectedName;
	PRINT N'Actual database type:   ' + ISNULL(@name, '<NULL>');
	PRINT N'Upgrade is not supported.';
	PRINT N'Check if you are executing this script against proper database.';
	SET NOEXEC ON;
END
IF @currentVersion<>@expectedVersion
BEGIN	
	PRINT N'Expected version of the database: ' + @expectedVersion;
	PRINT N'Actual version of the database:   ' + ISNULL(@currentVersion, '<NULL>');
	PRINT N'Upgrade is not supported.';
	PRINT N'Check if you are executing this script against proper database.';
	SET NOEXEC ON;
END
PRINT N'Upgrading database from version ' + @currentVersion + N' to version ' + @newVersion + N'...';
GO

GO

GO

IF (SELECT OBJECT_ID('tempdb..#tmpErrors')) IS NOT NULL DROP TABLE #tmpErrors
GO
CREATE TABLE #tmpErrors (Error int)
GO
SET XACT_ABORT ON
GO
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
GO
BEGIN TRANSACTION
GO
PRINT N'Creating Schema [Static]...';


GO
CREATE SCHEMA [Static]
    AUTHORIZATION [dbo];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Table [dbo].[SchemaVersion]...';


GO
ALTER TABLE [dbo].[SchemaVersion]
    ADD [MinApiLevel] TINYINT CONSTRAINT [DF_SchemaVersion_MinApiLevel] DEFAULT ((1)) NOT NULL;


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Static].[LanguageNameCasing]...';


GO
CREATE TABLE [Static].[LanguageNameCasing] (
    [Id]         SMALLINT IDENTITY (1, 1) NOT NULL,
    [LanguageId] TINYINT  NOT NULL,
    [NameTypeId] TINYINT  NOT NULL,
    [CasingId]   TINYINT  NOT NULL,
    CONSTRAINT [PK_LanguageNameCasing] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[LanguageNameCasing].[UX_LanguageNameCasing_LanguageId_NameTypeId]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_LanguageNameCasing_LanguageId_NameTypeId]
    ON [Static].[LanguageNameCasing]([LanguageId] ASC, [NameTypeId] ASC);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Static].[DataTypeMap]...';


GO
CREATE TABLE [Static].[DataTypeMap] (
    [Id]              SMALLINT       IDENTITY (1, 1) NOT NULL,
    [LanguageId]      TINYINT        NOT NULL,
    [SqlType]         NVARCHAR (128) NOT NULL,
    [NativeType]      VARCHAR (200)  NOT NULL,
    [SqlDbType]       VARCHAR (200)  NULL,
    [DbType]          VARCHAR (200)  NULL,
    [IsNullable]      BIT            NOT NULL,
    [SizeNeeded]      BIT            NOT NULL,
    [PrecisionNeeded] BIT            NOT NULL,
    [ScaleNeeded]     BIT            NOT NULL,
    CONSTRAINT [PK_DataTypeMap] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[DataTypeMap].[UX_DataTypeMap_LanguageId_SqlType]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_DataTypeMap_LanguageId_SqlType]
    ON [Static].[DataTypeMap]([LanguageId] ASC, [SqlType] ASC);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Static].[LanguageOption]...';


GO
CREATE TABLE [Static].[LanguageOption] (
    [Id]                         SMALLINT     IDENTITY (1, 1) NOT NULL,
    [LanguageId]                 TINYINT      NULL,
    [Name]                       VARCHAR (50) NOT NULL,
    [Value]                      BIGINT       NOT NULL,
    [IsPrimary]                  BIT          NOT NULL,
    [IsOverridablePerStoredProc] BIT          NOT NULL,
    CONSTRAINT [PK_LanguageOption] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[LanguageOption].[UX_LanguageOption_LanguageId_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_LanguageOption_LanguageId_Name]
    ON [Static].[LanguageOption]([LanguageId] ASC, [Name] ASC);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[LanguageOption].[IX_LanguageOption_IsPrimary_Name]...';


GO
CREATE NONCLUSTERED INDEX [IX_LanguageOption_IsPrimary_Name]
    ON [Static].[LanguageOption]([IsPrimary] ASC, [Name] ASC)
    INCLUDE([LanguageId], [Value]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[LanguageOption].[FU_LanguageOption_LanguageId_IsPrimary_Value]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [FU_LanguageOption_LanguageId_IsPrimary_Value]
    ON [Static].[LanguageOption]([LanguageId] ASC, [IsPrimary] ASC, [Value] ASC) WHERE ([IsPrimary]=(1));


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Static].[Template]...';


GO
CREATE TABLE [Static].[Template] (
    [Id]              SMALLINT        IDENTITY (1, 1) NOT NULL,
    [LanguageId]      TINYINT         NOT NULL,
    [TypeId]          TINYINT         NOT NULL,
    [LanguageOptions] BIGINT          NOT NULL,
    [Template]        NVARCHAR (4000) NOT NULL,
    CONSTRAINT [PK_Template] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Index [Static].[Template].[UX_Template_LanguageId_TypeId_LanguageOptions]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Template_LanguageId_TypeId_LanguageOptions]
    ON [Static].[Template]([LanguageId] ASC, [TypeId] ASC, [LanguageOptions] ASC);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Static].[Number]...';


GO
CREATE TABLE [Static].[Number] (
    [N] INT NOT NULL,
    CONSTRAINT [PK_Number] PRIMARY KEY CLUSTERED ([N] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Enum].[CodePart]...';


GO
CREATE TABLE [Enum].[CodePart] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    [Code] CHAR (1)     NOT NULL,
    CONSTRAINT [PK_CodePart] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_CodePart_Code] UNIQUE NONCLUSTERED ([Code] ASC),
    CONSTRAINT [UQ_CodePart_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Table [Enum].[LoggingLevel]...';


GO
CREATE TABLE [Enum].[LoggingLevel] (
    [Id]   TINYINT      NOT NULL,
    [Code] CHAR (1)     NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_Enum_LoggingLevel] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UQ_Enum_LoggingLevel_Code] UNIQUE NONCLUSTERED ([Code] ASC),
    CONSTRAINT [UQ_Enum_LoggingLevel_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_IsNullable]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_IsNullable] DEFAULT ((1)) FOR [IsNullable];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_SizeNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_SizeNeeded] DEFAULT ((0)) FOR [SizeNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_PrecisionNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_PrecisionNeeded] DEFAULT ((0)) FOR [PrecisionNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_DataTypeMap_ScaleNeeded]...';


GO
ALTER TABLE [Static].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_ScaleNeeded] DEFAULT ((0)) FOR [ScaleNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_LanguageOption_IsPrimary]...';


GO
ALTER TABLE [Static].[LanguageOption]
    ADD CONSTRAINT [DF_LanguageOption_IsPrimary] DEFAULT ((1)) FOR [IsPrimary];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_LanguageOption_IsOverridablePerStoredProc]...';


GO
ALTER TABLE [Static].[LanguageOption]
    ADD CONSTRAINT [DF_LanguageOption_IsOverridablePerStoredProc] DEFAULT ((1)) FOR [IsOverridablePerStoredProc];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Default Constraint [Static].[DF_Template_LanguageOptions]...';


GO
ALTER TABLE [Static].[Template]
    ADD CONSTRAINT [DF_Template_LanguageOptions] DEFAULT ((0)) FOR [LanguageOptions];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_Casing]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_Casing] FOREIGN KEY ([CasingId]) REFERENCES [Enum].[Casing] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_Language]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageNameCasing_NameType]...';


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageNameCasing_NameType] FOREIGN KEY ([NameTypeId]) REFERENCES [Enum].[NameType] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_DataTypeMap_Language]...';


GO
ALTER TABLE [Static].[DataTypeMap] WITH NOCHECK
    ADD CONSTRAINT [FK_DataTypeMap_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_LanguageOption_Language]...';


GO
ALTER TABLE [Static].[LanguageOption] WITH NOCHECK
    ADD CONSTRAINT [FK_LanguageOption_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_Template_Language]...';


GO
ALTER TABLE [Static].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Foreign Key [Static].[FK_Template_TemplateType]...';


GO
ALTER TABLE [Static].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_TemplateType] FOREIGN KEY ([TypeId]) REFERENCES [Enum].[TemplateType] ([Id]);


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Function [DbInfo].[GetName]...';


GO



ALTER FUNCTION [DbInfo].[GetName]
(	
)
RETURNS VARCHAR(50)
AS
BEGIN
	DECLARE @name VARCHAR(50) = 'TigerWrapDb';	

	RETURN @name;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Function [Internal].[GetLanguageOptions]...';


GO

ALTER FUNCTION [Internal].[GetLanguageOptions]
(
	@languageId TINYINT,
	@options VARCHAR(1000)
)
RETURNS BIGINT
AS
BEGIN
	DECLARE @result BIGINT = NULL;

	SELECT @result=SUM(DISTINCT(lo.[Value]))
	FROM [dbo].[DelimitedSplitN4K](@options, ',') o
	JOIN [Static].[LanguageOption] lo ON ISNULL(lo.[LanguageId], @languageId)=@languageId AND lo.[IsPrimary]=1 AND lo.[Name]=LTRIM(RTRIM(o.[Item]));

	RETURN ISNULL(@result, 0);
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Function [Internal].[GetLanguageOptionsString]...';


GO


ALTER FUNCTION [Internal].[GetLanguageOptionsString]
(
	@languageId TINYINT,
	@options BIGINT
)
RETURNS VARCHAR(1000)
AS
BEGIN
	DECLARE @result VARCHAR(1000) = NULL;

    SELECT @result=STRING_AGG(lo.[Name], ',') WITHIN GROUP (ORDER BY lo.[Value])
    FROM [Static].[LanguageOption] lo
    WHERE lo.[IsPrimary]=1 AND ((lo.[Value] & @options)=lo.[Value]);
    
    RETURN @result;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Function [Internal].[GetName]...';


GO
ALTER FUNCTION [Internal].[GetName]
(	
	@projectId TINYINT,
	@typeId TINYINT,
	@name NVARCHAR(128),
	@schema NVARCHAR(128)
)
RETURNS NVARCHAR(200)
AS
BEGIN
	DECLARE @result NVARCHAR(200) = '';
	DECLARE @casingId TINYINT;
	
	SELECT @casingId=lnc.[CasingId]
	FROM [dbo].[Project] p
	JOIN [Static].[LanguageNameCasing] lnc ON lnc.[LanguageId]=p.[LanguageId] AND lnc.[NameTypeId]=@typeId
	WHERE p.[Id]=@projectId;

	SELECT @result=[Internal].[GetCaseName](@casingId, @name, NULL);
	
	RETURN ISNULL(NULLIF(@result, ''), [Internal].[GetCaseName](@casingId, 'x', NULL));
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Function [Internal].[GetTemplate]...';


GO
ALTER FUNCTION [Internal].[GetTemplate]
(
	@languageId TINYINT,
	@languageOptions BIGINT,
	@typeId TINYINT
)
RETURNS SMALLINT
AS
BEGIN
	DECLARE @result SMALLINT;

	SELECT TOP(1) @result=t.[Id]
	FROM [Static].[Template] t
	WHERE t.[LanguageId]=@languageId AND t.TypeId=@typeId AND ((t.[LanguageOptions] & @languageOptions) = t.[LanguageOptions])
	ORDER BY t.[LanguageOptions] DESC;
		
	RETURN @result;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateStartCode]...';


GO

ALTER PROCEDURE [Internal].[GenerateStartCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';
	
	DECLARE @codeHeaderPartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeHeader');
	DECLARE @CodeBootstrapPartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeBootstrap');
	


	DECLARE @TT_START_COMMENT TINYINT = 1;
	DECLARE @TT_START_USING TINYINT = 37;
	DECLARE @TT_START_CLASS TINYINT = 38;
	DECLARE @TT_START_COMMENT_TOOL TINYINT = 39;
	DECLARE @TT_START_COMMENT_ENV TINYINT = 40;
	DECLARE @TT_START_COMMENT_END TINYINT = 41;
	DECLARE @TT_STATIC_CTOR_END TINYINT = 42;
	DECLARE @TT_RS_MAPPING_SETUP TINYINT = 43;
	DECLARE @TT_WRAPPER_ENUM_START TINYINT = 48;
	DECLARE @TT_WRAPPER_ENUM_END TINYINT = 49;
	DECLARE @TT_WRAPPER_ENUM_ITEM TINYINT = 50;
	DECLARE @TT_START_CLASS_BOOTSTRAP TINYINT = 51;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	DECLARE @projectName NVARCHAR(200);
	DECLARE @genStaticClass BIT; 
	DECLARE @langOptions BIGINT;
	

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name], @projectName=p.[Name], @langOptions=p.[LanguageOptions]	
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    DECLARE @vars [Internal].[Variable];
	 
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ServerName', CAST(serverproperty('servername') AS NVARCHAR(500)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'InstanceName', @@SERVICENAME);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Database', @dbName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ProjectName', @projectName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Timestamp', CONVERT(NVARCHAR(50), CAST(SYSDATETIME() AS DATETIME2(0)), 120));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'DbUser', ORIGINAL_LOGIN());
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolDatabase', DB_NAME());
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolName', N'TigerWrap');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolUrl', N'https://github.com/rkozlowski/TigerWrap');	
	INSERT INTO @vars ([Name], [Value]) 
	SELECT TOP(1) N'ToolVersion', [Version]
	FROM [dbo].[SchemaVersion]
	ORDER BY [Id] DESC;
	INSERT INTO @vars ([Name], [Value]) VALUES (N'RsType', NULL);


	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_ENV)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_TOOL)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_COMMENT_END)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_USING)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codeHeaderPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_CLASS)
	ORDER BY c.[Id];

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_START_CLASS_BOOTSTRAP)
	ORDER BY c.[Id];

	DECLARE @id INT;
	DECLARE @rsType VARCHAR(200);

	SELECT @id=MIN([Id]) FROM #StoredProcResultType;	
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @rsType=rt.[Name]
		FROM #StoredProcResultType rt		
		WHERE rt.[Id]=@id;

		UPDATE @vars
		SET [Value]=@rsType
		WHERE [Name]=N'RsType';

		INSERT INTO #Output ([CodePartId], [Text])
		SELECT @CodeBootstrapPartId, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RS_MAPPING_SETUP)
		ORDER BY c.[Id];

		

		SELECT @id=MIN([Id]) FROM #StoredProcResultType WHERE [Id] > @id;
	END

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_STATIC_CTOR_END)
	ORDER BY c.[Id];

	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumAccess', 'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumName', 'StoredProcedureWrapper');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', '');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', ',');

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_START)
	ORDER BY c.[Id];



	SELECT @id=MIN([Id]) FROM #StoredProc;
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProc);
	DECLARE @wrapperName NVARCHAR(200);
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @wrapperName=[WrapperName]
		FROM #StoredProc WHERE [Id]=@id;

		UPDATE @vars
		SET [Value]=@wrapperName
		WHERE [Name]=N'Name';

		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Text])
		SELECT @CodeBootstrapPartId, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_ITEM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProc WHERE [Id] > @id;
	END

	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @CodeBootstrapPartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_ENUM_END)
	ORDER BY c.[Id];
	
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateStoredProcWrapperCode]...';


GO




ALTER PROCEDURE [Internal].[GenerateStoredProcWrapperCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='SpWrappers');

	DECLARE @TT_WRAPPER_START TINYINT = 10;
	DECLARE @TT_WRAPPER_END TINYINT = 11;
	DECLARE @TT_WRAPPER_PREP TINYINT = 12;
	DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
	DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
	DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
	DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
	DECLARE @TT_WRAPPER_START2 TINYINT = 20;
	DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
	DECLARE @TT_WRAPPER_END2 TINYINT = 22;
	DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;
    DECLARE @TT_WRAPPER_EXEC_RS_RV TINYINT = 46;

	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

	DECLARE @LO_GENERATE_STATIC_CLASS BIGINT = 1;
    DECLARE @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT BIGINT = 2;
    DECLARE @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES BIGINT = 4;
    DECLARE @LO_TARGET_CLASSIC_DOT_NET BIGINT = 65536;
    DECLARE @LO_USE_SYNC_WRAPPERS BIGINT = 131072;

	DECLARE @NT_CLASS TINYINT = 1;
	DECLARE @NT_METHOD TINYINT = 2;
	DECLARE @NT_PROPERTY TINYINT = 3;
	DECLARE @NT_FIELD TINYINT = 4;
	DECLARE @NT_PARAMETER TINYINT = 5;
	DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
	DECLARE @NT_TUPLE_FIELD TINYINT = 7;
	DECLARE @NT_ENUM TINYINT = 8;
	DECLARE @NT_ENUM_MEMBER TINYINT = 9;
	
	DECLARE @wrapperName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	DECLARE @hasResultSet BIT;
    DECLARE @hasUnknownResultSet BIT;
	DECLARE @resultType NVARCHAR(200);
	

	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);		
	DECLARE @langOptions BIGINT;

	SELECT @className=p.[ClassName], @classAccess=ca.[Name], @langOptions=p.[LanguageOptions]
	--, @genStaticClass=p.[GenerateStaticClass], @treatOutputParamAsInputOutput=p.[TreatOutputParamAsInputOutput]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	--DECLARE @genStaticClass BIT; 	
    DECLARE @langOptionsReset BIGINT = NULL;
    DECLARE @langOptionsSet BIGINT = NULL;

	SELECT @wrapperName=sp.[WrapperName], @spSchema=sp.[Schema], @spName=sp.[Name], @hasResultSet=sp.[HasResultSet], @resultType=[ResultType], 
        @hasUnknownResultSet=sp.[HasUnknownResultSet], @langOptionsReset=[LanguageOptionsReset], @langOptionsSet=[LanguageOptionsSet]
	FROM #StoredProc sp 
	WHERE sp.[Id]=@spId;

	IF @wrapperName IS NULL
	BEGIN	
		SET @errorCode='UnknownStoredProcedure';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    IF @langOptionsReset IS NOT NULL
    BEGIN
        SET @langOptions &= ~@langOptionsReset;
    END

    IF @langOptionsSet IS NOT NULL
    BEGIN
        SET @langOptions |= @langOptionsSet;
    END

    DECLARE @treatOutputParamAsInputOutput BIT = CASE WHEN (@langOptions & @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT) = @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT THEN 1 ELSE 0 END;
    DECLARE @captureRetValForRsStoredProc BIT = CASE WHEN (@langOptions & @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES) = @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES THEN 1 ELSE 0 END;

    DECLARE @resultSetWithReturnValue BIT = CASE WHEN @hasUnknownResultSet=1 OR (@hasResultSet=1 AND @captureRetValForRsStoredProc=1) THEN 1 ELSE 0 END;

	DECLARE @methodAccess NVARCHAR(200) = N'public';

	DECLARE @resultTypeSingle NVARCHAR(200) = @resultType;

	IF @hasResultSet=1
	BEGIN
		SET @resultType = 'IList<' + @resultType + '>';
	END;

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'WrapperName', @wrapperName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', [Internal].[EscapeString](@langId, QUOTENAME(@spSchema)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', [Internal].[EscapeString](@langId, QUOTENAME(@spName)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultType', @resultType);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultTypeSingle', @resultTypeSingle);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarName', CASE WHEN @hasResultSet=1 THEN N'result' ELSE N'returnValue' END);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'RetValVarName', N'returnValue');
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'MethodAccess', @methodAccess);
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TypeCast', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ParamName', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'DbType', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Size', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Precision', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Scale', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');	

	INSERT INTO @vars ([Name], [Value]) VALUES (N'DtName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ReaderName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TvpName', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TableType', NULL);	
	
	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N',' ELSE N'' END WHERE [Name]=N'Sep';
	
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleStart', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N'(' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleEnd', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN N')' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarNameTuple', CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN CASE WHEN @hasResultSet=1 THEN N' Result' ELSE ' ReturnValue' END ELSE N'' END);

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_START)
	ORDER BY c.[Id];

	
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	DECLARE @name NVARCHAR(100);	
	DECLARE @type NVARCHAR(100);
	DECLARE @typeCast NVARCHAR(100);
	DECLARE @paramName NVARCHAR(100);	
	DECLARE @isOutput BIT;
	DECLARE @dbType NVARCHAR(100);
	DECLARE @size NVARCHAR(100);
	DECLARE @precision NVARCHAR(100);
	DECLARE @scale NVARCHAR(100);
	
    IF @resultSetWithReturnValue=1
    BEGIN
        UPDATE @vars
		SET [Value]=NULL
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=N'int'
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=[Internal].[GetName](@projectId, @NT_TUPLE_FIELD, N'returnValue', NULL)
		WHERE [Name]=N'ParamName';		
		
		
		IF @id IS NULL
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM_DEC)
		ORDER BY c.[Id];
    END
	

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName= [Internal].[GetName](@projectId, @NT_TUPLE_FIELD, p.[ParamName], NULL), @isOutput=p.[IsOutput]			
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM_DEC)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_START2)
	ORDER BY c.[Id];

	UPDATE @vars SET [Value]=',' WHERE [Name]=N'Sep';
	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	DECLARE @isTableType BIT;
	-- for CancellationToken parameter - C# specific, might need different logic to support different languages
	DECLARE @hasExtraParams BIT = CASE WHEN (@langOptions & @LO_USE_SYNC_WRAPPERS) = @LO_USE_SYNC_WRAPPERS THEN 0 ELSE 1 END;

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(ISNULL(N'IEnumerable<' + @className + N'.' + tt.[Name] + N'>', @className + N'.' + e.[EnumName]), dtm.[NativeType]) + CASE WHEN tt.[Id] IS NULL AND dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName=p.[ParamName], @isOutput=p.[IsOutput], @isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END
		FROM #StoredProcParam p 
		LEFT JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
				
		IF @id=@lastId AND @hasExtraParams=0
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PARAM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0) AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PREP)
	ORDER BY c.[Id];

	DECLARE @dtName NVARCHAR(200);
	DECLARE @readerName NVARCHAR(200);
	DECLARE @tvpName NVARCHAR(300);
	DECLARE @tableType NVARCHAR(300);

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],			
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' ELSE N'(' + dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END,
			@isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END,
			@dtName=[Internal].[GetName](@projectId, @NT_LOCAL_VARIABLE, N'dt_' + @paramName, NULL),
			@readerName=[Internal].[GetName](@projectId, @NT_LOCAL_VARIABLE, @paramName + '_reader', NULL),
			@tvpName=QUOTENAME(tt.[SqlTypeSchema]) + N'.' + [Internal].[EscapeString](@langId, QUOTENAME(tt.[SqlType])),
			@tableType=@className + N'.' + tt.[Name]
		FROM #StoredProcParam p 
		LEFT JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		UPDATE @vars
		SET [Value]=@tableType
		WHERE [Name]=N'TableType';
		


		UPDATE @vars
		SET [Value]=@dtName
		WHERE [Name]=N'DtName';
		UPDATE @vars
		SET [Value]=@readerName
		WHERE [Name]=N'ReaderName';
		UPDATE @vars
		SET [Value]=@tvpName
		WHERE [Name]=N'TvpName';
		
		
		
		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
			CASE WHEN @isTableType=1 THEN @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE WHEN @isOutput=0 THEN @TT_WRAPPER_PARAM_PRE_EXEC_INPUT ELSE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT END)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
    CASE WHEN @hasResultSet=0 THEN @TT_WRAPPER_EXEC WHEN @resultSetWithReturnValue=1 THEN @TT_WRAPPER_EXEC_RS_RV ELSE  @TT_WRAPPER_EXEC_RS END)
	ORDER BY c.[Id];

	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],			
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' 
				ELSE N'(' + ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		
		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_PARAM_POST_EXEC)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL OR @resultSetWithReturnValue=1 THEN ',' ELSE '' END WHERE [Name]=N'Sep';
	
	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_END)
	ORDER BY c.[Id];

	IF @resultSetWithReturnValue=1
    BEGIN
        UPDATE @vars
		SET [Value]=NULL
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=N'int'
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=N'returnValue'
		WHERE [Name]=N'ParamName';		
		
		
		IF @id IS NULL
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM)
		ORDER BY c.[Id];
    END
    

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
		@paramName=p.[ParamName], @isOutput=p.[IsOutput]			
		FROM #StoredProcParam p 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';		
		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_RETURN_PARAM)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_WRAPPER_END2)
	ORDER BY c.[Id];
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateEndCode]...';


GO

ALTER PROCEDURE [Internal].[GenerateEndCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @TT_START TINYINT = 1;
	DECLARE @TT_END TINYINT = 2;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	DECLARE @langOptions BIGINT;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='CodeEnd');

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name], @langOptions=p.[LanguageOptions]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);


	INSERT INTO #Output ([CodePartId], [Text])
	SELECT @codePartId, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_END)
	ORDER BY c.[Id];

END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateEnumCode]...';


GO


ALTER PROCEDURE [Internal].[GenerateEnumCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='Enums');

	DECLARE @TT_ENUM_START TINYINT = 3;
	DECLARE @TT_ENUM_END TINYINT = 4;
	DECLARE @TT_ENUM_ENTRY TINYINT = 5;
    DECLARE @TT_ENUM_START_FLAG TINYINT = 47;

	DECLARE @className NVARCHAR(100);	
	DECLARE @langOptions BIGINT;
	DECLARE @isSetOfFlags BIT;

	SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]	
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @enumName NVARCHAR(100);
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	

	SELECT @enumName=[EnumName], @enumSchema=[Schema], @enumTable=[Table], @isSetOfFlags=[IsSetOfFlags]
	FROM #Enum	
	WHERE [Id]=@enumId;

	IF @enumName IS NULL
	BEGIN		
		SET @errorCode='UnknownEnum';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumName', @enumName);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumSchema', [Internal].[EscapeString](@langId, QUOTENAME(@enumSchema)));	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumTable', [Internal].[EscapeString](@langId, QUOTENAME(@enumTable)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Value', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @enumSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
        CASE WHEN @isSetOfFlags=1 THEN @TT_ENUM_START_FLAG ELSE @TT_ENUM_START END
        )
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @name NVARCHAR(100);
	DECLARE @value NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=[Name], @value=[Value] FROM #EnumVal WHERE [Id]=@id;
		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@value
		WHERE [Name]=N'Value';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @enumSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_ENUM_ENTRY)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @enumSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_ENUM_END)
	ORDER BY c.[Id];

	

END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateResultTypeCode]...';


GO



ALTER PROCEDURE [Internal].[GenerateResultTypeCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@rtId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='ResultTypes');

	DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
	DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
	DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;

	DECLARE @NT_CLASS TINYINT = 1;
	DECLARE @NT_METHOD TINYINT = 2;
	DECLARE @NT_PROPERTY TINYINT = 3;
	DECLARE @NT_FIELD TINYINT = 4;
	DECLARE @NT_PARAMETER TINYINT = 5;
	DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
	DECLARE @NT_TUPLE_FIELD TINYINT = 7;
	DECLARE @NT_ENUM TINYINT = 8;
	DECLARE @NT_ENUM_MEMBER TINYINT = 9;

	DECLARE @spId INT;
	DECLARE @typeName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	DECLARE @className NVARCHAR(100);
	DECLARE @langOptions BIGINT;

	SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	SELECT @spId=rt.[StoredProcId], @typeName=rt.[Name], @spSchema=sp.[Schema], @spName=sp.[Name]
	FROM #StoredProcResultType rt
	JOIN #StoredProc sp ON rt.[StoredProcId]=sp.[Id]
	WHERE rt.[Id]=@rtId;

	IF @typeName IS NULL
	BEGIN		
		SET @errorCode='UnknownResultType';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
	END

    

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', [Internal].[EscapeString](@langId, QUOTENAME(@spSchema)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', [Internal].[EscapeString](@langId, QUOTENAME(@spName)));
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_START)
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @name NVARCHAR(128);
	DECLARE @columnName NVARCHAR(128);
	DECLARE @type NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @columnName=[Internal].[EscapeString](@langId, rs.[Name]), @name=rs.[PropertyName], 
			@type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN rs.[IsNullable]=1 AND dtm.[IsNullable]=0 THEN N'?' ELSE N'' END
		FROM #StoredProcResultSet rs 
		JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=rs.[SqlType]
		LEFT JOIN #Enum e ON rs.[EnumId]=e.[Id]
		WHERE rs.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@columnName
		WHERE [Name]=N'ColumnName';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @spSchema, c.[Text]
		FROM [Static].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_PROPERTY)
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @spSchema, c.[Text]
	FROM [Static].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_RESULT_TYPE_END)
	ORDER BY c.[Id];

	

END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GenerateTableTypeCode]...';


GO




ALTER PROCEDURE [Internal].[GenerateTableTypeCode]
    @projectId SMALLINT,
    @dbId SMALLINT,
    @langId TINYINT,
    @ttId INT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @rc INT;

    DECLARE @RC_OK INT = 0;
    
	DECLARE @errorCode VARCHAR(100) = 'InternalError';

	DECLARE @codePartId TINYINT = (SELECT [Id] FROM [Enum].[CodePart] WHERE [Name]='TvpTypes');

    DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
    DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
    DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
    DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
    DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
    DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
    DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
    DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
    DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_IDENTITY TINYINT = 44;
    DECLARE @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE TINYINT = 45;

    DECLARE @typeName NVARCHAR(200);
    DECLARE @ttSchema NVARCHAR(128);
    DECLARE @ttName NVARCHAR(128);

    DECLARE @className NVARCHAR(100);
    DECLARE @langOptions BIGINT;
    
    SELECT @className=p.[ClassName], @langOptions=p.[LanguageOptions]
    FROM [dbo].[Project] p
    JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
    WHERE p.[Id]=@projectId;

    IF @className IS NULL
    BEGIN
        SET @errorCode='UnknownProject';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
    END

    SELECT @typeName=tt.[Name], @ttSchema=tt.[SqlTypeSchema], @ttName=tt.[SqlType]
    FROM #TableType tt    
    WHERE tt.[Id]=@ttId;

    IF @typeName IS NULL
    BEGIN        
        SET @errorCode='UnknownTableType';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
		RETURN @rc;
    END

    DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

    IF @dbName IS NULL
    BEGIN
        SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage=[Description]
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
    END

    DECLARE @numberOfColumns INT = (SELECT COUNT(*) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId);

    DECLARE @vars [Internal].[Variable];
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TtSchema', [Internal].[EscapeString](@langId, QUOTENAME(@ttSchema)));
    INSERT INTO @vars ([Name], [Value]) VALUES (N'TtName', [Internal].[EscapeString](@langId, QUOTENAME(@ttName)));
    
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
    INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'BaseType', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnName', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'AllowNull', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'MaxLength', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Cast', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');    
    INSERT INTO @vars ([Name], [Value]) VALUES (N'NumberOfColumns', @numberOfColumns);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnNumber', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'SqlDbType', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Precision', NULL);
    INSERT INTO @vars ([Name], [Value]) VALUES (N'Scale', NULL);
    
    


    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_START)
    ORDER BY c.[Id];

    DECLARE @id INT = (SELECT MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0);
    DECLARE @lastId INT = (SELECT MAX([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0);    
    DECLARE @name NVARCHAR(128);
    DECLARE @columnName NVARCHAR(128);
    DECLARE @type NVARCHAR(128);
    DECLARE @baseType NVARCHAR(128);
    DECLARE @sqlDbType NVARCHAR(128);

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=ttc.[Name], @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';
        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_PROPERTY)
        ORDER BY c.[Id];

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0 AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_START)
    ORDER BY c.[Id];

    SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId;
    DECLARE @allowNull BIT
    DECLARE @maxLength INT;
    DECLARE @isIdentity BIT;
    DECLARE @columnNumber INT;
    DECLARE @precision INT;
    DECLARE @scale INT;

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=[Internal].[EscapeString](@langId, ttc.[Name]), @baseType=dtm.[NativeType], -- + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END, @isIdentity=ttc.[IsIdentity], @columnNumber=ttc.[ColumnNumber], @sqlDbType=dtm.SqlDbType,
        @precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN ttc.[Precision] ELSE NULL END, @scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN ttc.[Scale] ELSE NULL END
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';

        UPDATE @vars
        SET [Value]=@columnName
        WHERE [Name]=N'ColumnName';
        UPDATE @vars
        SET [Value]=@columnNumber
        WHERE [Name]=N'ColumnNumber';
        UPDATE @vars
        SET [Value]=@baseType
        WHERE [Name]=N'BaseType';
        UPDATE @vars
        SET [Value]=@sqlDbType
        WHERE [Name]=N'SqlDbType';
        

        UPDATE @vars
        SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
        WHERE [Name]=N'AllowNull';
        UPDATE @vars
        SET [Value]=@maxLength
        WHERE [Name]=N'MaxLength';

        UPDATE @vars
        SET [Value]=@precision
        WHERE [Name]=N'Precision';
        UPDATE @vars
        SET [Value]=@scale
        WHERE [Name]=N'Scale';

        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, 
            CASE WHEN @isIdentity=1 THEN @TT_TABLE_TYPE_DT_COLUMN_IDENTITY WHEN @maxLength IS NOT NULL THEN @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN 
            WHEN @precision IS NOT NULL THEN @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE ELSE @TT_TABLE_TYPE_DT_COLUMN END)
        ORDER BY c.[Id];


        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_COLUMN_ADD)
        ORDER BY c.[Id];

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_ROWS_START)
    ORDER BY c.[Id];

    SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0;
    DECLARE @cast NVARCHAR(200);

    WHILE @id IS NOT NULL
    BEGIN        
        SELECT @name=ttc.[PropertyName], @columnName=[Internal].[EscapeString](@langId, ttc.[Name]), @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
        @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,        
        @allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END, @columnNumber=ttc.[ColumnNumber]
        FROM #TableTypeColumn ttc 
        JOIN [Static].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
        LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
        WHERE ttc.[Id]=@id;

        SET @cast = CASE WHEN @baseType = @type THEN N'' ELSE N'(' + @baseType + N') ' END;

        UPDATE @vars
        SET [Value]=@name
        WHERE [Name]=N'Name';
        UPDATE @vars
        SET [Value]=@type
        WHERE [Name]=N'Type';

        UPDATE @vars
        SET [Value]=@columnName
        WHERE [Name]=N'ColumnName';
        UPDATE @vars
        SET [Value]=@columnNumber
        WHERE [Name]=N'ColumnNumber';
        UPDATE @vars
        SET [Value]=@baseType
        WHERE [Name]=N'BaseType';        

        UPDATE @vars
        SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
        WHERE [Name]=N'AllowNull';
        UPDATE @vars
        SET [Value]=@maxLength
        WHERE [Name]=N'MaxLength';

        UPDATE @vars
        SET [Value]=@cast
        WHERE [Name]=N'Cast';
        
        IF @id=@lastId
        BEGIN
            UPDATE @vars
            SET [Value]=''
            WHERE [Name]=N'Sep';
        END

        INSERT INTO #Output ([CodePartId], [Schema],  [Text])
		SELECT @codePartId, @ttSchema, c.[Text]
        FROM [Static].[Template] t
        CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
        WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, CASE WHEN @allowNull=1 THEN @TT_TABLE_TYPE_DT_ROW_NULL ELSE @TT_TABLE_TYPE_DT_ROW END)
        ORDER BY c.[Id];        

        SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [IsIdentity]=0 AND [Id]>@id;
    END

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_ROWS_END)
    ORDER BY c.[Id];

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_DT_END)
    ORDER BY c.[Id];

    INSERT INTO #Output ([CodePartId], [Schema],  [Text])
	SELECT @codePartId, @ttSchema, c.[Text]
    FROM [Static].[Template] t
    CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
    WHERE t.[Id]=[Internal].[GetTemplate](@langId, @langOptions, @TT_TABLE_TYPE_END)
    ORDER BY c.[Id];

    

END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Parser].[GetSeqElemIdRange]...';


GO

ALTER PROCEDURE [Parser].[GetSeqElemIdRange]
	@rangeLen INT = 1
AS
BEGIN
	DECLARE @firstId INT;

    IF ISNULL(@rangeLen, 0) < 1
    BEGIN
        SET @rangeLen = 1;
    END

    DROP TABLE IF EXISTS #SeqElemIdRange;

    CREATE TABLE #SeqElemIdRange
    (
        [NextId] INT NOT NULL PRIMARY KEY,
    );

    INSERT INTO #SeqElemIdRange ([NextId])
    SELECT NEXT VALUE FOR [Parser].[TSqlSeqEl] OVER (ORDER BY n.[N]) [NextId]
    FROM [Static].[Number] n 
    WHERE n.[N] BETWEEN 1 AND @rangeLen    
    ORDER BY n.[N];

    SELECT @firstId = MIN([NextId])
    FROM #SeqElemIdRange;

    DROP TABLE IF EXISTS #SeqElemIdRange;

	RETURN @firstId;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Parser].[TryParseSequence]...';


GO


ALTER PROCEDURE [Parser].[TryParseSequence]
    @tokenId INT,
    @sequenceId SMALLINT,
    @parentStatementId INT,
    @parentStatementPartId TINYINT,
    @lastTokenId INT OUTPUT,
    @isFinished BIT OUTPUT,
    @statementSeparatorTokenId INT OUTPUT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

    --PRINT(N'[Parser].[TryParseSequence] @tokenId: ' + LOWER(@tokenId) + N'; @sequenceId: ' + LOWER(@sequenceId));
	--PRINT(N'[Parser].[TryParseSequence] @parentStatementId: ' + ISNULL(LOWER(@parentStatementId), '<NULL>') + N'; @parentStatementPartId: ' + ISNULL(LOWER(@parentStatementPartId), '<NULL>'));

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_NOT_MATCH INT = 1;

    DECLARE @RC_ERR_DATA INT = 10;

    DECLARE @RC_ERR_DB INT = 100;
    
    SELECT @lastTokenId=NULL, @isFinished=0, @statementSeparatorTokenId=NULL,  @errorMessage=NULL;

    DECLARE @rc INT = @RC_NOT_MATCH;

    DECLARE @startTokenId INT = @tokenId;

    DECLARE @ET_KEYWORD TINYINT = 1;
    DECLARE @ET_IDENTIFIER TINYINT = 2;
    DECLARE @ET_OPERATOR TINYINT = 3;
    DECLARE @ET_SEPARATOR TINYINT = 4;
    DECLARE @ET_DELIMITER TINYINT = 5;
    DECLARE @ET_STATEMENT TINYINT = 6;
    DECLARE @ET_SEQUENCE_OF_STATEMENTS TINYINT = 7;
    DECLARE @ET_BLOCK TINYINT = 8;
    DECLARE @ET_LITERAL_STRING TINYINT = 9;
    DECLARE @ET_SEQUENCE TINYINT = 10;
    DECLARE @ET_END TINYINT = 11;
    DECLARE @ET_LITERAL_INT TINYINT = 12;
    DECLARE @ET_VARIABLE_NAME TINYINT = 13;
    DECLARE @ET_SPECIAL_SEQUENCE TINYINT = 14;
    DECLARE @ET_LITERAL TINYINT = 15;

    DECLARE @SQT_NORMAL TINYINT = 1;
    DECLARE @SQT_ANY_STATEMENT TINYINT = 2;
    DECLARE @SQT_BLOCK_STATEMENT TINYINT = 3;
    DECLARE @SQT_SEQUENCE_OF_STATEMENTS TINYINT = 4;
    DECLARE @SQT_TWO_PART_IDENTIFIER TINYINT = 5;
    DECLARE @SQT_THREE_PART_IDENTIFIER TINYINT = 6;
    DECLARE @SQT_MORE_TOKENS TINYINT = 7;
    DECLARE @SQT_LABEL TINYINT = 8;
    DECLARE @SQT_BEGIN_BLOCK TINYINT = 9;
    DECLARE @SQT_END_BLOCK TINYINT = 10;
    DECLARE @SQT_SEQUENCE_IN_PARENTHESES TINYINT = 11;
    DECLARE @SQT_FOUR_PART_IDENTIFIER TINYINT = 12;
    DECLARE @SQT_SCALAR_EXPRESSION TINYINT = 13;
    DECLARE @SQT_OUTPUT_CLAUSE TINYINT = 14;
    DECLARE @SQT_CASE_EXPRESSION TINYINT = 15;

    DECLARE @SP_IDENTIFIER TINYINT = 1;
    DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
    DECLARE @SP_DEFINITION TINYINT = 3;
    DECLARE @SP_CHILD_STATEMENT TINYINT = 4;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @TST_STRING TINYINT = 6;
    DECLARE @TST_UNICODE_STRING TINYINT = 7;
    DECLARE @TST_INTEGER TINYINT = 8;
    DECLARE @TST_DECIMAL TINYINT = 9;
    DECLARE @TST_MONEY TINYINT = 10;
    DECLARE @TST_REAL TINYINT = 11;
    DECLARE @TST_BINARY TINYINT = 12;
    DECLARE @TST_COMMA TINYINT = 13;
    DECLARE @TST_SEMICOLON TINYINT = 14;
    DECLARE @TST_PERIOD TINYINT = 15;
    DECLARE @TST_VARIABLE_NAME TINYINT = 16;

    DECLARE @BT_REGULAR_BLOCK TINYINT = 1;
    DECLARE @BT_TRY_BLOCK TINYINT = 2;
    DECLARE @BT_CATCH_BLOCK TINYINT = 3;
    DECLARE @BT_ATOMIC_BLOCK TINYINT = 4;
    DECLARE @BT_CASE_BLOCK TINYINT = 5;


    DECLARE @KW_ADD SMALLINT = 1;
    DECLARE @KW_ALL SMALLINT = 2;
    DECLARE @KW_ALTER SMALLINT = 3;
    DECLARE @KW_AND SMALLINT = 4;
    DECLARE @KW_ANY SMALLINT = 5;
    DECLARE @KW_AS SMALLINT = 6;
    DECLARE @KW_ASC SMALLINT = 7;
    DECLARE @KW_AUTHORIZATION SMALLINT = 8;
    DECLARE @KW_BACKUP SMALLINT = 9;
    DECLARE @KW_BEGIN SMALLINT = 10;
    DECLARE @KW_BETWEEN SMALLINT = 11;
    DECLARE @KW_BREAK SMALLINT = 12;
    DECLARE @KW_BROWSE SMALLINT = 13;
    DECLARE @KW_BULK SMALLINT = 14;
    DECLARE @KW_BY SMALLINT = 15;
    DECLARE @KW_CASCADE SMALLINT = 16;
    DECLARE @KW_CASE SMALLINT = 17;
    DECLARE @KW_CHECK SMALLINT = 18;
    DECLARE @KW_CHECKPOINT SMALLINT = 19;
    DECLARE @KW_CLOSE SMALLINT = 20;
    DECLARE @KW_CLUSTERED SMALLINT = 21;
    DECLARE @KW_COALESCE SMALLINT = 22;
    DECLARE @KW_COLLATE SMALLINT = 23;
    DECLARE @KW_COLUMN SMALLINT = 24;
    DECLARE @KW_COMMIT SMALLINT = 25;
    DECLARE @KW_COMPUTE SMALLINT = 26;
    DECLARE @KW_CONSTRAINT SMALLINT = 27;
    DECLARE @KW_CONTAINS SMALLINT = 28;
    DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
    DECLARE @KW_CONTINUE SMALLINT = 30;
    DECLARE @KW_CONVERT SMALLINT = 31;
    DECLARE @KW_CREATE SMALLINT = 32;
    DECLARE @KW_CROSS SMALLINT = 33;
    DECLARE @KW_CURRENT SMALLINT = 34;
    DECLARE @KW_CURRENT_DATE SMALLINT = 35;
    DECLARE @KW_CURRENT_TIME SMALLINT = 36;
    DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
    DECLARE @KW_CURRENT_USER SMALLINT = 38;
    DECLARE @KW_CURSOR SMALLINT = 39;
    DECLARE @KW_DATABASE SMALLINT = 40;
    DECLARE @KW_DBCC SMALLINT = 41;
    DECLARE @KW_DEALLOCATE SMALLINT = 42;
    DECLARE @KW_DECLARE SMALLINT = 43;
    DECLARE @KW_DEFAULT SMALLINT = 44;
    DECLARE @KW_DELETE SMALLINT = 45;
    DECLARE @KW_DENY SMALLINT = 46;
    DECLARE @KW_DESC SMALLINT = 47;
    DECLARE @KW_DISK SMALLINT = 48;
    DECLARE @KW_DISTINCT SMALLINT = 49;
    DECLARE @KW_DISTRIBUTED SMALLINT = 50;
    DECLARE @KW_DOUBLE SMALLINT = 51;
    DECLARE @KW_DROP SMALLINT = 52;
    DECLARE @KW_DUMP SMALLINT = 53;
    DECLARE @KW_ELSE SMALLINT = 54;
    DECLARE @KW_END SMALLINT = 55;
    DECLARE @KW_ERRLVL SMALLINT = 56;
    DECLARE @KW_ESCAPE SMALLINT = 57;
    DECLARE @KW_EXCEPT SMALLINT = 58;
    DECLARE @KW_EXEC SMALLINT = 59;
    DECLARE @KW_EXECUTE SMALLINT = 60;
    DECLARE @KW_EXISTS SMALLINT = 61;
    DECLARE @KW_EXIT SMALLINT = 62;
    DECLARE @KW_EXTERNAL SMALLINT = 63;
    DECLARE @KW_FETCH SMALLINT = 64;
    DECLARE @KW_FILE SMALLINT = 65;
    DECLARE @KW_FILLFACTOR SMALLINT = 66;
    DECLARE @KW_FOR SMALLINT = 67;
    DECLARE @KW_FOREIGN SMALLINT = 68;
    DECLARE @KW_FREETEXT SMALLINT = 69;
    DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
    DECLARE @KW_FROM SMALLINT = 71;
    DECLARE @KW_FULL SMALLINT = 72;
    DECLARE @KW_FUNCTION SMALLINT = 73;
    DECLARE @KW_GOTO SMALLINT = 74;
    DECLARE @KW_GRANT SMALLINT = 75;
    DECLARE @KW_GROUP SMALLINT = 76;
    DECLARE @KW_HAVING SMALLINT = 77;
    DECLARE @KW_HOLDLOCK SMALLINT = 78;
    DECLARE @KW_IDENTITY SMALLINT = 79;
    DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
    DECLARE @KW_IDENTITYCOL SMALLINT = 81;
    DECLARE @KW_IF SMALLINT = 82;
    DECLARE @KW_IN SMALLINT = 83;
    DECLARE @KW_INDEX SMALLINT = 84;
    DECLARE @KW_INNER SMALLINT = 85;
    DECLARE @KW_INSERT SMALLINT = 86;
    DECLARE @KW_INTERSECT SMALLINT = 87;
    DECLARE @KW_INTO SMALLINT = 88;
    DECLARE @KW_IS SMALLINT = 89;
    DECLARE @KW_JOIN SMALLINT = 90;
    DECLARE @KW_KEY SMALLINT = 91;
    DECLARE @KW_KILL SMALLINT = 92;
    DECLARE @KW_LEFT SMALLINT = 93;
    DECLARE @KW_LIKE SMALLINT = 94;
    DECLARE @KW_LINENO SMALLINT = 95;
    DECLARE @KW_LOAD SMALLINT = 96;
    DECLARE @KW_MERGE SMALLINT = 97;
    DECLARE @KW_NATIONAL SMALLINT = 98;
    DECLARE @KW_NOCHECK SMALLINT = 99;
    DECLARE @KW_NONCLUSTERED SMALLINT = 100;
    DECLARE @KW_NOT SMALLINT = 101;
    DECLARE @KW_NULL SMALLINT = 102;
    DECLARE @KW_NULLIF SMALLINT = 103;
    DECLARE @KW_OF SMALLINT = 104;
    DECLARE @KW_OFF SMALLINT = 105;
    DECLARE @KW_OFFSETS SMALLINT = 106;
    DECLARE @KW_ON SMALLINT = 107;
    DECLARE @KW_OPEN SMALLINT = 108;
    DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
    DECLARE @KW_OPENQUERY SMALLINT = 110;
    DECLARE @KW_OPENROWSET SMALLINT = 111;
    DECLARE @KW_OPENXML SMALLINT = 112;
    DECLARE @KW_OPTION SMALLINT = 113;
    DECLARE @KW_OR SMALLINT = 114;
    DECLARE @KW_ORDER SMALLINT = 115;
    DECLARE @KW_OUTER SMALLINT = 116;
    DECLARE @KW_OVER SMALLINT = 117;
    DECLARE @KW_PERCENT SMALLINT = 118;
    DECLARE @KW_PIVOT SMALLINT = 119;
    DECLARE @KW_PLAN SMALLINT = 120;
    DECLARE @KW_PRECISION SMALLINT = 121;
    DECLARE @KW_PRIMARY SMALLINT = 122;
    DECLARE @KW_PRINT SMALLINT = 123;
    DECLARE @KW_PROC SMALLINT = 124;
    DECLARE @KW_PROCEDURE SMALLINT = 125;
    DECLARE @KW_PUBLIC SMALLINT = 126;
    DECLARE @KW_RAISERROR SMALLINT = 127;
    DECLARE @KW_READ SMALLINT = 128;
    DECLARE @KW_READTEXT SMALLINT = 129;
    DECLARE @KW_RECONFIGURE SMALLINT = 130;
    DECLARE @KW_REFERENCES SMALLINT = 131;
    DECLARE @KW_REPLICATION SMALLINT = 132;
    DECLARE @KW_RESTORE SMALLINT = 133;
    DECLARE @KW_RESTRICT SMALLINT = 134;
    DECLARE @KW_RETURN SMALLINT = 135;
    DECLARE @KW_REVERT SMALLINT = 136;
    DECLARE @KW_REVOKE SMALLINT = 137;
    DECLARE @KW_RIGHT SMALLINT = 138;
    DECLARE @KW_ROLLBACK SMALLINT = 139;
    DECLARE @KW_ROWCOUNT SMALLINT = 140;
    DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
    DECLARE @KW_RULE SMALLINT = 142;
    DECLARE @KW_SAVE SMALLINT = 143;
    DECLARE @KW_SCHEMA SMALLINT = 144;
    DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
    DECLARE @KW_SELECT SMALLINT = 146;
    DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
    DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
    DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
    DECLARE @KW_SESSION_USER SMALLINT = 150;
    DECLARE @KW_SET SMALLINT = 151;
    DECLARE @KW_SETUSER SMALLINT = 152;
    DECLARE @KW_SHUTDOWN SMALLINT = 153;
    DECLARE @KW_SOME SMALLINT = 154;
    DECLARE @KW_STATISTICS SMALLINT = 155;
    DECLARE @KW_SYSTEM_USER SMALLINT = 156;
    DECLARE @KW_TABLE SMALLINT = 157;
    DECLARE @KW_TABLESAMPLE SMALLINT = 158;
    DECLARE @KW_TEXTSIZE SMALLINT = 159;
    DECLARE @KW_THEN SMALLINT = 160;
    DECLARE @KW_TO SMALLINT = 161;
    DECLARE @KW_TOP SMALLINT = 162;
    DECLARE @KW_TRAN SMALLINT = 163;
    DECLARE @KW_TRANSACTION SMALLINT = 164;
    DECLARE @KW_TRIGGER SMALLINT = 165;
    DECLARE @KW_TRUNCATE SMALLINT = 166;
    DECLARE @KW_TRY_CONVERT SMALLINT = 167;
    DECLARE @KW_TSEQUAL SMALLINT = 168;
    DECLARE @KW_UNION SMALLINT = 169;
    DECLARE @KW_UNIQUE SMALLINT = 170;
    DECLARE @KW_UNPIVOT SMALLINT = 171;
    DECLARE @KW_UPDATE SMALLINT = 172;
    DECLARE @KW_UPDATETEXT SMALLINT = 173;
    DECLARE @KW_USE SMALLINT = 174;
    DECLARE @KW_USER SMALLINT = 175;
    DECLARE @KW_VALUES SMALLINT = 176;
    DECLARE @KW_VARYING SMALLINT = 177;
    DECLARE @KW_VIEW SMALLINT = 178;
    DECLARE @KW_WAITFOR SMALLINT = 179;
    DECLARE @KW_WHEN SMALLINT = 180;
    DECLARE @KW_WHERE SMALLINT = 181;
    DECLARE @KW_WHILE SMALLINT = 182;
    DECLARE @KW_WITH SMALLINT = 183;
    DECLARE @KW_WITHIN SMALLINT = 184;
    DECLARE @KW_WRITETEXT SMALLINT = 185;
    DECLARE @KW_ATOMIC SMALLINT = 186;
    DECLARE @KW_CONVERSATION SMALLINT = 187;
    DECLARE @KW_DIALOG SMALLINT = 188;
    DECLARE @KW_CATCH SMALLINT = 189;
    DECLARE @KW_TRY SMALLINT = 190;
    DECLARE @KW_THROW SMALLINT = 191;
    DECLARE @KW_FILETABLE SMALLINT = 192;
    DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;

    DECLARE @elementId INT;

    DECLARE @typeId [tinyint];
    --DECLARE @sequenceId [smallint];
    --DECLARE @isStartElement [bit];
    DECLARE @nextElementId [int];
    DECLARE @altElementId [int];
    DECLARE @keywordId [smallint];
    DECLARE @operatorId [tinyint];
    DECLARE @sequenceTypeId [tinyint];
    DECLARE @statementPartId [tinyint];
    DECLARE @tokenTypeId [tinyint];
    DECLARE @tokenSubtypeId [tinyint];
    DECLARE @stringValue [nvarchar](200);
    DECLARE @intValue [bigint];

    DECLARE @tkTypeId TINYINT;
    DECLARE @tkKeywordId SMALLINT;
    DECLARE @tkSubtypeId SMALLINT;
    DECLARE @tkText NVARCHAR(MAX);
    DECLARE @tkLevel SMALLINT;
    DECLARE @tkStartTokenId INT;
    DECLARE @tkEndTokenId INT;
    DECLARE @tkBlockTypeId TINYINT;
    DECLARE @tkSeqStartTokenId INT;
    DECLARE @tkSeqEndTokenId INT;
    DECLARE @tkSeqTypeId TINYINT;
    DECLARE @tkOperatorId TINYINT;
    DECLARE @match BIT = 0;
    DECLARE @done BIT = 0;
    
    SELECT @elementId=MIN(el.[Id])
    FROM [Parser].[TSqlSeqElement] el
    WHERE el.[SequenceId]=@sequenceId;

    --PRINT('Get token details');
    SELECT @tkTypeId=tk.[TypeId], @tkKeywordId=tk.[KeywordId], @tkSubtypeId=tk.[SubtypeId], @tkText=tk.[Text], @tkLevel=tk.[Level], @tkStartTokenId=tk.[StartTokenId],
        @tkEndTokenId=tk.[EndTokenId], @tkBlockTypeId=tk.[BlockTypeId], @tkSeqStartTokenId=tk.[SeqStartTokenId], @tkSeqEndTokenId=tk.[SeqEndTokenId], 
        @tkSeqTypeId=tk.[SeqTypeId], @tkOperatorId=tk.[OperatorId]
    FROM #Token tk
    WHERE tk.[Id]=@tokenId;

    DECLARE @statementId INT = NULL;
    DECLARE @statementTypeId SMALLINT = NULL;
    DECLARE @isNewStatement BIT = 0;
    DECLARE @lastTokenIdBeforeChildStatement INT = NULL;

    SELECT @statementTypeId=st.[Id]
    FROM [Parser].[TSqlSequence] seq 
    JOIN [ParserEnum].[TSqlStatementType] st ON seq.[StatementTypeId]=st.[Id]
    WHERE seq.[Id]=@sequenceId;

    IF @statementTypeId IS NOT NULL
    BEGIN
		--PRINT('INSERT Statement ' + LOWER(@statementTypeId) + ', ' + LOWER(@tokenId));
        INSERT INTO #Statement ([TypeId], [StartTokenId])
        VALUES (@statementTypeId, @tokenId);
        SET @statementId=SCOPE_IDENTITY();
        SET @isNewStatement=1;
    END
    ELSE
    BEGIN
        SELECT @statementId=MAX([Id])
        FROM #Statement;
    END

    IF @statementId IS NULL
    BEGIN
        SELECT @rc=@RC_ERR_DATA, @errorMessage=N'Statement Id not set. Sequence Id: ' + @sequenceId;
        RETURN @rc;
    END

    DECLARE @tpsRc INT;
    DECLARE @tpsParentStatementId INT;
    DECLARE @tpsParentStatementPartId TINYINT;
    DECLARE @tpsLastTokenId INT;
    DECLARE @tpsIsFinished BIT;
    DECLARE @tpsStatementSeparatorTokenId INT;
    DECLARE @tpsErrorMessage NVARCHAR(4000);
    DECLARE @tpsSequenceId SMALLINT;
    DECLARE @elStatementTypeId SMALLINT;
    
    WHILE @elementId IS NOT NULL AND @done=0
    BEGIN
        --PRINT('Get element details');
        SELECT @typeId=el.[TypeId], @nextElementId=el.[NextElementId], @altElementId=el.[AltElementId], @keywordId=el.[KeywordId], @operatorId=el.[OperatorId],
            @sequenceTypeId=el.[SequenceTypeId], @statementPartId=el.[StatementPartId], @tokenTypeId=el.[TokenTypeId], @tokenSubtypeId=el.[TokenSubtypeId],
            @elStatementTypeId=el.[StatementTypeId], @stringValue=el.[StringValue], @intValue=el.[IntValue]
        FROM [Parser].[TSqlSeqElement] el
        WHERE el.[Id]=@elementId;

        

        --PRINT('Check if they match');
        
        SET @match=0;
        --SET @lastTokenId=NULL;

        IF @typeId=@ET_KEYWORD
        BEGIN
            IF @tkTypeId=@tokenTypeId AND @tkKeywordId=@keywordId
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId IN (@ET_IDENTIFIER, @ET_VARIABLE_NAME, @ET_SEPARATOR)
        BEGIN
            IF @tkTypeId=@tokenTypeId AND (@tokenSubtypeId IS NULL OR @tokenSubtypeId=@tkSubtypeId)
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId=@ET_OPERATOR
        BEGIN
            --PRINT('Operator');
            IF @tkTypeId=ISNULL(@tokenTypeId, @TT_OPERATOR) AND (@operatorId IS NULL OR @tkOperatorId=@operatorId) -- subtype?
            BEGIN
                SET @lastTokenId = @tkEndTokenId;
                SET @match=1;
                --PRINT('Operator match');
            END
        END ELSE IF @typeId IN (@ET_LITERAL, @ET_LITERAL_INT, @ET_LITERAL_STRING)
        BEGIN
            IF @tkTypeId=ISNULL(@tokenTypeId, @TT_LITERAL) AND ((@typeId=@ET_LITERAL_INT AND @tkSubtypeId=@TST_INTEGER) OR (@typeId=@ET_LITERAL_STRING AND @tkSubtypeId IN (@TST_STRING, @TST_UNICODE_STRING)) 
                OR (@typeId=@ET_LITERAL AND (@tokenSubtypeId IS NULL OR @tkSubtypeId=@tokenSubtypeId)))
            BEGIN
                SET @match=1;
            END
        END ELSE IF @typeId IN (@ET_SEQUENCE, @ET_STATEMENT)
        BEGIN
            IF @typeId=@ET_SEQUENCE
            BEGIN
                --PRINT('@ET_SEQUENCE');
                SELECT @tpsSequenceId=[Id]
                FROM [Parser].[TSqlSequence] WHERE [SequenceTypeId]=@sequenceTypeId;
            END
            ELSE
            BEGIN
                --PRINT('@ET_STATEMENT');
                SET @lastTokenIdBeforeChildStatement = @lastTokenId;
                SELECT @tpsSequenceId=[Id]
                FROM [Parser].[TSqlSequence] WHERE [StatementTypeId]=@elStatementTypeId;
            END
            -- recursively call [Parser].[TryParseStatement]
            EXEC @tpsRc = [Parser].[TryParseSequence] @tokenId, @tpsSequenceId, @statementId, @statementPartId, 
                @tpsLastTokenId OUTPUT, @tpsIsFinished OUTPUT, @tpsStatementSeparatorTokenId OUTPUT, @tpsErrorMessage OUTPUT;
            IF @tpsRc=@RC_OK
            BEGIN
                SET @match=1;
                SET @lastTokenId = @tpsLastTokenId;
            END
            ELSE IF @tpsRc<>@RC_NOT_MATCH
            BEGIN
                SET @errorMessage = N'[TryParseSequence] recursive call returned : ' + LOWER(@tpsRc) + N' - ' + ISNULL(@tpsErrorMessage, '<NULL>');
                SET @rc = @RC_ERR_DATA;
                RETURN @rc;
            END

        END ELSE IF @typeId=@ET_SPECIAL_SEQUENCE
        BEGIN
            --PRINT('@ET_SPECIAL_SEQUENCE');
            IF @sequenceTypeId = @SQT_MORE_TOKENS
            BEGIN
                SET @done = 1;
                SET @lastTokenId = @tokenId;
                SET @match = 1;
                SET @isFinished = 0;
                SELECT @statementSeparatorTokenId = MIN([Id])
                FROM #Token
                WHERE [Id] > @tokenId AND [TypeId]=@TT_SEPARATOR AND [SubtypeId]=@TST_SEMICOLON;
            END
            ELSE IF @sequenceTypeId=@SQT_SEQUENCE_IN_PARENTHESES AND @tkTypeId=@TT_DELIMITER AND @tkText=N'('
            BEGIN
                SET @match = 1;
                SET @lastTokenId = @tkEndTokenId;
            END
            ELSE IF @sequenceTypeId=@SQT_CASE_EXPRESSION AND @tkBlockTypeId=@BT_CASE_BLOCK AND @tkKeywordId=@KW_CASE
            BEGIN
                SET @match = 1;
                SET @lastTokenId = @tkEndTokenId;
            END
        END ELSE IF @typeId=@ET_END
        BEGIN
            --PRINT('@ET_END');
            SET @done = 1;
            SET @match = 1;
            SET @isFinished = 1;
        END ELSE
        BEGIN
            PRINT('???');
            SELECT @rc = @RC_ERR_DATA, @errorMessage=N'Unexpected element type: ' + LOWER(@typeId);
            RETURN @rc;
        END
        
        IF @done=1
        BEGIN
            --PRINT('MATCH');
            SET @elementId=NULL;
            SET @rc = @RC_OK;
            IF @parentStatementId IS NOT NULL AND  @parentStatementPartId IS NOT NULL
            BEGIN
				/*
				PRINT ('StatementPart ' + ISNULL(LOWER(@parentStatementId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@parentStatementPartId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@startTokenId), '<NULL>') 
				+ ', ' + ISNULL(LOWER(@lastTokenId), '<NULL>'));
				*/
                INSERT INTO #StatementPart ([StatementId], [TypeId], [StartTokenId], [EndTokenId])
                VALUES (@parentStatementId, @parentStatementPartId, @startTokenId, @lastTokenId);
            END
            IF @isNewStatement=1
            BEGIN
				--PRINT('******');
				--PRINT('[ParentStatementId]: ' + ISNULL(LOWER(@typeId), '<NULL>') + ' (' + LOWER(@ET_STATEMENT) + '), ' +  ISNULL(LOWER(@parentStatementId), '<NULL>'));
                UPDATE #Statement
                SET [EndTokenId]=ISNULL(@lastTokenIdBeforeChildStatement, @lastTokenId), [IsFinished]=@isFinished, [StatementSeparatorTokenId]=@statementSeparatorTokenId, 
                --[ParentStatementId]=CASE WHEN @typeId=@ET_STATEMENT THEN @parentStatementId ELSE NULL END
				[ParentStatementId]=@parentStatementId
                WHERE [Id]=@statementId;
				SET @isNewStatement=0; -- ????
				--PRINT ('UPDATE: ' + LOWER(@statementId) + '; Parent: ' + ISNULL(LOWER(CASE WHEN @typeId=@ET_STATEMENT THEN @parentStatementId ELSE NULL END), '<NULL>'));
				--PRINT('!!!!');
            END
        END
        ELSE
        BEGIN
            IF @match=0
            BEGIN
                SET @elementId=@altElementId;
                IF @elementId IS NULL
                BEGIN
                    --PRINT('NOT MATCH');
                    SET @rc = @RC_NOT_MATCH;
                    SET @done=1;
                    -- revert inserts from recursive calls
                    SET @statementId=SCOPE_IDENTITY();
                    SET @isNewStatement=1;
                    IF @isNewStatement=1
                    BEGIN
                        DELETE FROM #StatementPart
                        WHERE [StatementId]>=@statementId;
                        
                        DELETE FROM #Statement
                        WHERE [Id]>=@statementId;
                    END
                    ELSE
                    BEGIN
                        DELETE FROM #StatementPart
                        WHERE [StatementId]>@statementId;
                        
                        DELETE FROM #Statement
                        WHERE [Id]>@statementId;
                    END
                END
            END
            ELSE
            BEGIN
                
                IF @lastTokenId IS NULL OR @lastTokenId<@tokenId
                BEGIN
                    SET @lastTokenId = @tokenId;
                END

                SET @elementId=@nextElementId;
                IF @elementId IS NULL
                BEGIN
                    PRINT('ERROR');
                    SELECT @rc = @RC_ERR_DATA, @errorMessage=N'Next element not set. Sequence Id: ' + LOWER(@sequenceId);
                    RETURN @rc;
                END
                SELECT TOP(1) @tokenId=tk.[Id], @tkTypeId=tk.[TypeId], @tkKeywordId=tk.[KeywordId], @tkSubtypeId=tk.[SubtypeId], @tkText=tk.[Text], @tkLevel=tk.[Level], @tkStartTokenId=tk.[StartTokenId],
                    @tkEndTokenId=tk.[EndTokenId], @tkBlockTypeId=tk.[BlockTypeId], @tkSeqStartTokenId=tk.[SeqStartTokenId], @tkSeqEndTokenId=tk.[SeqEndTokenId],
                    @tkSeqTypeId=tk.[SeqTypeId], @tkOperatorId=tk.[OperatorId]
                FROM #Token tk
                WHERE tk.[Id]>@lastTokenId AND tk.[TypeId] NOT IN (@TT_COMMENT, @TT_WHITESPACE)
                ORDER BY tk.[Id];
            END
        END
        
        
        
        
    END

    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[AddProjectEnumMapping]...';


GO
-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Updated:     2025-07-02
-- Description: Adds an enum mapping to a project, avoiding duplicates.
-- Parameters:
--   @projectId      - Target project ID
--   @schema         - Schema of the enum table
--   @nameMatchId    - Name matching strategy (from enum)
--   @namePattern    - Pattern used to match the enum
--   @escChar        - Escape character used in pattern (if any)
--   @isSetOfFlags   - Whether this enum is a set of flags
--   @nameColumn     - Column name for enum display name
--   @id             - ID of the inserted or existing row
--   @errorMessage   - detailed error message if any
-- =============================================
CREATE PROCEDURE [Toolkit].[AddProjectEnumMapping]
    @projectId      SMALLINT,
    @schema         NVARCHAR(128),
    @nameMatchId    TINYINT,
    @namePattern    NVARCHAR(200),
    @escChar        NCHAR(1),
    @isSetOfFlags   BIT,
    @nameColumn     NVARCHAR(128),
    @id             INT OUTPUT,
    @errorMessage   NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
	SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;

	
	DECLARE @NM_LIKE TINYINT = 4;
	DECLARE @NM_ANY TINYINT = 255;

    SET @id = NULL;
    SET @errorMessage = NULL;
	DECLARE @errorCode VARCHAR(100) = 'InternalError';
	SET @id = NULL;

    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

	IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'UnknownProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF ISNULL(@schema, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'SchemaNotProvided';
        RETURN @rc;
    END

	IF @nameMatchId <> @NM_ANY AND ISNULL(@namePattern, '') = ''
    BEGIN
        SET @errorCode = 'NamePatternNotProvided';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF @nameMatchId <> @NM_LIKE AND @escChar IS NOT NULL
	BEGIN
        SET @errorCode = 'UnexpectedEscChar';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

	IF EXISTS (
		SELECT 1 FROM [dbo].[ProjectEnum] 
		WHERE [ProjectId] = @projectId AND [Schema] = @schema AND [NamePattern] = @namePattern
	)
	BEGIN
        SET @errorCode = 'DuplicateEnumMapping';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectEnum]
        (
			[ProjectId], [Schema], [NameMatchId], [NamePattern], [EscChar], [IsSetOfFlags], [NameColumn]
        )
        VALUES
        (
			@projectId, @schema, @nameMatchId, @namePattern, @escChar, @isSetOfFlags, @nameColumn
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;
        

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[AddProjectNameNormalization]...';


GO
CREATE   PROCEDURE [Toolkit].[AddProjectNameNormalization]
    @projectId SMALLINT,
    @namePart NVARCHAR(128),
    @namePartTypeId TINYINT,
    @id INT OUTPUT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
    DECLARE @rc INT = @RC_INTERNAL_ERROR,
        @errorCode VARCHAR(100) = 'InternalError',
        @tranCount INT = @@TRANCOUNT;

    SET @id = NULL;
    SET @errorMessage = NULL;

    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'UnknownProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id] = @namePartTypeId)
    BEGIN
        SET @errorCode = 'InvalidNamePartType';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectNameNormalization]
        (
            [ProjectId],
            [NamePart],
            [NamePartTypeId]
        )
        VALUES
        (
            @projectId,
            @namePart,
            @namePartTypeId
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[AddProjectStoredProcMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Updated:     2025-07-02
-- Description: Adds a stored procedure mapping to a project.
-- Parameters:
--   @projectId             - Target project ID
--   @schema                - Schema of the procedure
--   @nameMatchId           - Name matching strategy
--   @namePattern           - Pattern for matching
--   @escChar               - Escape character for LIKE pattern
--   @languageOptionsReset  - Options to reset (bitmask)
--   @languageOptionsSet    - Options to set (bitmask)
--   @id                    - Output ID of new row
--   @errorMessage          - Output error message if any
-- =============================================
CREATE PROCEDURE [Toolkit].[AddProjectStoredProcMapping]
    @projectId             SMALLINT,
    @schema                NVARCHAR(128),
    @nameMatchId           TINYINT,
    @namePattern           NVARCHAR(200),
    @escChar               NCHAR(1),
    @languageOptionsReset  BIGINT,
    @languageOptionsSet    BIGINT,
    @id                    INT OUTPUT,
    @errorMessage          NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
    
	DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    DECLARE @NM_LIKE TINYINT = 4;
    DECLARE @NM_ANY TINYINT = 255;

    SET @id = NULL;
    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';
        RETURN @rc;
    END

	IF ISNULL(@schema, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'SchemaNotProvided';
        RETURN @rc;
    END

    IF @nameMatchId <> @NM_ANY AND ISNULL(@namePattern, '') = ''
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'NamePatternNotProvided';
        RETURN @rc;
    END

    IF @nameMatchId <> @NM_LIKE AND @escChar IS NOT NULL
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnexpectedEscChar';
        RETURN @rc;
    END

    IF EXISTS (
        SELECT 1 FROM [dbo].[ProjectStoredProc]
        WHERE [ProjectId] = @projectId AND [Schema] = @schema AND [NamePattern] = @namePattern
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'DuplicateStoredProcMapping';
        RETURN @rc;
    END

    -- Insert
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        INSERT INTO [dbo].[ProjectStoredProc]
        (
            [ProjectId],
            [Schema],
            [NameMatchId],
            [NamePattern],
            [EscChar],
            [LanguageOptionsReset],
            [LanguageOptionsSet]
        )
        VALUES
        (
            @projectId,
            @schema,
            @nameMatchId,
            @namePattern,
            @escChar,
            @languageOptionsReset,
            @languageOptionsSet
        );

        SET @id = SCOPE_IDENTITY();
        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetDbInfo]...';


GO

-- =============================================
-- 2️⃣ [Toolkit].[GetDbInfo]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetDbInfo]
    @dbName NVARCHAR(128) OUTPUT,
    @version NVARCHAR(50) OUTPUT,
    @apiLevel TINYINT OUTPUT,
    @minApiLevel TINYINT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT TOP (1)
        @dbName = [DbInfo].[GetName](),
        @version = [Version],
        @apiLevel = [ApiLevel],
        @minApiLevel = [MinApiLevel]
    FROM [dbo].[SchemaVersion]
    ORDER BY [Id] DESC; -- Consistent with [DbInfo].[GetCurrentVersion]

END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetLanguageOptions]...';


GO
-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-06-29
-- Description: Returns all primary language options for the specified language,
--              including global options (LanguageId IS NULL).
-- Parameters:
--   @languageId - Language ID to filter by
-- =============================================
CREATE PROCEDURE [Toolkit].[GetLanguageOptions]
    @languageId TINYINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        [Id],
        [Name],
        [Value],
        [IsOverridablePerStoredProc]
    FROM [Static].[LanguageOption]
    WHERE 
        [IsPrimary] = 1
        AND ISNULL([LanguageId], @languageId) = @languageId
    ORDER BY [Value];
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetLanguages]...';


GO

-- =============================================
-- 3️⃣ [Toolkit].[GetLanguages]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetLanguages]
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        [Id],
        [Name],
        [Code]
    FROM [Enum].[Language]
    WHERE [StatusId] = 1
    ORDER BY [Id];
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemaEnumCandidates]...';


GO

CREATE   PROCEDURE [Toolkit].[GetProjectDbSchemaEnumCandidates]
    @projectId SMALLINT,
    @schema NVARCHAR(128)
AS
BEGIN
    SET NOCOUNT ON;

    DROP TABLE IF EXISTS #Result;

    CREATE TABLE #Result
    (
        [Name] NVARCHAR(128) NOT NULL PRIMARY KEY, -- Table name
        [NameColumn] NVARCHAR(128) NULL,           -- Auto-detected name column (optional)
        [NameColumns] NVARCHAR(4000) NOT NULL      -- JSON array of char-like columns
    );

    DECLARE @dbName NVARCHAR(256);
    SELECT @dbName = d.[name]
    FROM [dbo].[Project] p
    JOIN [sys].[databases] d ON p.[DefaultDatabase] = d.[name]
    WHERE p.[Id] = @projectId;

    IF @dbName IS NULL
    BEGIN
        RAISERROR('Could not resolve target database name for the specified project.', 16, 1);
        RETURN;
    END

    DECLARE @sql NVARCHAR(MAX);

    SET @sql = N'
    WITH CandidateTables AS (
        SELECT t.[name] AS TableName, t.[object_id]
        FROM ' + QUOTENAME(@dbName) + '.sys.tables t
        JOIN ' + QUOTENAME(@dbName) + '.sys.schemas s ON t.[schema_id] = s.[schema_id]
        WHERE s.[name] = @schema
        AND EXISTS (
            SELECT 1
            FROM ' + QUOTENAME(@dbName) + '.sys.indexes i
            JOIN ' + QUOTENAME(@dbName) + '.sys.index_columns ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
            JOIN ' + QUOTENAME(@dbName) + '.sys.columns c ON ic.[object_id] = c.[object_id] AND ic.[column_id] = c.[column_id]
            WHERE i.[object_id] = t.[object_id]
              AND i.is_primary_key = 1
              AND c.system_type_id IN (48, 52, 56, 127) -- tinyint, smallint, int, bigint
            GROUP BY i.[object_id]
            HAVING COUNT(*) = 1
        )
        AND EXISTS (
            SELECT 1
            FROM ' + QUOTENAME(@dbName) + '.sys.columns c
            WHERE c.[object_id] = t.[object_id]
              AND c.system_type_id IN (175, 239, 167, 231) -- char, nchar, varchar, nvarchar
        )
    )
    INSERT INTO #Result ([Name], [NameColumn], [NameColumns])
    SELECT 
        ct.TableName,
        (
            SELECT TOP 1 c.[name]
            FROM ' + QUOTENAME(@dbName) + '.sys.indexes i
            JOIN ' + QUOTENAME(@dbName) + '.sys.index_columns ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
            JOIN ' + QUOTENAME(@dbName) + '.sys.columns c ON ic.[object_id] = c.[object_id] AND ic.[column_id] = c.[column_id]
            WHERE i.[object_id] = ct.[object_id]
              AND i.is_unique = 1
              AND c.system_type_id IN (175, 239, 167, 231)
            GROUP BY c.[name]
            HAVING COUNT(*) = 1
        ),
        (
            SELECT c.[name]
            FROM ' + QUOTENAME(@dbName) + '.sys.columns c
            WHERE c.[object_id] = ct.[object_id]
              AND c.system_type_id IN (175, 239, 167, 231)
            FOR JSON PATH
        )
    FROM CandidateTables ct;
    ';

    EXEC sp_executesql @sql, N'@schema NVARCHAR(128)', @schema = @schema;

    SELECT [Name], [NameColumn], [NameColumns]
    FROM #Result
    ORDER BY [Name];

    DROP TABLE IF EXISTS #Result;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemaProcs]...';


GO

CREATE PROCEDURE [Toolkit].[GetProjectDbSchemaProcs]
    @projectId SMALLINT,
	@schema NVARCHAR(128)
AS
BEGIN
    SET NOCOUNT ON;

	DROP TABLE IF EXISTS #Result;

	CREATE TABLE #Result
	(
		[Name] NVARCHAR(128) NOT NULL PRIMARY KEY
	);
	DECLARE @query NVARCHAR(1000);
	SELECT @query='SELECT p.[name] FROM ' + QUOTENAME(d.[name]) 
		+ '.[sys].[procedures] p WHERE p.[Type]=''P'' AND SCHEMA_NAME(p.schema_id)=' + QUOTENAME(@schema, '''') + ' ORDER BY p.[name]'
	FROM [dbo].[Project] p
	JOIN [sys].[databases] d ON p.[DefaultDatabase]=d.[name] 
	WHERE p.[Id]=@projectId;

	--PRINT @query;

	INSERT INTO #Result ([Name])
	EXEC(@query);
    
	SELECT [Name]
	FROM #Result
	ORDER BY [Name];

	DROP TABLE IF EXISTS #Result;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDbSchemas]...';


GO

CREATE PROCEDURE [Toolkit].[GetProjectDbSchemas]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

	DROP TABLE IF EXISTS #Result;

	CREATE TABLE #Result
	(
		[Name] NVARCHAR(128) NOT NULL PRIMARY KEY
	);
	DECLARE @query NVARCHAR(1000);
	SELECT @query='SELECT [name] FROM ' + QUOTENAME(d.[name]) 
		+ '.[sys].[schemas] WHERE [schema_id]<16384 AND [name] NOT IN (''guest'', ''INFORMATION_SCHEMA'', ''sys'') ORDER BY [name]'
	FROM [dbo].[Project] p
	JOIN [sys].[databases] d ON p.[DefaultDatabase]=d.[name] 
	WHERE p.[Id]=@projectId;

	--PRINT @query;

	INSERT INTO #Result ([Name])
	EXEC(@query);
    
	SELECT [Name]
	FROM #Result
	ORDER BY [Name];

	DROP TABLE IF EXISTS #Result;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectDetails]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectDetails]
    @projectName NVARCHAR(200),
    @projectId SMALLINT OUTPUT,
    @languageId TINYINT OUTPUT,
    @defaultDatabase NVARCHAR(128) OUTPUT,
	@className VARCHAR(100) OUTPUT,
	@namespaceName VARCHAR(100) OUTPUT,
	@classAccessId TINYINT OUTPUT,
	@languageOptions BIGINT OUTPUT,
	@paramEnumMappingId TINYINT OUTPUT,
	@mapResultSetEnums BIT OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_UNKNOWN_PROJECT INT = 3;  -- Matches [Enum].[ToolkitResponseCode]
    DECLARE @rc INT = @RC_UNKNOWN_PROJECT;

    -- Look up project by name
    SELECT 
        @projectId = p.[Id],
        @languageId = p.[LanguageId],
        @defaultDatabase = p.[DefaultDatabase],
		@className = p.[ClassName],
		@namespaceName = p.[NamespaceName],
		@classAccessId = p.[ClassAccessId],
		@languageOptions = p.[LanguageOptions],
		@paramEnumMappingId = p.[ParamEnumMappingId],
		@mapResultSetEnums = p.[MapResultSetEnums]
    FROM [dbo].[Project] p
    WHERE p.[Name] = @projectName;

    IF @projectId IS NULL
    BEGIN
        SELECT @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';

        RETURN @RC_UNKNOWN_PROJECT;
    END

    -- Validate default database is a user DB only (database_id > 4)
    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (
        SELECT 1 
        FROM sys.databases 
        WHERE [name] = @defaultDatabase AND [database_id] > 4
    )
    BEGIN
        SET @defaultDatabase = NULL;
    END

    SET @rc = @RC_OK;
    RETURN @rc;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectEnumMappings]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectEnumMappings]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [Schema], [NameMatchId], [NamePattern], [EscChar], [IsSetOfFlags], [NameColumn]
	FROM [dbo].[ProjectEnum]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];

END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectInfo]...';


GO
CREATE   PROCEDURE [Toolkit].[GetProjectInfo]
    @projectName NVARCHAR(200),
    @projectId SMALLINT OUTPUT,
    @languageId TINYINT OUTPUT,
    @defaultDatabase NVARCHAR(128) OUTPUT,
	@className VARCHAR(100) OUTPUT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_UNKNOWN_PROJECT INT = 3;  -- Matches [Enum].[ToolkitResponseCode]
    DECLARE @rc INT = @RC_UNKNOWN_PROJECT;

    -- Look up project by name
    SELECT 
        @projectId = p.[Id],
        @languageId = p.[LanguageId],
        @defaultDatabase = p.[DefaultDatabase],
		@className = p.[ClassName]
    FROM [dbo].[Project] p
    WHERE p.[Name] = @projectName;

    IF @projectId IS NULL
    BEGIN
        SELECT @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownProject';

        RETURN @RC_UNKNOWN_PROJECT;
    END

    -- Validate default database is a user DB only (database_id > 4)
    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (
        SELECT 1 
        FROM sys.databases 
        WHERE [name] = @defaultDatabase AND [database_id] > 4
    )
    BEGIN
        SET @defaultDatabase = NULL;
    END

    SET @rc = @RC_OK;
    RETURN @rc;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectNameNormalizations]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectNameNormalizations]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [NamePart], [NamePartTypeId]
	FROM [dbo].[ProjectNameNormalization]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjects]...';


GO

-- =============================================
-- 4️⃣ [Toolkit].[GetProjects]
-- =============================================
CREATE   PROCEDURE [Toolkit].[GetProjects]
    @languageId TINYINT = NULL
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        p.[Id],
        p.[Name],
        p.[ClassName],
        p.[NamespaceName],
        l.[Name] AS [LanguageName],
        l.[Code] AS [LanguageCode]
    FROM [dbo].[Project] p
    LEFT JOIN [Enum].[Language] l ON l.[Id] = p.[LanguageId]
    WHERE (@languageId IS NULL OR p.[LanguageId] = @languageId)
    ORDER BY p.[Name];
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GetProjectStoredProcedureMappings]...';


GO
CREATE PROCEDURE [Toolkit].[GetProjectStoredProcedureMappings]
    @projectId SMALLINT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT [Id], [Schema], [NameMatchId], [NamePattern], [EscChar], [LanguageOptionsReset], [LanguageOptionsSet]
	FROM [dbo].[ProjectStoredProc]
	WHERE [ProjectId]=@projectId
	ORDER BY [Id];
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectEnumMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-07-02
-- Description: Removes an enum mapping from a project.
-- Parameters:
--   @projectId             - Target project ID
--   @spMappingId           - ID of the mapping to be removed
--   @errorMessage          - Output error message if any
-- =============================================
CREATE   PROCEDURE [Toolkit].[RemoveProjectEnumMapping]
    @projectId SMALLINT,
    @enumMappingId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
   
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectEnum]
        WHERE [Id] = @enumMappingId AND [ProjectId] = @projectId
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownEnumMapping';
        RETURN @rc;
    END

    -- Delete
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectEnum]
        WHERE [Id] = @enumMappingId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectNameNormalization]...';


GO
CREATE   PROCEDURE [Toolkit].[RemoveProjectNameNormalization]
    @projectId SMALLINT,
    @normalizationId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;

    DECLARE @rc INT = @RC_INTERNAL_ERROR,
        @errorCode VARCHAR(100) = 'InternalError',
        @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectNameNormalization]
        WHERE [Id] = @normalizationId AND [ProjectId] = @projectId
    )
    BEGIN
        SET @errorCode = 'UnknownNameNormalization';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectNameNormalization]
        WHERE [Id] = @normalizationId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[RemoveProjectStoredProcMapping]...';


GO

-- =============================================
-- Author:      IT Tiger team
-- Created:     2025-07-02
-- Description: Removes a stored procedure mapping from a project.
-- Parameters:
--   @projectId             - Target project ID
--   @spMappingId           - ID of the mapping to be removed
--   @errorMessage          - Output error message if any
-- =============================================
CREATE   PROCEDURE [Toolkit].[RemoveProjectStoredProcMapping]
    @projectId SMALLINT,
    @spMappingId INT,
    @errorMessage NVARCHAR(4000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE 
        @RC_OK INT = 0,
        @RC_DB_ERROR INT = 1,
        @RC_INTERNAL_ERROR INT = 2;
   
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;

    SET @errorMessage = NULL;

    -- Validation
    IF NOT EXISTS (
        SELECT 1 FROM [dbo].[ProjectStoredProc]
        WHERE [Id] = @spMappingId AND [ProjectId] = @projectId
    )
    BEGIN
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = 'UnknownStoredProcMapping';
        RETURN @rc;
    END

    -- Delete
    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        DELETE FROM [dbo].[ProjectStoredProc]
        WHERE [Id] = @spMappingId AND [ProjectId] = @projectId;

        SET @rc = @RC_OK;

        IF @tranCount = 0
            COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END;
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[UpdateProject]...';


GO

CREATE   PROCEDURE [Toolkit].[UpdateProject]
    @projectId SMALLINT,
    @name NVARCHAR(200) = NULL,
    @namespaceName VARCHAR(100) = NULL,
    @className VARCHAR(100) = NULL,
    @classAccessId TINYINT = NULL,
    @paramEnumMappingId TINYINT = NULL,
    @mapResultSetEnums BIT = NULL,
    @languageOptions BIGINT = NULL,
    @defaultDatabase NVARCHAR(128) = NULL,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_DB_ERROR INT = 1;
    DECLARE @RC_INTERNAL_ERROR INT = 2;
    DECLARE @rc INT = @RC_INTERNAL_ERROR;
    DECLARE @tranCount INT = @@TRANCOUNT;
    DECLARE @errorCode VARCHAR(100) = 'InternalError';

    IF NOT EXISTS (SELECT 1 FROM [dbo].[Project] WHERE [Id] = @projectId)
    BEGIN
        SET @errorCode = 'MissingProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @classAccessId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id] = @classAccessId)
    BEGIN
        SET @errorCode = 'InvalidClassAccess';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @paramEnumMappingId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id] = @paramEnumMappingId)
    BEGIN
        SET @errorCode = 'InvalidParamEnumMapping';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @defaultDatabase IS NOT NULL AND NOT EXISTS (SELECT 1 FROM [sys].[databases] WHERE [name] = @defaultDatabase)
    BEGIN
        SET @errorCode = 'InvalidDatabase';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    IF @name IS NOT NULL AND EXISTS (
        SELECT 1 FROM [dbo].[Project] WHERE [Name] = @name AND [Id] <> @projectId
    )
    BEGIN
        SET @errorCode = 'DuplicateProject';
        SELECT @rc = [Id], @errorMessage = [Description]
        FROM [Enum].[ToolkitResponseCode]
        WHERE [Name] = @errorCode;
        RETURN @rc;
    END

    BEGIN TRY
        IF @tranCount = 0
            BEGIN TRANSACTION;
        ELSE
            SAVE TRANSACTION TrnSp;

        UPDATE [dbo].[Project]
        SET 
            [Name] = COALESCE(@name, [Name]),
            [NamespaceName] = COALESCE(@namespaceName, [NamespaceName]),
            [ClassName] = COALESCE(@className, [ClassName]),
            [ClassAccessId] = COALESCE(@classAccessId, [ClassAccessId]),
            [ParamEnumMappingId] = COALESCE(@paramEnumMappingId, [ParamEnumMappingId]),
            [MapResultSetEnums] = COALESCE(@mapResultSetEnums, [MapResultSetEnums]),
            [LanguageOptions] = COALESCE(@languageOptions, [LanguageOptions]),
            [DefaultDatabase] = COALESCE(@defaultDatabase, [DefaultDatabase])
        WHERE [Id] = @projectId;

        IF @tranCount = 0
            COMMIT TRANSACTION;

        SET @rc = @RC_OK;
    END TRY
    BEGIN CATCH
        SET @rc = @RC_DB_ERROR;
        SET @errorMessage = ERROR_MESSAGE();

        IF XACT_STATE() = -1 ROLLBACK;
        ELSE IF XACT_STATE() = 1
            IF @tranCount = 0 ROLLBACK;
            ELSE ROLLBACK TRANSACTION TrnSp;

        EXEC [Internal].[LogError];
    END CATCH

    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Parser].[TryDescribeFirstResultSetWorkaround]...';


GO

ALTER PROCEDURE [Parser].[TryDescribeFirstResultSetWorkaround]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,	
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_PARSE INT = 1;

	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;


    DECLARE @ST_CREATE_PROCEDURE SMALLINT = 1;
    DECLARE @ST_CREATE_TABLE SMALLINT = 2;
    DECLARE @ST_EXEC SMALLINT = 3;
    DECLARE @ST_SELECT SMALLINT = 4;
    DECLARE @ST_INSERT SMALLINT = 5;
    DECLARE @ST_UPDATE SMALLINT = 6;
    DECLARE @ST_DELETE SMALLINT = 7;
    DECLARE @ST_DECLARE SMALLINT = 8;
    DECLARE @ST_SET SMALLINT = 9;

    DECLARE @ST_TRUNCATE_TABLE SMALLINT = 10;
    DECLARE @ST_DROP_TABLE SMALLINT = 11;

    DECLARE @ST_BEGIN_TRANSACTION SMALLINT = 20;
    DECLARE @ST_BEGIN_DISTRIBUTED_TRANSACTION SMALLINT = 21;
    DECLARE @ST_COMMIT SMALLINT = 23;
    DECLARE @ST_ROLLBACK SMALLINT = 24;

    DECLARE @ST_IF SMALLINT = 31;
    DECLARE @ST_WHILE SMALLINT = 32;
    DECLARE @ST_CONTINUE SMALLINT = 33;
    DECLARE @ST_BREAK SMALLINT = 34;
    DECLARE @ST_THROW SMALLINT = 35;
    DECLARE @ST_RAISERROR SMALLINT = 36;
    DECLARE @ST_PRINT SMALLINT = 37;
    DECLARE @ST_RETURN SMALLINT = 38;
	
    DECLARE @SP_IDENTIFIER TINYINT = 1;
    DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
    DECLARE @SP_DEFINITION TINYINT = 3;
    DECLARE @SP_CHILD_STATEMENT TINYINT = 4;

    DECLARE @KW_ADD SMALLINT = 1;
    DECLARE @KW_ALL SMALLINT = 2;
    DECLARE @KW_ALTER SMALLINT = 3;
    DECLARE @KW_AND SMALLINT = 4;
    DECLARE @KW_ANY SMALLINT = 5;
    DECLARE @KW_AS SMALLINT = 6;
    DECLARE @KW_ASC SMALLINT = 7;
    DECLARE @KW_AUTHORIZATION SMALLINT = 8;
    DECLARE @KW_BACKUP SMALLINT = 9;
    DECLARE @KW_BEGIN SMALLINT = 10;
    DECLARE @KW_BETWEEN SMALLINT = 11;
    DECLARE @KW_BREAK SMALLINT = 12;
    DECLARE @KW_BROWSE SMALLINT = 13;
    DECLARE @KW_BULK SMALLINT = 14;
    DECLARE @KW_BY SMALLINT = 15;
    DECLARE @KW_CASCADE SMALLINT = 16;
    DECLARE @KW_CASE SMALLINT = 17;
    DECLARE @KW_CHECK SMALLINT = 18;
    DECLARE @KW_CHECKPOINT SMALLINT = 19;
    DECLARE @KW_CLOSE SMALLINT = 20;
    DECLARE @KW_CLUSTERED SMALLINT = 21;
    DECLARE @KW_COALESCE SMALLINT = 22;
    DECLARE @KW_COLLATE SMALLINT = 23;
    DECLARE @KW_COLUMN SMALLINT = 24;
    DECLARE @KW_COMMIT SMALLINT = 25;
    DECLARE @KW_COMPUTE SMALLINT = 26;
    DECLARE @KW_CONSTRAINT SMALLINT = 27;
    DECLARE @KW_CONTAINS SMALLINT = 28;
    DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
    DECLARE @KW_CONTINUE SMALLINT = 30;
    DECLARE @KW_CONVERT SMALLINT = 31;
    DECLARE @KW_CREATE SMALLINT = 32;
    DECLARE @KW_CROSS SMALLINT = 33;
    DECLARE @KW_CURRENT SMALLINT = 34;
    DECLARE @KW_CURRENT_DATE SMALLINT = 35;
    DECLARE @KW_CURRENT_TIME SMALLINT = 36;
    DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
    DECLARE @KW_CURRENT_USER SMALLINT = 38;
    DECLARE @KW_CURSOR SMALLINT = 39;
    DECLARE @KW_DATABASE SMALLINT = 40;
    DECLARE @KW_DBCC SMALLINT = 41;
    DECLARE @KW_DEALLOCATE SMALLINT = 42;
    DECLARE @KW_DECLARE SMALLINT = 43;
    DECLARE @KW_DEFAULT SMALLINT = 44;
    DECLARE @KW_DELETE SMALLINT = 45;
    DECLARE @KW_DENY SMALLINT = 46;
    DECLARE @KW_DESC SMALLINT = 47;
    DECLARE @KW_DISK SMALLINT = 48;
    DECLARE @KW_DISTINCT SMALLINT = 49;
    DECLARE @KW_DISTRIBUTED SMALLINT = 50;
    DECLARE @KW_DOUBLE SMALLINT = 51;
    DECLARE @KW_DROP SMALLINT = 52;
    DECLARE @KW_DUMP SMALLINT = 53;
    DECLARE @KW_ELSE SMALLINT = 54;
    DECLARE @KW_END SMALLINT = 55;
    DECLARE @KW_ERRLVL SMALLINT = 56;
    DECLARE @KW_ESCAPE SMALLINT = 57;
    DECLARE @KW_EXCEPT SMALLINT = 58;
    DECLARE @KW_EXEC SMALLINT = 59;
    DECLARE @KW_EXECUTE SMALLINT = 60;
    DECLARE @KW_EXISTS SMALLINT = 61;
    DECLARE @KW_EXIT SMALLINT = 62;
    DECLARE @KW_EXTERNAL SMALLINT = 63;
    DECLARE @KW_FETCH SMALLINT = 64;
    DECLARE @KW_FILE SMALLINT = 65;
    DECLARE @KW_FILLFACTOR SMALLINT = 66;
    DECLARE @KW_FOR SMALLINT = 67;
    DECLARE @KW_FOREIGN SMALLINT = 68;
    DECLARE @KW_FREETEXT SMALLINT = 69;
    DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
    DECLARE @KW_FROM SMALLINT = 71;
    DECLARE @KW_FULL SMALLINT = 72;
    DECLARE @KW_FUNCTION SMALLINT = 73;
    DECLARE @KW_GOTO SMALLINT = 74;
    DECLARE @KW_GRANT SMALLINT = 75;
    DECLARE @KW_GROUP SMALLINT = 76;
    DECLARE @KW_HAVING SMALLINT = 77;
    DECLARE @KW_HOLDLOCK SMALLINT = 78;
    DECLARE @KW_IDENTITY SMALLINT = 79;
    DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
    DECLARE @KW_IDENTITYCOL SMALLINT = 81;
    DECLARE @KW_IF SMALLINT = 82;
    DECLARE @KW_IN SMALLINT = 83;
    DECLARE @KW_INDEX SMALLINT = 84;
    DECLARE @KW_INNER SMALLINT = 85;
    DECLARE @KW_INSERT SMALLINT = 86;
    DECLARE @KW_INTERSECT SMALLINT = 87;
    DECLARE @KW_INTO SMALLINT = 88;
    DECLARE @KW_IS SMALLINT = 89;
    DECLARE @KW_JOIN SMALLINT = 90;
    DECLARE @KW_KEY SMALLINT = 91;
    DECLARE @KW_KILL SMALLINT = 92;
    DECLARE @KW_LEFT SMALLINT = 93;
    DECLARE @KW_LIKE SMALLINT = 94;
    DECLARE @KW_LINENO SMALLINT = 95;
    DECLARE @KW_LOAD SMALLINT = 96;
    DECLARE @KW_MERGE SMALLINT = 97;
    DECLARE @KW_NATIONAL SMALLINT = 98;
    DECLARE @KW_NOCHECK SMALLINT = 99;
    DECLARE @KW_NONCLUSTERED SMALLINT = 100;
    DECLARE @KW_NOT SMALLINT = 101;
    DECLARE @KW_NULL SMALLINT = 102;
    DECLARE @KW_NULLIF SMALLINT = 103;
    DECLARE @KW_OF SMALLINT = 104;
    DECLARE @KW_OFF SMALLINT = 105;
    DECLARE @KW_OFFSETS SMALLINT = 106;
    DECLARE @KW_ON SMALLINT = 107;
    DECLARE @KW_OPEN SMALLINT = 108;
    DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
    DECLARE @KW_OPENQUERY SMALLINT = 110;
    DECLARE @KW_OPENROWSET SMALLINT = 111;
    DECLARE @KW_OPENXML SMALLINT = 112;
    DECLARE @KW_OPTION SMALLINT = 113;
    DECLARE @KW_OR SMALLINT = 114;
    DECLARE @KW_ORDER SMALLINT = 115;
    DECLARE @KW_OUTER SMALLINT = 116;
    DECLARE @KW_OVER SMALLINT = 117;
    DECLARE @KW_PERCENT SMALLINT = 118;
    DECLARE @KW_PIVOT SMALLINT = 119;
    DECLARE @KW_PLAN SMALLINT = 120;
    DECLARE @KW_PRECISION SMALLINT = 121;
    DECLARE @KW_PRIMARY SMALLINT = 122;
    DECLARE @KW_PRINT SMALLINT = 123;
    DECLARE @KW_PROC SMALLINT = 124;
    DECLARE @KW_PROCEDURE SMALLINT = 125;
    DECLARE @KW_PUBLIC SMALLINT = 126;
    DECLARE @KW_RAISERROR SMALLINT = 127;
    DECLARE @KW_READ SMALLINT = 128;
    DECLARE @KW_READTEXT SMALLINT = 129;
    DECLARE @KW_RECONFIGURE SMALLINT = 130;
    DECLARE @KW_REFERENCES SMALLINT = 131;
    DECLARE @KW_REPLICATION SMALLINT = 132;
    DECLARE @KW_RESTORE SMALLINT = 133;
    DECLARE @KW_RESTRICT SMALLINT = 134;
    DECLARE @KW_RETURN SMALLINT = 135;
    DECLARE @KW_REVERT SMALLINT = 136;
    DECLARE @KW_REVOKE SMALLINT = 137;
    DECLARE @KW_RIGHT SMALLINT = 138;
    DECLARE @KW_ROLLBACK SMALLINT = 139;
    DECLARE @KW_ROWCOUNT SMALLINT = 140;
    DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
    DECLARE @KW_RULE SMALLINT = 142;
    DECLARE @KW_SAVE SMALLINT = 143;
    DECLARE @KW_SCHEMA SMALLINT = 144;
    DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
    DECLARE @KW_SELECT SMALLINT = 146;
    DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
    DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
    DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
    DECLARE @KW_SESSION_USER SMALLINT = 150;
    DECLARE @KW_SET SMALLINT = 151;
    DECLARE @KW_SETUSER SMALLINT = 152;
    DECLARE @KW_SHUTDOWN SMALLINT = 153;
    DECLARE @KW_SOME SMALLINT = 154;
    DECLARE @KW_STATISTICS SMALLINT = 155;
    DECLARE @KW_SYSTEM_USER SMALLINT = 156;
    DECLARE @KW_TABLE SMALLINT = 157;
    DECLARE @KW_TABLESAMPLE SMALLINT = 158;
    DECLARE @KW_TEXTSIZE SMALLINT = 159;
    DECLARE @KW_THEN SMALLINT = 160;
    DECLARE @KW_TO SMALLINT = 161;
    DECLARE @KW_TOP SMALLINT = 162;
    DECLARE @KW_TRAN SMALLINT = 163;
    DECLARE @KW_TRANSACTION SMALLINT = 164;
    DECLARE @KW_TRIGGER SMALLINT = 165;
    DECLARE @KW_TRUNCATE SMALLINT = 166;
    DECLARE @KW_TRY_CONVERT SMALLINT = 167;
    DECLARE @KW_TSEQUAL SMALLINT = 168;
    DECLARE @KW_UNION SMALLINT = 169;
    DECLARE @KW_UNIQUE SMALLINT = 170;
    DECLARE @KW_UNPIVOT SMALLINT = 171;
    DECLARE @KW_UPDATE SMALLINT = 172;
    DECLARE @KW_UPDATETEXT SMALLINT = 173;
    DECLARE @KW_USE SMALLINT = 174;
    DECLARE @KW_USER SMALLINT = 175;
    DECLARE @KW_VALUES SMALLINT = 176;
    DECLARE @KW_VARYING SMALLINT = 177;
    DECLARE @KW_VIEW SMALLINT = 178;
    DECLARE @KW_WAITFOR SMALLINT = 179;
    DECLARE @KW_WHEN SMALLINT = 180;
    DECLARE @KW_WHERE SMALLINT = 181;
    DECLARE @KW_WHILE SMALLINT = 182;
    DECLARE @KW_WITH SMALLINT = 183;
    DECLARE @KW_WITHIN SMALLINT = 184;
    DECLARE @KW_WRITETEXT SMALLINT = 185;
    DECLARE @KW_ATOMIC SMALLINT = 186;
    DECLARE @KW_CONVERSATION SMALLINT = 187;
    DECLARE @KW_DIALOG SMALLINT = 188;
    DECLARE @KW_CATCH SMALLINT = 189;
    DECLARE @KW_TRY SMALLINT = 190;
    DECLARE @KW_THROW SMALLINT = 191;
    DECLARE @KW_FILETABLE SMALLINT = 192;
    DECLARE @KW_OUTPUT SMALLINT = 193;
    DECLARE @KW_LOGIN SMALLINT = 194;
    DECLARE @KW_AT SMALLINT = 195;
    DECLARE @KW_DATA_SOURCE SMALLINT = 196;
    DECLARE @KW_RECOMPILE SMALLINT = 197;
    DECLARE @KW_RESULT SMALLINT = 198;
    DECLARE @KW_SETS SMALLINT = 199;
    DECLARE @KW_UNDEFINED SMALLINT = 200;
    DECLARE @KW_NONE SMALLINT = 201;
    DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;

    DECLARE @TT_NONE TINYINT = 0;
    DECLARE @TT_WHITESPACE TINYINT = 1;
    DECLARE @TT_COMMENT TINYINT = 2;
    DECLARE @TT_IDENTIFIER TINYINT = 3;
    DECLARE @TT_KEYWORD TINYINT = 4;
    DECLARE @TT_DELIMITER TINYINT = 5;
    DECLARE @TT_SEPARATOR TINYINT = 6;
    DECLARE @TT_OPERATOR TINYINT = 7;
    DECLARE @TT_LITERAL TINYINT = 8;
    DECLARE @TT_UNKNOWN TINYINT = 255;

    DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
    DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
    DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
    DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
    DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
    DECLARE @TST_STRING TINYINT = 6;
    DECLARE @TST_UNICODE_STRING TINYINT = 7;
    DECLARE @TST_INTEGER TINYINT = 8;
    DECLARE @TST_DECIMAL TINYINT = 9;
    DECLARE @TST_MONEY TINYINT = 10;
    DECLARE @TST_REAL TINYINT = 11;
    DECLARE @TST_BINARY TINYINT = 12;
    DECLARE @TST_COMMA TINYINT = 13;
    DECLARE @TST_SEMICOLON TINYINT = 14;
    DECLARE @TST_PERIOD TINYINT = 15;
    DECLARE @TST_VARIABLE_NAME TINYINT = 16;
    DECLARE @TST_UNARY_OPERATOR TINYINT = 17;
    DECLARE @TST_BINARY_OPERATOR TINYINT = 18;
    DECLARE @TST_UNARY_OR_BINARY_OPERATOR TINYINT = 19;

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);
    DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
    SELECT @spSchema = [Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	DROP TABLE IF EXISTS #Definition;

    CREATE TABLE #Definition
    (
        [Id] INT NOT NULL IDENTITY(1, 1) PRIMARY KEY,
        [Schema] NVARCHAR(128) NOT NULL,
        [Name] NVARCHAR(128) NOT NULL,
        [Definition] NVARCHAR(MAX) NOT NULL,
        UNIQUE ([Schema], [Name])
    );

    DECLARE @query NVARCHAR(MAX);

    SET @query = N'USE ' + QUOTENAME(@dbName) + N';
    '
    SET @query += N'SELECT SCHEMA_NAME(o.[schema_id]) [Schema], OBJECT_NAME(m.[object_id]) [Name], m.[definition] [Definition]
    FROM sys.all_sql_modules m
    JOIN sys.all_objects o ON m.object_id=o.[object_id]
    WHERE m.object_id=OBJECT_ID(' + QUOTENAME(QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName), '''') + N');
    ';

    INSERT INTO #Definition ([Schema], [Name], [Definition])
    EXEC(@query);

    DECLARE @tsql NVARCHAR(MAX);

    SELECT TOP(1) @tsql=[Definition] FROM #Definition;

    DROP TABLE IF EXISTS #Definition;

    DROP TABLE IF EXISTS #Token, #Statement, #StatementPart;

    CREATE TABLE #Token
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TypeId] TINYINT NOT NULL,
        [KeywordId] SMALLINT NULL,
        [SubTypeId] SMALLINT NULL,
        [OperatorId] TINYINT NULL,
        [Text] NVARCHAR(MAX) NULL,
        [Level] SMALLINT NULL,
        [StartTokenId] INT NULL,
        [EndTokenId] INT NULL,
        [BlockTypeId] TINYINT NULL,
        [SeqStartTokenId] INT NULL,
        [SeqEndTokenId] INT NULL,
        [SeqTypeId] TINYINT NULL,
    
    );

    CREATE TABLE #Statement
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TypeId] SMALLINT NOT NULL, -- [Enum].[TSqlStatementType]
        [StartTokenId] INT NOT NULL,
        [EndTokenId] INT NULL,
        [IsFinished] BIT NOT NULL DEFAULT (0),
        [StatementSeparatorTokenId] INT NULL,
        [ParentStatementId] INT NULL
    );


    CREATE TABLE #StatementPart
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StatementId] INT NOT NULL,
        [TypeId] TINYINT NOT NULL, -- [Enum].[TSqlStatementPart]
        [StartTokenId] INT NOT NULL,
        [EndTokenId] INT NOT NULL
    );

    CREATE TABLE #TempTable
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [Name] NVARCHAR(128) NOT NULL UNIQUE,
        [TvName] NVARCHAR(128) NOT NULL UNIQUE,
        [CreateTokenId] INT NOT NULL,
        [TableTokenId] INT NOT NULL,
        [NameTokenId] INT NOT NULL,
		[EndTokenId] INT NOT NULL,
		[CloseParenTokenId] INT NOT NULL
    );

    DECLARE	@returnValue int,
        @spErrorMessage nvarchar(4000);

    EXEC @returnValue = [Parser].[TokenizeTSql] @tsql = @tsql, @errorMessage = @spErrorMessage OUTPUT;

    IF @returnValue = @RC_OK
    BEGIN
        EXEC @returnValue = [Parser].[ParseTSql] @errorMessage = @errorMessage OUTPUT;
    END
    IF @returnValue <> @RC_OK
    BEGIN
        SELECT @rc = @RC_ERR_PARSE, @errorMessage=N'Failed to parse the stored procedure';
        RETURN @rc;
    END

    DECLARE @tempSpName NVARCHAR(128) = N'__Temp__' + LEFT(@spName, 64) + N'__' + REPLACE(LOWER(NEWID()), '-', '');

    INSERT INTO #TempTable ([Name], [TvName], [CreateTokenId], [TableTokenId], [NameTokenId], [EndTokenId], [CloseParenTokenId])
    SELECT tkn.[Text], N'@' + [Internal].[GetCaseName](@C_CAMEL_CASE, LEFT(tkn.[Text], 65), NULL) + N'___' + REPLACE(LOWER(NEWID()), '-', ''), tkc.[Id], tkt.[Id], tkn.[Id],
		st.[EndTokenId], tkcp.[Id]
    FROM #Statement st    
    JOIN #StatementPart stp ON stp.[StatementId]=st.[Id] AND stp.[TypeId]=@SP_IDENTIFIER AND stp.[StartTokenId]=stp.[EndTokenId]
    JOIN #Token tkn ON tkn.[Id]=stp.[StartTokenId]
    JOIN #Token tkc ON tkc.[Id] >= st.[StartTokenId] AND tkc.[Id] <= st.[EndTokenId] AND tkc.[TypeId]=@TT_KEYWORD AND tkc.[KeywordId]=@KW_CREATE
    JOIN #Token tkt ON tkt.[Id] >= st.[StartTokenId] AND tkt.[Id] <= st.[EndTokenId] AND tkt.[TypeId]=@TT_KEYWORD AND tkt.[KeywordId]=@KW_TABLE AND tkt.[Id] > tkc.[Id]
	JOIN #Token tkcp ON tkcp.[Id] >= st.[StartTokenId] AND tkcp.[Id] <= st.[EndTokenId] AND tkcp.[Text] = ')' AND tkcp.[TypeId]=@TT_DELIMITER AND tkcp.[Id] > tkt.[Id]
	
	LEFT JOIN #Token xtkc ON xtkc.[Id] >= st.[StartTokenId] AND xtkc.[Id] <= st.[EndTokenId] AND xtkc.[TypeId]=@TT_KEYWORD AND xtkc.[KeywordId]=@KW_CREATE AND xtkc.[Id] < tkc.[Id]
    LEFT JOIN #Token xtkt ON xtkt.[Id] >= st.[StartTokenId] AND xtkt.[Id] <= st.[EndTokenId] AND xtkt.[TypeId]=@TT_KEYWORD AND xtkt.[KeywordId]=@KW_TABLE AND xtkt.[Id] < tkt.[Id]
	LEFT JOIN #Token xtkcp ON xtkcp.[Id] >= st.[StartTokenId] AND xtkcp.[Id] <= st.[EndTokenId] AND xtkcp.[Text] = ')' AND xtkcp.[TypeId]=@TT_DELIMITER AND xtkcp.[Id] > tkcp.[Id]

	WHERE st.[TypeId]=@ST_CREATE_TABLE AND tkn.[Text] LIKE N'#[^#]%' AND xtkc.[Id] IS NULL AND xtkt.[Id] IS NULL AND xtkcp.[Id] IS NULL;
    
    -- SELECT * 
	-- FROM #TempTable;

    -- change SP name
    WITH cte AS
    (
        SELECT TOP(1) st.[Id], sp.[StartTokenId], sp.[EndTokenId]
        FROM #Statement st
        JOIN #StatementPart sp ON sp.[StatementId]=st.[Id] AND sp.[TypeId]=@SP_IDENTIFIER
        WHERE st.[TypeId]=@ST_CREATE_PROCEDURE
        ORDER BY st.[Id]
    )
    UPDATE tk
    SET tk.[Text]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @tempSpName ELSE N'' END,
        tk.[TypeId]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @TT_IDENTIFIER ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE WHEN tk.[Id]=cte.[StartTokenId] THEN @TST_REGULAR_IDENTIFIER ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id] BETWEEN cte.[StartTokenId] AND cte.[EndTokenId];



    -- remove comments
    UPDATE #Token
    SET [TypeId]=@TT_WHITESPACE, [Text]=CASE WHEN [SubTypeId]=@TST_SINGLE_LINE_COMMENT THEN N'' ELSE N' ' END, [SubTypeId]=NULL
    WHERE [TypeId]=@TT_COMMENT;

    -- remove DROP TABLE ...
    UPDATE tk
    SET [Text]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId] IN (@KW_DROP, @KW_TABLE) THEN CASE WHEN tk.[KeywordId]=@KW_DROP THEN N'PRINT' ELSE N'DROP TABLE removed...' END ELSE N' ' END,
        [SubTypeId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId]=@KW_TABLE THEN @TST_STRING ELSE NULL END,
        [TypeId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId] IN (@KW_DROP, @KW_TABLE) THEN CASE WHEN tk.[KeywordId]=@KW_DROP THEN @TT_KEYWORD ELSE @TT_LITERAL END ELSE @TT_WHITESPACE END,
        [KeywordId]=CASE WHEN tk.[TypeId]=@TT_KEYWORD AND tk.[KeywordId]=@KW_DROP THEN @KW_PRINT ELSE NULL END        
    FROM #Statement st
    JOIN #Token tk ON tk.[Id] BETWEEN st.[StartTokenId] AND st.[EndTokenId]
    WHERE st.TypeId=@ST_DROP_TABLE;

	--SELECT * 
	--FROM #Token;

	--SELECT *
	--FROM #Statement;

    -- remove INSERT... EXEC
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY sti.[Id] ORDER BY tk.[Id]) [RowNum], sti.[Id] [StatementId], tk.[Id] [TokenId]
        FROM #Statement sti
        JOIN #Statement ste ON ste.[ParentStatementId]=sti.[Id] AND ste.[TypeId]=@ST_EXEC
        JOIN #Token tk ON tk.[Id] BETWEEN sti.[StartTokenId] AND ste.[EndTokenId]
        WHERE sti.[TypeId]=@ST_INSERT AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD  WHEN 2 THEN @TT_LITERAL ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 2 THEN @TST_STRING ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'PRINT' WHEN 2 THEN N'INSERT... EXEC removed...' ELSE N'' END,
        tk.[KeywordId]=CASE WHEN cte.[RowNum]=1 THEN @KW_PRINT ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- remove EXEC
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY ste.[Id] ORDER BY tk.[Id]) [RowNum], ste.[Id] [StatementId], tk.[Id] [TokenId]
        FROM #Statement ste
        JOIN #Token tk ON tk.[Id] BETWEEN ste.[StartTokenId] AND ste.[EndTokenId]
        WHERE ste.[TypeId]=@ST_EXEC AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD  WHEN 2 THEN @TT_LITERAL ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 2 THEN @TST_STRING ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'PRINT' WHEN 2 THEN N'EXEC removed...' ELSE N'' END,
        tk.[KeywordId]=CASE WHEN cte.[RowNum]=1 THEN @KW_PRINT ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- replace TRUNCATE TABLE #... with DELETE FROM @...
    WITH cte AS
    (
        SELECT ROW_NUMBER() OVER (PARTITION BY st.[Id] ORDER BY tk.[Id]) [RowNum], st.[Id] [StatementId], tk.[Id] [TokenId], tt.[Name] [TableName], tt.[TvName]
        FROM #Statement st
        JOIN #StatementPart stp ON stp.[StatementId]=st.[Id] AND stp.[TypeId]=@SP_IDENTIFIER AND stp.[StartTokenId]=stp.[EndTokenId]
        JOIN #Token ntk ON ntk.[Id]=stp.[StartTokenId]
        JOIN #TempTable tt ON tt.[Name]=ntk.[Text]
        JOIN #Token tk ON tk.[Id] BETWEEN st.[StartTokenId] AND st.[EndTokenId]
        WHERE st.[TypeId]=@ST_TRUNCATE_TABLE AND tk.[TypeId]<>@TT_WHITESPACE
    )
    UPDATE tk
    SET tk.[TypeId]=CASE cte.[RowNum] WHEN 1 THEN @TT_KEYWORD WHEN 2 THEN @TT_KEYWORD WHEN 3 THEN @TT_IDENTIFIER ELSE @TT_WHITESPACE END,
        tk.[SubTypeId]=CASE cte.[RowNum] WHEN 3 THEN @TST_VARIABLE_NAME ELSE NULL END, 
        tk.[Text] = CASE cte.[RowNum] WHEN 1 THEN N'DELETE' WHEN 2 THEN N'FROM' WHEN 3 THEN cte.[TvName] ELSE N'' END,
        tk.[KeywordId]=CASE cte.[RowNum] WHEN 1 THEN @KW_DELETE WHEN 2 THEN @KW_FROM ELSE NULL END
    FROM cte
    JOIN #Token tk ON tk.[Id]=cte.[TokenId];

    -- replace CREATE TABLE #... with DECLARE @... TABLE

    UPDATE tk
    SET tk.[KeywordId]=@KW_DECLARE, tk.[Text]=N'DECLARE'
    FROM #TempTable tt
    JOIN #Token tk ON tt.[CreateTokenId]=tk.[Id];

    UPDATE tk
    SET tk.[TypeId]=@TT_IDENTIFIER, tk.[SubTypeId]=@TST_VARIABLE_NAME, tk.[KeywordId]=NULL, tk.[Text]=tt.[TvName]
    FROM #TempTable tt
    JOIN #Token tk ON tt.[TableTokenId]=tk.[Id];

    UPDATE tk
    SET tk.[TypeId]=@TT_KEYWORD, tk.[SubTypeId]=NULL, tk.[KeywordId]=@KW_TABLE, tk.[Text]=N'TABLE'
    FROM #TempTable tt
    JOIN #Token tk ON tt.[NameTokenId]=tk.[Id];


	-- Remove trailing comma before closing parenthesis in DECLARE @... TABLE
	UPDATE tk
	SET tk.[TypeId]=@TT_COMMENT, tk.[SubTypeId]=@TST_MULTI_LINE_COMMENT, tk.[Text]='/* comma removed */'
	FROM #TempTable tt
	JOIN #Token tk ON tk.[Text] = ',' AND tk.[TypeId]=@TT_SEPARATOR AND tk.[Id] < tt.[CloseParenTokenId] AND tk.[Id] > tt.[NameTokenId]
	LEFT JOIN #Token xtk ON xtk.[TypeId]<>@TT_WHITESPACE AND xtk.[Id] > tk.[Id] AND xtk.[Id] < tt.[CloseParenTokenId]
	WHERE xtk.[Id] IS NULL;

    -- replace #... with @... in all identifiers

    UPDATE tk
    SET tk.[Text]=tt.[TvName], tk.[SubTypeId]=@TST_VARIABLE_NAME
    FROM #TempTable tt
    JOIN #Token tk ON tt.[Name]=tk.[Text]
    WHERE tk.[TypeId]=@TT_IDENTIFIER;


    SELECT @tsql=STRING_AGG([Parser].[GetFullText]([Text], [SubTypeId]), N'') WITHIN GROUP (ORDER BY [Id])
    FROM #Token;

    

    --PRINT N'---------------------------------'
    --SELECT @tsql;
    --PRINT N'---------------------------------'

    SET @query = N'USE ' + QUOTENAME(@dbName) + N';    
    '
    SET @query += N'EXEC(N''' + REPLACE(@tsql, '''', '''''') + N''');
    ';
    SET @query += N'SELECT frs.[is_hidden], frs.[column_ordinal], frs.[name], frs.[is_nullable], frs.[system_type_id], frs.[system_type_name], frs.[max_length], frs.[precision], frs.[scale], 
        frs.[collation_name], frs.[user_type_id], frs.[user_type_database], frs.[user_type_schema], frs.[user_type_name], frs.[assembly_qualified_type_name], frs.[xml_collection_id], 
        frs.[xml_collection_database], frs.[xml_collection_schema], frs.[xml_collection_name], frs.[is_xml_document], frs.[is_case_sensitive], frs.[is_fixed_length_clr_type], 
        frs.[source_server], frs.[source_database], frs.[source_schema], frs.[source_table], frs.[source_column], frs.[is_identity_column], frs.[is_part_of_unique_key], 
        frs.[is_updateable], frs.[is_computed_column], frs.[is_sparse_column_set], frs.[ordinal_in_order_by_list], frs.[order_by_is_descending], frs.[order_by_list_length], 
        frs.[error_number], frs.[error_severity], frs.[error_state], frs.[error_message], frs.[error_type], frs.[error_type_desc]
    FROM sys.dm_exec_describe_first_result_set(''' + @tempSpName + N''', NULL, 1) frs;    
    '

    SET @query += N'DROP PROCEDURE ' + @tempSpName + N';    
    ';

    --SELECT @query;

    TRUNCATE TABLE #SingleStoredProcResultSet;

    INSERT INTO #SingleStoredProcResultSet 
    ([is_hidden], [column_ordinal], [name], [is_nullable], [system_type_id], [system_type_name], [max_length], [precision], [scale], [collation_name], [user_type_id], 
     [user_type_database], [user_type_schema], [user_type_name], [assembly_qualified_type_name], [xml_collection_id], [xml_collection_database], [xml_collection_schema], 
     [xml_collection_name], [is_xml_document], [is_case_sensitive], [is_fixed_length_clr_type], [source_server], [source_database], [source_schema], [source_table], 
     [source_column], [is_identity_column], [is_part_of_unique_key], [is_updateable], [is_computed_column], [is_sparse_column_set], [ordinal_in_order_by_list], 
     [order_by_is_descending], [order_by_list_length], [error_number], [error_severity], [error_state], [error_message], [error_type], [error_type_desc])
    EXEC(@query);

    --PRINT('All OK?')
    --SELECT * FROM #SingleStoredProcResultSet;

    DROP TABLE IF EXISTS #Token, #Statement, #StatementPart;
    RETURN @RC_OK;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Internal].[GetStoredProcResultSet]...';


GO



ALTER PROCEDURE [Internal].[GetStoredProcResultSet]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

    DECLARE @DFRS_ERR_MISC INT = 1;
    DECLARE @DFRS_ERR_SYNTAX INT = 2;
    DECLARE @DFRS_ERR_CONFLICTING_RESULTS INT = 3;
    DECLARE @DFRS_ERR_DYNAMIC_SQL INT = 4;
    DECLARE @DFRS_ERR_CLR_PROCEDURE INT = 5;
    DECLARE @DFRS_ERR_CLR_TRIGGER INT = 6;
    DECLARE @DFRS_ERR_EXTENDED_PROCEDURE INT = 7;
    DECLARE @DFRS_ERR_UNDECLARED_PARAMETER INT = 8;
    DECLARE @DFRS_ERR_RECURSION INT = 9;
    DECLARE @DFRS_ERR_TEMPORARY_TABLE INT = 10;
    DECLARE @DFRS_ERR_UNSUPPORTED_STATEMENT INT = 11;
    DECLARE @DFRS_ERR_OBJECT_TYPE_NOT_SUPPORTED INT = 12;
    DECLARE @DFRS_ERR_OBJECT_DOES_NOT_EXIST INT = 13;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	
	DECLARE @mapEnums TINYINT;

	SELECT @mapEnums=[MapResultSetEnums]
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @mapEnums IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @spSchema = [Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	IF @spSchema IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @tsql NVARCHAR(4000);

    TRUNCATE TABLE #SingleStoredProcResultSet;
	

	SET @tsql = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @tsql += N'EXEC ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName)
	
	--PRINT(@tsql);
	
	INSERT INTO #SingleStoredProcResultSet 
    ([is_hidden], [column_ordinal], [name], [is_nullable], [system_type_id], [system_type_name], [max_length], [precision], [scale], [collation_name], [user_type_id], 
     [user_type_database], [user_type_schema], [user_type_name], [assembly_qualified_type_name], [xml_collection_id], [xml_collection_database], [xml_collection_schema], 
     [xml_collection_name], [is_xml_document], [is_case_sensitive], [is_fixed_length_clr_type], [source_server], [source_database], [source_schema], [source_table], 
     [source_column], [is_identity_column], [is_part_of_unique_key], [is_updateable], [is_computed_column], [is_sparse_column_set], [ordinal_in_order_by_list], 
     [order_by_is_descending], [order_by_list_length], [error_number], [error_severity], [error_state], [error_message], [error_type], [error_type_desc])
    SELECT frs.[is_hidden], frs.[column_ordinal], frs.[name], frs.[is_nullable], frs.[system_type_id], frs.[system_type_name], frs.[max_length], frs.[precision], frs.[scale], 
        frs.[collation_name], frs.[user_type_id], frs.[user_type_database], frs.[user_type_schema], frs.[user_type_name], frs.[assembly_qualified_type_name], frs.[xml_collection_id], 
        frs.[xml_collection_database], frs.[xml_collection_schema], frs.[xml_collection_name], frs.[is_xml_document], frs.[is_case_sensitive], frs.[is_fixed_length_clr_type], 
        frs.[source_server], frs.[source_database], frs.[source_schema], frs.[source_table], frs.[source_column], frs.[is_identity_column], frs.[is_part_of_unique_key], 
        frs.[is_updateable], frs.[is_computed_column], frs.[is_sparse_column_set], frs.[ordinal_in_order_by_list], frs.[order_by_is_descending], frs.[order_by_list_length], 
        frs.[error_number], frs.[error_severity], frs.[error_state], frs.[error_message], frs.[error_type], frs.[error_type_desc]
    FROM sys.dm_exec_describe_first_result_set(@tsql, NULL, 1) frs;

    DECLARE @frsErrorNumber INT;
    DECLARE @frsErrorSeverity INT;
    DECLARE @frsErrorState INT;
    DECLARE @frsErrorMessage NVARCHAR(MAX);
    DECLARE @frsErrorType INT;
    DECLARE @frsErrorTypeDesc NVARCHAR(60);

    DECLARE	@returnValue int,
        @spErrorMessage nvarchar(4000);
    
    SELECT @frsErrorNumber=frs.[error_number], @frsErrorSeverity=frs.[error_severity], @frsErrorState=frs.[error_state], @frsErrorMessage=frs.[error_message], 
        @frsErrorType=frs.[error_type], @frsErrorTypeDesc=frs.[error_type_desc]
    FROM #SingleStoredProcResultSet frs;

    IF @frsErrorType IS NOT NULL AND @frsErrorType IN (@DFRS_ERR_TEMPORARY_TABLE, @DFRS_ERR_DYNAMIC_SQL, @DFRS_ERR_RECURSION, @DFRS_ERR_EXTENDED_PROCEDURE)
    BEGIN
        PRINT(N'SP: ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName));
        PRINT(N'Cannot determine result set');
        PRINT(N'sys.dm_exec_describe_first_result_set returned error #' + LOWER(@frsErrorType)+ N': ' + ISNULL(@frsErrorTypeDesc, N'<NULL>'));
        PRINT(N'Trying to get result set from a modified temporary copy of the stored procedure');
        
        EXEC @returnValue = [Parser].[TryDescribeFirstResultSetWorkaround] @projectId, @dbId,	@langId, @spId, @errorMessage = @spErrorMessage OUTPUT;
        IF @returnValue<>@RC_OK
        BEGIN
            PRINT(N'Workaround failed: ' + LOWER(@returnValue) +': ' +ISNULL(@spErrorMessage, '<NULL>'));
            SELECT * FROM #SingleStoredProcResultSet;
        END
        ELSE
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM #SingleStoredProcResultSet)
            BEGIN
                SELECT @frsErrorNumber=NULL, @frsErrorSeverity=NULL, @frsErrorState=NULL, @frsErrorMessage=NULL, @frsErrorMessage=NULL, @frsErrorType=NULL, @frsErrorTypeDesc=NULL;
            END
            ELSE
            BEGIN
                SELECT @frsErrorNumber=frs.[error_number], @frsErrorSeverity=frs.[error_severity], @frsErrorState=frs.[error_state], @frsErrorMessage=frs.[error_message], 
                    @frsErrorType=frs.[error_type], @frsErrorTypeDesc=frs.[error_type_desc]
                FROM #SingleStoredProcResultSet frs;
            END
        END
    END

    IF @frsErrorType IS NOT NULL
    BEGIN
        PRINT(N'SP: ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName));
        PRINT(N'Cannot determine result set');
        PRINT(N'sys.dm_exec_describe_first_result_set returned error #' + LOWER(@frsErrorType)+ N': ' + ISNULL(@frsErrorTypeDesc, N'<NULL>'));
        PRINT(N'ErrorNumber: ' + ISNULL(LOWER(@frsErrorNumber), N'<NULL>') + N'; ErrorSeverity: ' + ISNULL(LOWER(@frsErrorSeverity), N'<NULL>') 
            + N'; ErrorState: ' + ISNULL(LOWER(@frsErrorState), N'<NULL>') + + N'; ErrorMessage: ' + ISNULL(LOWER(@frsErrorMessage), N'<NULL>'));  
        UPDATE #StoredProc
        SET [HasUnknownResultSet]=1
        WHERE [Id]=@spId;
    END
    ELSE
    BEGIN
	    /*
	     * Join is with local sys.types view, so we can only use system types, not user defined types.	 
	     */

		--SELECT * FROM #SingleStoredProcResultSet;
	
	    INSERT INTO #StoredProcResultSet
	    ([StoredProcId], [ColumnOrdinal], [Name], [IsNullable], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [EnumId])
	    SELECT @spId, rs.[column_ordinal], rs.[name], rs.[is_nullable], st.[name], SCHEMA_NAME(st.[schema_id]), rs.[max_length], rs.[precision], rs.[scale], ISNULL(e.[EnumId], ee.[Id])
	    FROM #SingleStoredProcResultSet rs
	    JOIN sys.types st ON st.[system_type_id]=rs.[system_type_id] AND st.[user_type_id]=rs.[system_type_id]
	    LEFT JOIN #EnumForeignKey e 
	    ON @mapEnums=1 AND rs.[source_server] IS NULL AND rs.[source_database]=@dbName AND rs.[source_schema]=e.[ForeignSchema] AND rs.[source_table]=e.[ForeignTable] AND rs.[source_column]=e.[ForeignColumn]
		LEFT JOIN #Enum ee
		ON @mapEnums=1 AND rs.[source_server] IS NULL AND rs.[source_database]=@dbName AND rs.[source_schema]=ee.[Schema] AND rs.[source_table]=ee.[Table] AND rs.[source_column]=ee.[ValueColumn]
	    WHERE rs.[is_hidden]=0
	    ORDER BY rs.[column_ordinal];
	END    
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Internal].[GenerateCode]...';


GO
CREATE PROCEDURE [Internal].[GenerateCode]
    @projectId NVARCHAR(200),
	@dbId SMALLINT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
	DECLARE @RC_DB_ERROR INT = 1;
	DECLARE @RC_INTERNAL_ERROR INT = 2;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 3;
    
    SELECT @rc = @RC_OK, @errorMessage = NULL;

	DECLARE @errorCode VARCHAR(100) = 'InternalError';

    DECLARE @OPT_GEN_ENUMS SMALLINT = 1;
    DECLARE @OPT_GEN_RESULT_TYPES SMALLINT = 2;
    DECLARE @OPT_GEN_TVP_TYPES SMALLINT = 4;
    DECLARE @OPT_GEN_SP_WRAPPERS SMALLINT = 8;

    DECLARE @C_PASCAL_CASE TINYINT = 1;
    DECLARE @C_CAMEL_CASE TINYINT = 2;
    DECLARE @C_SNAKE_CASE TINYINT = 3;
    DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
    DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

    DECLARE @NT_CLASS TINYINT = 1;
    DECLARE @NT_METHOD TINYINT = 2;
    DECLARE @NT_PROPERTY TINYINT = 3;
    DECLARE @NT_FIELD TINYINT = 4;
    DECLARE @NT_PARAMETER TINYINT = 5;
    DECLARE @NT_LOCAL_VARIABLE TINYINT = 6;
    DECLARE @NT_TUPLE_FIELD TINYINT = 7;
    DECLARE @NT_ENUM TINYINT = 8;
    DECLARE @NT_ENUM_MEMBER TINYINT = 9;

	DECLARE @NS_TABLE_NAME TINYINT = 1;
	DECLARE @NS_STORED_PROC_NAME TINYINT = 2;
	DECLARE @NS_TABLE_TYPE_NAME TINYINT = 3;

    DECLARE @langId TINYINT;
    
	SELECT @langId=[LanguageId]  FROM [dbo].[Project] WHERE [Id]=@projectId;

    IF @langId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(LOWER(@projectId), '<NULL>');
        RETURN @rc;
    END;

    IF @dbId IS NULL 
    BEGIN
		SET @errorCode='InvalidDatabase';
		SELECT @rc=[Id], @errorMessage='Unknown database: ' + ISNULL(LOWER(@dbId), '<NULL>')
		FROM [Enum].[ToolkitResponseCode]
		WHERE [Name]=@errorCode;
        RETURN @rc;
    END;

    DROP TABLE IF EXISTS #Enum;
    CREATE TABLE #Enum
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [Schema] NVARCHAR(128) NOT NULL,
        [Table] NVARCHAR(128) NOT NULL,        
        [NameColumn] NVARCHAR(128) NOT NULL,
        [ValueColumn] NVARCHAR(128) NOT NULL,
        [EnumName] NVARCHAR(200) NULL,
        [ValueType] NVARCHAR(128) NOT NULL,
        [IsSetOfFlags] BIT NOT NULL DEFAULT (0),
        UNIQUE ([Schema], [Table])
    );

    DROP TABLE IF EXISTS #EnumVal;
    CREATE TABLE #EnumVal
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [EnumId] INT NOT NULL,        
        [Name] VARCHAR(200) NOT NULL,
        [Value] BIGINT NOT NULL,     
		[TempName] VARCHAR(200) NULL,
        UNIQUE ([EnumId], [Name]),
        UNIQUE ([EnumId], [Value]),
		UNIQUE ([EnumId], [TempName], [Value])
    );

    DROP TABLE IF EXISTS #EnumForeignKey;
    CREATE TABLE #EnumForeignKey
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,        
        [EnumId] INT NOT NULL,
        [ForeignSchema] NVARCHAR(128) NOT NULL,
        [ForeignTable] NVARCHAR(128) NOT NULL,
        [ForeignColumn] NVARCHAR(128) NOT NULL,        
        UNIQUE ([EnumId], [ForeignSchema], [ForeignTable], [ForeignColumn]),
        UNIQUE ([ForeignSchema], [ForeignTable], [ForeignColumn])        
    );

    DROP TABLE IF EXISTS #StoredProc;
    CREATE TABLE #StoredProc 
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [Schema] NVARCHAR(128) NOT NULL, 
        [Name] NVARCHAR(128) NOT NULL,
        [WrapperName] NVARCHAR(200) NULL,
        [HasResultSet] BIT NOT NULL DEFAULT (0),
        [HasUnknownResultSet] BIT NOT NULL DEFAULT (0),
        [ResultType] NVARCHAR(200) NOT NULL DEFAULT(N'int'),
        [LanguageOptionsReset] BIGINT NULL,
        [LanguageOptionsSet] BIGINT NULL,
        UNIQUE ([Schema], [Name])
    );

    DROP TABLE IF EXISTS #StoredProcParam;
    CREATE TABLE #StoredProcParam
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL,
        [ParamId] INT NOT NULL, 
        [Name] NVARCHAR(128) NOT NULL, 
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL, 
        [IsOutput] BIT NOT NULL, 
        [IsReadOnly] BIT NOT NULL, 
        [IsTypeUserDefined] BIT NOT NULL, 
        [IsTableType] BIT NOT NULL,
        [EnumId] INT NULL,
        [ParamName]  NVARCHAR(200) NULL,
        UNIQUE ([StoredProcId], [ParamId]),
        UNIQUE ([StoredProcId], [Name])
    );

    DROP TABLE IF EXISTS #SingleStoredProcResultSet;
    CREATE TABLE #SingleStoredProcResultSet (
        [is_hidden] BIT NULL,
        [column_ordinal] INT NULL,
        [name] SYSNAME NULL,
        [is_nullable] BIT NULL,
        [system_type_id] INT NULL,
        [system_type_name] NVARCHAR(256) NULL,
        [max_length] SMALLINT NULL,
        [precision] TINYINT NULL,
        [scale] TINYINT NULL,
        [collation_name] SYSNAME NULL,
        [user_type_id] INT NULL,
        [user_type_database] SYSNAME NULL,
        [user_type_schema] SYSNAME NULL,
        [user_type_name] SYSNAME NULL,
        [assembly_qualified_type_name] NVARCHAR(4000),
        [xml_collection_id] INT NULL,
        [xml_collection_database] SYSNAME NULL,
        [xml_collection_schema] SYSNAME NULL,
        [xml_collection_name] SYSNAME NULL,
        [is_xml_document] BIT NULL,
        [is_case_sensitive] BIT NULL,
        [is_fixed_length_clr_type] BIT NULL,
        [source_server] SYSNAME NULL,
        [source_database] SYSNAME NULL,
        [source_schema] SYSNAME NULL,
        [source_table] SYSNAME NULL,
        [source_column] SYSNAME NULL,
        [is_identity_column] BIT NULL,
        [is_part_of_unique_key] BIT NULL,
        [is_updateable] BIT NULL,
        [is_computed_column] BIT NULL,
        [is_sparse_column_set] BIT NULL,
        [ordinal_in_order_by_list] SMALLINT NULL,
        [order_by_list_length] SMALLINT NULL,
        [order_by_is_descending] SMALLINT NULL,
        /*
        [tds_type_id] INT NOT NULL,
        [tds_length] INT NOT NULL,
        [tds_collation_id] INT NULL,
        [tds_collation_sort_id] TINYINT NULL
        */
        [error_number] INT NULL,
        [error_severity] INT NULL,
        [error_state] INT NULL,
        [error_message] NVARCHAR(MAX) NULL,
        [error_type] INT NULL,
        [error_type_desc] NVARCHAR(60) NULL
    );

    DROP TABLE IF EXISTS #StoredProcResultSet;
    CREATE TABLE #StoredProcResultSet (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL,
        [ColumnOrdinal] INT NOT NULL,
        [Name] SYSNAME NULL,
        [IsNullable] BIT NOT NULL,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL,
        [EnumId] INT NULL,
		[PropertyName] NVARCHAR(200) NULL,
        UNIQUE ([StoredProcId], [ColumnOrdinal]),		
        UNIQUE ([StoredProcId], [PropertyName], [ColumnOrdinal])
    );

    DROP TABLE IF EXISTS #StoredProcResultType;
    CREATE TABLE #StoredProcResultType
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [StoredProcId] INT NOT NULL UNIQUE,
        [Name] NVARCHAR(200) NOT NULL UNIQUE
    );

    DROP TABLE IF EXISTS #TableType;
    CREATE TABLE #TableType
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL,
        [Name] NVARCHAR(200) NOT NULL UNIQUE,
        UNIQUE ([SqlType], [SqlTypeSchema])
    );

    DROP TABLE IF EXISTS #TableTypeColumn;
    CREATE TABLE #TableTypeColumn
    (
        [Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
        [TableTypeId] INT NOT NULL,
        [ColumnId] INT NOT NULL,
        [ColumnNumber] INT NOT NULL,
        [Name] SYSNAME NULL,
        [IsNullable] BIT NOT NULL,
        [SqlType] NVARCHAR(128) NOT NULL, 
        [SqlTypeSchema] NVARCHAR(128) NOT NULL, 
        [MaxLen] SMALLINT NOT NULL, 
        [Precision] TINYINT NOT NULL, 
        [Scale] TINYINT NOT NULL,
        [IsIdentity] BIT NOT NULL,
        [EnumId] INT NULL,
        [PropertyName] NVARCHAR(200) NULL
    );

    DECLARE    @retVal int;
    
    
    EXEC @retVal = [Internal].[GetEnums] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END
	DECLARE @hasDuplicates BIT = 0;
	DECLARE @dupNo INT = 1;

    UPDATE #Enum SET [EnumName]=[Internal].[GetNameEx](@projectId, @NT_ENUM, @NS_TABLE_NAME, [Table], [Schema]);
	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #Enum e1 JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]>e2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE e2
		SET e2.[EnumName] = [Internal].[GetName](@projectId, @NT_ENUM, e2.[EnumName] + LOWER(@dupNo), NULL)
		FROM #Enum e1 
		JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]<e2.[Id]
		LEFT JOIN #Enum ex ON e1.[EnumName]=ex.[EnumName] AND e1.[Id]>ex.[Id]
		WHERE ex.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #Enum e1 JOIN #Enum e2 ON e1.[EnumName]=e2.[EnumName] AND e1.[Id]>e2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    DECLARE @id INT = (SELECT MIN([Id]) FROM #Enum);
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetEnumValues] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END

        EXEC @retVal = [Internal].[GetEnumForeignKeys] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        

        SELECT @id = MIN([Id]) FROM #Enum WHERE [Id]>@id;
    END


	UPDATE #EnumVal SET [TempName]=[Internal].[GetName](@projectId, @NT_ENUM_MEMBER, [Name], NULL);
	
	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #EnumVal v1 JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]>v2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE v2
		SET v2.[TempName] = [Internal].[GetName](@projectId, @NT_ENUM_MEMBER, v2.[TempName] + LOWER(@dupNo), NULL)
		FROM #EnumVal v1 
		JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]<v2.[Id]
		LEFT JOIN #EnumVal vx ON v1.[EnumId]=vx.[EnumId] AND v1.[TempName]=vx.[TempName] AND v1.[Id]>vx.[Id]
		WHERE vx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #EnumVal v1 JOIN #EnumVal v2 ON v1.[EnumId]=v2.[EnumId] AND v1.[TempName]=v2.[TempName] AND v1.[Id]>v2.[Id]) THEN 1 ELSE 0 END;		
		SET @dupNo += 1;
	END

	UPDATE #EnumVal SET [Name]=[TempName];

    /*
    SELECT e.[Schema], e.[Table], e.[EnumName], fk.*
    FROM #Enum e
    JOIN #EnumForeignKey fk ON fk.[EnumId]=e.[Id]
    ORDER BY e.[Id], fk.[Id];
    */

    EXEC @retVal = [Internal].[GetStoredProcedures] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

    SELECT @id=MIN([Id]) FROM #StoredProc;
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetStoredProcParams] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        
        EXEC @retVal = [Internal].[GetStoredProcResultSet] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END

        SELECT @id = MIN([Id]) FROM #StoredProc WHERE [Id]>@id;
    END

    UPDATE #StoredProc SET [WrapperName]=[Internal].[GetNameEx](@projectId, @NT_METHOD, @NS_STORED_PROC_NAME, [Name], [Schema]);

	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #StoredProc p1 JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE p2
		SET p2.[WrapperName] = [Internal].[GetName](@projectId, @NT_METHOD, p2.[WrapperName] + LOWER(@dupNo), NULL)
		FROM #StoredProc p1 
		JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]
		LEFT JOIN #StoredProc px ON p1.[WrapperName]=px.[WrapperName] AND p1.[Id]>px.[Id]
		WHERE px.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #StoredProc p1 JOIN #StoredProc p2 ON p1.[WrapperName]=p2.[WrapperName] AND p1.[Id]<p2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END


    UPDATE sp
    SET sp.[HasResultSet]=1, sp.[ResultType]=[Internal].[GetName](@projectId, @NT_CLASS, sp.[WrapperName] + N'Result', NULL)
    FROM #StoredProc sp
    WHERE EXISTS (SELECT 1 FROM #StoredProcResultSet rs WHERE rs.[StoredProcId]=sp.[Id]);

    UPDATE sp
    SET sp.[HasResultSet]=1, sp.[ResultType]=N'dynamic'
    FROM #StoredProc sp
    WHERE sp.[HasResultSet]=0 AND sp.[HasUnknownResultSet]=1;


	UPDATE rs
	SET rs.[PropertyName]=[Internal].[GetName](@projectId, @NT_PROPERTY, rs.[Name], NULL)
	FROM #StoredProcResultSet rs;

	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #StoredProcResultSet rs1 JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE rs2
		SET rs2.[PropertyName] = [Internal].[GetName](@projectId, @NT_PROPERTY, rs2.[PropertyName] + LOWER(@dupNo), NULL)
		FROM #StoredProcResultSet rs1 
		JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
		LEFT JOIN #StoredProcResultSet rsx ON rs1.[StoredProcId]=rsx.[StoredProcId] AND rs1.[PropertyName]=rsx.[PropertyName] AND rs1.[Id]>rsx.[Id]		
		WHERE rsx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #StoredProcResultSet rs1 JOIN #StoredProcResultSet rs2 ON rs1.[StoredProcId]=rs2.[StoredProcId] AND rs1.[PropertyName]=rs2.[PropertyName] AND rs1.[Id]<rs2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    
    INSERT INTO #StoredProcResultType ([StoredProcId], [Name])
    SELECT [Id], [ResultType]
    FROM #StoredProc
    WHERE [HasResultSet]=1 AND [HasUnknownResultSet]=0;

    UPDATE #StoredProcParam SET [ParamName]=[Internal].[GetName](@projectId, @NT_PARAMETER, [Name], NULL);
	
	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #StoredProcParam p1 JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE p2
		SET p2.[ParamName] = [Internal].[GetName](@projectId, @NT_PARAMETER, p2.[ParamName] + LOWER(@dupNo), NULL)
		FROM #StoredProcParam p1 
		JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
		LEFT JOIN #StoredProcParam px ON p1.[StoredProcId]=px.[StoredProcId] AND p1.[ParamName]=px.[ParamName] AND p1.[Id]>px.[Id]		
		WHERE px.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #StoredProcParam p1 JOIN #StoredProcParam p2 ON p1.[StoredProcId]=p2.[StoredProcId] AND p1.[ParamName]=p2.[ParamName] AND p1.[Id]<p2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END


    INSERT INTO #TableType ([SqlType], [SqlTypeSchema], [Name])
    SELECT DISTINCT spp.[SqlType], spp.[SqlTypeSchema], [Internal].[GetNameEx](@projectId, @NT_CLASS, @NS_TABLE_TYPE_NAME, spp.[SqlType], spp.[SqlTypeSchema])
    FROM #StoredProcParam spp
    WHERE spp.[IsTypeUserDefined]=1 AND spp.IsTableType=1;

	SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #TableType t1 JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE t2
		SET t2.[Name] = [Internal].[GetName](@projectId, @NT_CLASS, t2.[Name] + LOWER(@dupNo), NULL)
		FROM #TableType t1 
		JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]
		LEFT JOIN #TableType tx ON t1.[Name]=tx.[Name] AND t1.[Id]>tx.[Id]
		WHERE tx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (SELECT 1 FROM #TableType t1 JOIN #TableType t2 ON t1.[Name]=t2.[Name] AND t1.[Id]<t2.[Id]) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    SELECT @id=MIN([Id]) FROM #TableType;
    
    WHILE @id IS NOT NULL
    BEGIN
        EXEC @retVal = [Internal].[GetTableTypeColumns] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
        IF @retVal<>0
        BEGIN
            SELECT @rc = @retVal;
            RETURN @rc;
        END
        
        SELECT @id = MIN([Id]) FROM #TableType WHERE [Id]>@id;
    END

    UPDATE #TableTypeColumn
    SET [PropertyName]=[Internal].[GetName](@projectId, @NT_PROPERTY, [Name], NULL);

	SELECT @hasDuplicates = CASE WHEN EXISTS (
		SELECT 1 FROM #TableTypeColumn c1 JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
	) THEN 1 ELSE 0 END;
	SET @dupNo = 1;
	WHILE @hasDuplicates=1 AND @dupNo < 20
	BEGIN
		UPDATE c2
		SET c2.[PropertyName] = [Internal].[GetName](@projectId, @NT_PROPERTY, c2.[PropertyName] + LOWER(@dupNo), NULL)
		FROM #TableTypeColumn c1 
		JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
		LEFT JOIN #TableTypeColumn cx ON c1.[TableTypeId]=cx.[TableTypeId] AND c1.[PropertyName]=cx.[PropertyName] AND c1.[Id]>cx.[Id]		
		WHERE cx.[Id] IS NULL;

		SELECT @hasDuplicates = CASE WHEN EXISTS (
			SELECT 1 FROM #TableTypeColumn c1 JOIN #TableTypeColumn c2 ON c1.[TableTypeId]=c2.[TableTypeId] AND c1.[PropertyName]=c2.[PropertyName] AND c1.[Id]<c2.[Id]
		) THEN 1 ELSE 0 END;
		SET @dupNo += 1;
	END

    --SELECT * FROM #Enum ORDER BY [Id];
    --SELECT * FROM #EnumVal ORDER BY [Id];
    --SELECT * FROM #StoredProc ORDER BY [Id];
    --SELECT * FROM #StoredProcParam ORDER BY [Id];
    --SELECT * FROM #StoredProcResultSet ORDER BY [Id];
    --SELECT * FROM #TableType;
    --SELECT * FROM #TableTypeColumn ORDER BY [Id];

    EXECUTE @retVal = [Internal].[GenerateStartCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

    
    SELECT @id=MIN([Id]) FROM #Enum;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateEnumCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #Enum WHERE [Id] > @id;
    END
    

    
    SELECT @id=MIN([Id]) FROM #StoredProcResultType;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateResultTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @rtId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #StoredProcResultType WHERE [Id] > @id;
    END

	SELECT @id=MIN([Id]) FROM #TableType;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateTableTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #TableType WHERE [Id] > @id;
    END

    SELECT @id=MIN([Id]) FROM #StoredProc;
    WHILE @id IS NOT NULL
    BEGIN
		EXEC @retVal = [Internal].[GenerateStoredProcWrapperCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		SELECT @id=MIN([Id]) FROM #StoredProc WHERE [Id] > @id;
    END
    
    EXECUTE @retVal = [Internal].[GenerateEndCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END
        
    DROP TABLE IF EXISTS #Enum;
    DROP TABLE IF EXISTS #EnumVal;
    DROP TABLE IF EXISTS #StoredProc;
    DROP TABLE IF EXISTS #StoredProcParam;
    DROP TABLE IF EXISTS #SingleStoredProcResultSet;
    DROP TABLE IF EXISTS #EnumForeignKey;
    DROP TABLE IF EXISTS #StoredProcResultType;
    DROP TABLE IF EXISTS #TableType;
    DROP TABLE IF EXISTS #TableTypeColumn;

    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Creating Procedure [Toolkit].[GenerateCode]...';


GO
CREATE PROCEDURE [Toolkit].[GenerateCode]
    @projectId SMALLINT,
	@databaseName NVARCHAR(128),
	@loggingLevelId TINYINT,
    @errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 1;
    DECLARE @RC_ERR_UNKNOWN_DB INT = 2;

    SELECT @rc = @RC_OK, @errorMessage = NULL;

    DROP TABLE IF EXISTS #Output;

    DECLARE @OPT_GEN_ENUMS SMALLINT = 1;
    DECLARE @OPT_GEN_RESULT_TYPES SMALLINT = 2;
    DECLARE @OPT_GEN_TVP_TYPES SMALLINT = 4;
    DECLARE @OPT_GEN_SP_WRAPPERS SMALLINT = 8;

    DECLARE @langId TINYINT;
    
    SELECT @langId=[LanguageId], @databaseName=ISNULL(@databaseName, [DefaultDatabase]) 
	FROM [dbo].[Project] 
	WHERE [Id]=@projectId;

    IF @projectId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(LOWER(@projectId), '<NULL>');
        RETURN @rc;
    END;

    DECLARE @dbId SMALLINT = DB_ID(@databaseName);

    IF @dbId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_DB, @errorMessage = 'Unknown database: ' + ISNULL(@databaseName, '<NULL>')
        RETURN @rc;
    END;

    DECLARE @retVal int;
    
    CREATE TABLE #Output
	(
		[Id] INT IDENTITY(1,1) PRIMARY KEY,
		[CodePartId] TINYINT NOT NULL,
		[Schema] NVARCHAR(128) NULL,    -- Optional: e.g., for grouping (Enums, TVPs)
		[Text] NVARCHAR(MAX) NOT NULL
	);

    
    EXECUTE @retVal = [Internal].[GenerateCode] @projectId = @projectId, @dbId = @dbId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

	SELECT o.[Id], cp.[Id] [CodePartId], o.[Schema], o.[Text]
    FROM #Output o
	JOIN [Enum].[CodePart] cp ON cp.[Id]=o.[CodePartId]
    ORDER BY o.[Id];
    
    DROP TABLE IF EXISTS #Output;
    
    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Altering Procedure [Project].[GenerateCode]...';


GO
ALTER PROCEDURE [Project].[GenerateCode]
    @projectName NVARCHAR(200),
    @errorMessage NVARCHAR(2000) OUTPUT,
    @databaseName NVARCHAR(128) = NULL,
    @codeGenOptions VARCHAR(1000) = NULL
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE  @rc INT;

    DECLARE @RC_OK INT = 0;
    DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 1;
    DECLARE @RC_ERR_UNKNOWN_DB INT = 2;

    SELECT @rc = @RC_OK, @errorMessage = NULL;

    DROP TABLE IF EXISTS #Output;

    DECLARE @projectId SMALLINT;
    DECLARE @langId TINYINT;
    
	SELECT @projectId=[Id], @langId=[LanguageId], @databaseName=ISNULL(@databaseName, [DefaultDatabase]) FROM [dbo].[Project] WHERE [Name]=@projectName;

    IF @projectId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(@projectName, '<NULL>');
        RETURN @rc;
    END;

    DECLARE @dbId SMALLINT = DB_ID(@databaseName);

    IF @dbId IS NULL 
    BEGIN
        SELECT @rc = @RC_ERR_UNKNOWN_DB, @errorMessage = 'Unknown database: ' + ISNULL(@databaseName, '<NULL>')
        RETURN @rc;
    END;

    DECLARE    @retVal int;
    
    CREATE TABLE #Output
	(
		[Id] INT IDENTITY(1,1) PRIMARY KEY,
		[CodePartId] TINYINT NULL,     -- for now mustr be NULLable, untill we would fix all [Internal].[Generate*Code] SPs
		[Schema] NVARCHAR(128) NULL,    -- Optional: e.g., for grouping (Enums, TVPs)
		[Text] NVARCHAR(MAX) NOT NULL
	);

    
    EXECUTE @retVal = [Internal].[GenerateCode] @projectId = @projectId, @dbId = @dbId, @errorMessage = @errorMessage OUTPUT;
    IF @retVal<>0
    BEGIN
        SELECT @rc = @retVal;
        RETURN @rc;
    END

	SELECT [Text]
    FROM #Output
    ORDER BY [Id];
    
    DROP TABLE IF EXISTS #Output;
    
    SET @rc = @RC_OK;
    RETURN @rc;
END
GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Refreshing Procedure [Project].[CreateProject]...';


GO
EXECUTE sp_refreshsqlmodule N'[Project].[CreateProject]';


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Refreshing Procedure [Project].[UpdateProject]...';


GO
EXECUTE sp_refreshsqlmodule N'[Project].[UpdateProject]';


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Refreshing Procedure [Parser].[ParseTSql]...';


GO
EXECUTE sp_refreshsqlmodule N'[Parser].[ParseTSql]';


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO

PRINT N'Dropping Default Constraint [dbo].[DF_DataTypeMap_IsNullable]...';


GO
ALTER TABLE [dbo].[DataTypeMap] DROP CONSTRAINT [DF_DataTypeMap_IsNullable];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [dbo].[DF_DataTypeMap_SizeNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap] DROP CONSTRAINT [DF_DataTypeMap_SizeNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [dbo].[DF_DataTypeMap_PrecisionNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap] DROP CONSTRAINT [DF_DataTypeMap_PrecisionNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [dbo].[DF_DataTypeMap_ScaleNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap] DROP CONSTRAINT [DF_DataTypeMap_ScaleNeeded];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [dbo].[DF_LanguageOption_IsPrimary]...';


GO
ALTER TABLE [dbo].[LanguageOption] DROP CONSTRAINT [DF_LanguageOption_IsPrimary];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [dbo].[DF_Template_LanguageOptions]...';


GO
ALTER TABLE [dbo].[Template] DROP CONSTRAINT [DF_Template_LanguageOptions];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Default Constraint [Flag].[DF_CodeGenOption_IsSingleBit]...';


GO
ALTER TABLE [Flag].[CodeGenOption] DROP CONSTRAINT [DF_CodeGenOption_IsSingleBit];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_DataTypeMap_Language]...';


GO
ALTER TABLE [dbo].[DataTypeMap] DROP CONSTRAINT [FK_DataTypeMap_Language];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_LanguageNameCasing_Casing]...';


GO
ALTER TABLE [dbo].[LanguageNameCasing] DROP CONSTRAINT [FK_LanguageNameCasing_Casing];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_LanguageNameCasing_Language]...';


GO
ALTER TABLE [dbo].[LanguageNameCasing] DROP CONSTRAINT [FK_LanguageNameCasing_Language];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_LanguageNameCasing_NameType]...';


GO
ALTER TABLE [dbo].[LanguageNameCasing] DROP CONSTRAINT [FK_LanguageNameCasing_NameType];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_LanguageOption_Language]...';


GO
ALTER TABLE [dbo].[LanguageOption] DROP CONSTRAINT [FK_LanguageOption_Language];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_Template_Language]...';


GO
ALTER TABLE [dbo].[Template] DROP CONSTRAINT [FK_Template_Language];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Foreign Key [dbo].[FK_Template_TemplateType]...';


GO
ALTER TABLE [dbo].[Template] DROP CONSTRAINT [FK_Template_TemplateType];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [dbo].[DataTypeMap]...';


GO
DROP TABLE [dbo].[DataTypeMap];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [dbo].[LanguageNameCasing]...';


GO
DROP TABLE [dbo].[LanguageNameCasing];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [dbo].[LanguageOption]...';


GO
DROP TABLE [dbo].[LanguageOption];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [dbo].[Number]...';


GO
DROP TABLE [dbo].[Number];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [dbo].[Template]...';


GO
DROP TABLE [dbo].[Template];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Function [Internal].[GetCodeGenerationOptions]...';


GO
DROP FUNCTION [Internal].[GetCodeGenerationOptions];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO
PRINT N'Dropping Table [Flag].[CodeGenOption]...';


GO
DROP TABLE [Flag].[CodeGenOption];


GO
IF @@ERROR <> 0
   AND @@TRANCOUNT > 0
    BEGIN
        ROLLBACK;
    END

IF OBJECT_ID(N'tempdb..#tmpErrors') IS NULL
    CREATE TABLE [#tmpErrors] (
        Error INT
    );

IF @@TRANCOUNT = 0
    BEGIN
        INSERT  INTO #tmpErrors (Error)
        VALUES                 (1);
        BEGIN TRANSACTION;
    END


GO



IF EXISTS (SELECT * FROM #tmpErrors) ROLLBACK TRANSACTION
GO
IF @@TRANCOUNT>0 BEGIN
PRINT N'The transacted portion of the database update succeeded.'
COMMIT TRANSACTION
END
ELSE PRINT N'The transacted portion of the database update failed.'
GO
IF (SELECT OBJECT_ID('tempdb..#tmpErrors')) IS NOT NULL DROP TABLE #tmpErrors
GO
GO
/*
Post-Deployment Script							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- table [Enum].[Status]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=1) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (1, N'Active');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=2) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (2, N'Experimental');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Status] WHERE [Id]=3) 
INSERT INTO [Enum].[Status] ([Id], [Name]) 
VALUES (3, N'Deprecated');


-- table [Enum].[Language]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Language] WHERE [Id]=1) 
INSERT INTO [Enum].[Language] ([Id], [Name], [Code], [StatusId]) 
VALUES (1, N'c#', N'CSharp', 1);


-- table [Enum].[ClassAccess]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=1) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (1, N'public');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=2) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (2, N'protected');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=3) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (3, N'private');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=4) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (4, N'internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=5) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (5, N'protected internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=6) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (6, N'private protected');


-- table [Enum].[Casing]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=1) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (1, N'PascalCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=2) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (2, N'CamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=3) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (3, N'SnakeCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=4) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (4, N'UnderscoreCamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=5) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (5, N'UpperSnakeCase');


-- table [Enum].[ParamEnumMapping]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=1) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (1, N'ExplicitOnly');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=2) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (2, N'EnumName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=3) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (3, N'EnumNameWithId');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=4) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (4, N'EnumNameWithOrWithoutId');


-- table [Enum].[TemplateType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=1) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (1, N'StartComment');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=2) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (2, N'End');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=3) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (3, N'EnumStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=4) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (4, N'EnumEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=5) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (5, N'EnumEntry');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=6) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (6, N'ResultTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=7) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (7, N'ResultTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=8) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (8, N'ResultTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=10) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (10, N'WrapperStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=11) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (11, N'WrapperEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=12) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (12, N'WrapperPrep');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=13) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (13, N'WrapperExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=14) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (14, N'WrapperParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=15) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (15, N'WrapperParamPreExecInput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=16) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (16, N'WrapperParamPreExecOutput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=17) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (17, N'WrapperExecRS');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=19) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (19, N'WrapperParamPostExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=20) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (20, N'WrapperStart2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=21) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (21, N'WrapperReturnParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=22) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (22, N'WrapperEnd2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=23) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (23, N'WrapperReturnParamDec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=24) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (24, N'TableTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=25) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (25, N'TableTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=26) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (26, N'TableTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=27) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (27, N'WrapperParamPreExecTableType');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=28) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (28, N'TableTypeDtStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=29) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (29, N'TableTypeDtEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=30) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (30, N'TableTypeDtColumn');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=31) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (31, N'TableTypeDtRowsStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=32) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (32, N'TableTypeDtRowsEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=33) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (33, N'TableTypeDtRow');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=34) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (34, N'TableTypeDtColumnAdd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=35) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (35, N'TableTypeDtColumnMaxLen');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=36) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (36, N'TableTypeDtRowNull');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=37) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (37, N'StartUsing');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=38) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (38, N'StartClass');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=39) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (39, N'StartCommentTool');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=40) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (40, N'StartCommentEnv');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=41) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (41, N'StartCommentEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=42) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (42, N'StaticCtorEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=43) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (43, N'RsMappingSetup');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=44) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (44, N'TableTypeDtColumnIdentity');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=45) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (45, N'TableTypeDtColumnPrecisionScale');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=46) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (46, N'WrapperExecRsRv');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=47) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (47, N'EnumStartFlag');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=48) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (48, N'WrapperEnumStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=49) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (49, N'WrapperEnumEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=50) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (50, N'WrapperEnumItem');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=51) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (51, N'StartClassBootstrap');


-- table [Enum].[NameType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=1) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (1, N'Class');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=2) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (2, N'Method');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=3) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (3, N'Property');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=4) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (4, N'Field');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=5) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (5, N'Parameter');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=6) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (6, N'LocalVariable');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=7) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (7, N'TupleField');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=8) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (8, N'Enum');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameType] WHERE [Id]=9) 
INSERT INTO [Enum].[NameType] ([Id], [Name]) 
VALUES (9, N'EnumMember');


-- table: [Static].[DataTypeMap]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'tinyint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'tinyint', N'byte', N'SqlDbType.TinyInt', N'DbType.Byte', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallint', N'short', N'SqlDbType.SmallInt', N'DbType.Int16', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'int') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'int', N'int', N'SqlDbType.Int', N'DbType.Int32', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bigint') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bigint', N'long', N'SqlDbType.BigInt', N'DbType.Int64', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varchar', N'string', N'SqlDbType.VarChar', N'DbType.AnsiString', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'char') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'char', N'string', N'SqlDbType.Char', N'DbType.AnsiStringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nvarchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nvarchar', N'string', N'SqlDbType.NVarChar', N'DbType.String', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nchar') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nchar', N'string', N'SqlDbType.NChar', N'DbType.StringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'date') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'date', N'DateOnly', N'SqlDbType.Date', N'DbType.Date', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'time') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'time', N'TimeOnly', N'SqlDbType.Time', N'DbType.Time', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime2') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime2', N'DateTime', N'SqlDbType.DateTime2', N'DbType.DateTime2', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetimeoffset') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetimeoffset', N'DateTimeOffset', N'SqlDbType.DateTimeOffset', N'DbType.DateTimeOffset', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smalldatetime') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smalldatetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'real') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'real', N'float', N'SqlDbType.Real', N'DbType.Single', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'float') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'float', N'double', N'SqlDbType.Float', N'DbType.Double', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'money') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'money', N'decimal', N'SqlDbType.Money', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'decimal') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'decimal', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'numeric') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'numeric', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallmoney') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallmoney', N'decimal', N'SqlDbType.SmallMoney', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bit') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bit', N'bool', N'SqlDbType.Bit', N'DbType.Boolean', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varbinary') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varbinary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'binary') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'binary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'uniqueidentifier') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'uniqueidentifier', N'Guid', N'SqlDbType.UniqueIdentifier', N'DbType.Guid', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Static].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'sql_variant') 
INSERT INTO [Static].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'sql_variant', N'object', N'SqlDbType.Variant', N'DbType.Object', 1, 0, 0, 0);


-- table: [Static].[LanguageNameCasing]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=1) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=2) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 2, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=3) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 3, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=4) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 4, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=5) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 5, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=6) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 6, 2);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=7) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 7, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=8) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 8, 1);

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageNameCasing] WHERE [LanguageId]=1 AND [NameTypeId]=9) 
INSERT INTO [Static].[LanguageNameCasing] ([LanguageId], [NameTypeId], [CasingId]) 
VALUES (1, 9, 1);


-- table [Enum].[NameMatch]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=1) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (1, N'ExactMatch');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=2) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (2, N'Prefix');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=3) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (3, N'Suffix');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=4) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (4, N'Like');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameMatch] WHERE [Id]=255) 
INSERT INTO [Enum].[NameMatch] ([Id], [Name]) 
VALUES (255, N'Any');


-- table [Enum].[NameSource]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=1) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (1, N'TableName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=2) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (2, N'StoredProcName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[NameSource] WHERE [Id]=3) 
INSERT INTO [Enum].[NameSource] ([Id], [Name]) 
VALUES (3, N'TableTypeName');


-- table [Enum].[NamePartType]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=1) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (1, N'TableNamePreffix', 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=2) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (2, N'TableNameSuffix', 1, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=3) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (3, N'StoredProcNamePrefix', 2, 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=4) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (4, N'StoredProcNameSuffix', 2, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=5) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (5, N'TableTypeNamePrefix', 3, 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[NamePartType] WHERE [Id]=6) 
INSERT INTO [Enum].[NamePartType] ([Id], [Name], [NameSourceId], [IsPrefix], [IsSuffix]) 
VALUES (6, N'TableTypeNameSuffix', 3, 0, 1);


-- table [Enum].[ToolkitResponseCode]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=0) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (0, N'Ok', N'Operation completed successfully.', 1);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1, N'DbError', N'An unexpected database error occured.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=2) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (2, N'InternalError', N'An unexpected internal error occurred.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=3) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (3, N'UnknownProject', N'The specified project does not exist.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=4) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (4, N'InvalidDefaultDatabase', N'The provided default database is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=11) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (11, N'InvalidSchema', N'The provided schema is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=12) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (12, N'InvalidEnumPattern', N'Invalid enum name match pattern.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=13) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (13, N'InvalidProcPattern', N'Invalid stored procedure name match pattern.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=14) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (14, N'InvalidClassAccess', N'Invalid class access.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=15) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (15, N'InvalidLanguage', N'Invalid programming language.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=16) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (16, N'InvalidParamEnumMapping', N'Invalid enum mapping for parameters.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=17) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (17, N'InvalidDatabase', N'The provided database is not valid or accessible.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=18) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (18, N'UnknownEnum', N'Unknown enum', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=19) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (19, N'UnknownResultType', N'Unknown result type', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=20) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (20, N'UnknownTableType', N'Unknown table type', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=21) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (21, N'UnknownStoredProcedure', N'Unknown stored procedure', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=22) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (22, N'DuplicateProject', N'Project with provided name already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=23) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (23, N'NamePatternNotProvided', N'Name pattern must be provided', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=24) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (24, N'DuplicateEnumMapping', N'Project enum mapping already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=25) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (25, N'DuplicateStoredProcMapping', N'Project stored procedures mapping already exists', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=26) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (26, N'UnexpectedEscChar', N'Unexpected escape character', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=27) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (27, N'SchemaNotProvided', N'Name pattern must be provided', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=28) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (28, N'UnknownStoredProcMapping', N'Stored procedure mapping not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=29) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (29, N'UnknownEnumMapping', N'Enum mapping not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=30) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (30, N'InvalidNamePartType', N'Invalid name part type.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=31) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (31, N'UnknownNameNormalization', N'The specified name normalization entry does not exist for this project.', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1000) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1000, N'CliUnhandledException', N'Unexpected application error', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1001) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1001, N'CliFileWriteError', N'Failed to write to output file', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1002) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1002, N'CliInvalidArguments', N'Invalid command-line arguments', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1003) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1003, N'CliInteractiveNotAllowed', N'Prompt attempted in non-interactive mode', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1004) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1004, N'CliMissingConnection', N'Named connection not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1005) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1005, N'CliMissingProject', N'Project not found', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1006) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1006, N'CliCodeGenerationFailed', N'Code generation failed', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1007) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1007, N'CliMissingParameter', N'Missing command parameter', 0);

IF NOT EXISTS (SELECT 1 FROM [Enum].[ToolkitResponseCode] WHERE [Id]=1008) 
INSERT INTO [Enum].[ToolkitResponseCode] ([Id], [Name], [Description], [IsSuccess]) 
VALUES (1008, N'CliNoItemsAvailable', N'No selectable items available in CLI prompt', 0);


-- table [Enum].[CodePart]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=1) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (1, N'H', N'CodeHeader');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=2) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (2, N'B', N'CodeBootstrap');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=3) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (3, N'E', N'Enums');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=4) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (4, N'R', N'ResultTypes');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=5) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (5, N'T', N'TvpTypes');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=6) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (6, N'W', N'SpWrappers');

IF NOT EXISTS (SELECT 1 FROM [Enum].[CodePart] WHERE [Id]=7) 
INSERT INTO [Enum].[CodePart] ([Id], [Code], [Name]) 
VALUES (7, N'Z', N'CodeEnd');


-- table [Enum].[LoggingLevel]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=1) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (1, N'E', N'Error');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=2) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (2, N'W', N'Warning');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=3) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (3, N'I', N'Info');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=4) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (4, N'D', N'Debug');

IF NOT EXISTS (SELECT 1 FROM [Enum].[LoggingLevel] WHERE [Id]=5) 
INSERT INTO [Enum].[LoggingLevel] ([Id], [Code], [Name]) 
VALUES (5, N'T', N'Trace');



-- Completion time: 2025-07-05T16:28:58.8623960+01:00

-- table [Static].[LanguageOption]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='GenerateStaticClass')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'GenerateStaticClass', 0x0000000000000001, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='TreatOutputParamsAsInputOutput')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'TreatOutputParamsAsInputOutput', 0x0000000000000002, 1);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='CaptureReturnValueForResultSetStoredProcedures')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'CaptureReturnValueForResultSetStoredProcedures', 0x0000000000000004, 1);
END;


IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='OutputMinimalEnvInfo')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'OutputMinimalEnvInfo', 0x0000000000000008, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId] IS NULL AND [Name]='OutputMinimalToolInfo')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (NULL, 'OutputMinimalToolInfo', 0x0000000000000010, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId]=1 AND [Name]='TargetClassicDotNet')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (1, 'TargetClassicDotNet', 0x0000000000010000, 0);
END;

IF NOT EXISTS (SELECT 1 FROM [Static].[LanguageOption] WHERE [LanguageId]=1 AND [Name]='UseSyncWrappers')
BEGIN
	INSERT INTO [Static].[LanguageOption] ([LanguageId], [Name], [Value], [IsOverridablePerStoredProc])
	VALUES (1, 'UseSyncWrappers', 0x0000000000020000, 1);
END;



-- Completion time: 2025-07-05T15:59:22.4522379+01:00

DROP TABLE IF EXISTS #Template;
GO

CREATE TABLE #Template
(
    [Id] [smallint] IDENTITY(1,1) NOT NULL PRIMARY KEY,
    [LanguageId] [tinyint] NOT NULL,
    [TypeId] [tinyint] NOT NULL,
    [LanguageOptions] BIGINT NOT NULL DEFAULT(0),
    [Template] [nvarchar](4000) NOT NULL,
    UNIQUE ([LanguageId], [TypeId], [LanguageOptions])
);
GO

DECLARE @langId TINYINT = (SELECT [Id] FROM [Enum].[Language] WHERE [Name] = 'c#');

DECLARE @TT_START_COMMENT TINYINT = 1;
DECLARE @TT_END TINYINT = 2;
DECLARE @TT_ENUM_START TINYINT = 3;
DECLARE @TT_ENUM_END TINYINT = 4;
DECLARE @TT_ENUM_ENTRY TINYINT = 5;
DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;
DECLARE @TT_WRAPPER_START TINYINT = 10;
DECLARE @TT_WRAPPER_END TINYINT = 11;
DECLARE @TT_WRAPPER_PREP TINYINT = 12;
DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
DECLARE @TT_WRAPPER_START2 TINYINT = 20;
DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
DECLARE @TT_WRAPPER_END2 TINYINT = 22;
DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;
DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;
DECLARE @TT_START_USING TINYINT = 37;
DECLARE @TT_START_CLASS TINYINT = 38;
DECLARE @TT_START_COMMENT_TOOL TINYINT = 39;
DECLARE @TT_START_COMMENT_ENV TINYINT = 40;
DECLARE @TT_START_COMMENT_END TINYINT = 41;
DECLARE @TT_STATIC_CTOR_END TINYINT = 42;
DECLARE @TT_RS_MAPPING_SETUP TINYINT = 43;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_IDENTITY TINYINT = 44;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE TINYINT = 45;
DECLARE @TT_WRAPPER_EXEC_RS_RV TINYINT = 46;
DECLARE @TT_ENUM_START_FLAG TINYINT = 47;
DECLARE @TT_WRAPPER_ENUM_START TINYINT = 48;
DECLARE @TT_WRAPPER_ENUM_END TINYINT = 49;
DECLARE @TT_WRAPPER_ENUM_ITEM TINYINT = 50;
DECLARE @TT_START_CLASS_BOOTSTRAP TINYINT = 51;

DECLARE @LO_GENERATE_STATIC_CLASS BIGINT = 1;
DECLARE @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT BIGINT = 2;
DECLARE @LO_CAPTURE_RETURN_VALUE_FOR_RESULT_SET_STORED_PROCEDURES BIGINT = 4;
DECLARE @LO_OUTPUT_MINIMAL_ENV_INFO BIGINT = 8;
DECLARE @LO_OUTPUT_MINIMAL_TOOL_INFO BIGINT = 16;
DECLARE @LO_TARGET_CLASSIC_DOT_NET BIGINT = 65536;
DECLARE @LO_USE_SYNC_WRAPPERS BIGINT = 131072;

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT, 
N'// <auto-generated>
//     This code was generated by a tool.
//
//     Project name:    @{ProjectName}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_ENV, 
N'//     Source database: @{Database}
//     Source server:   @{ServerName}
//     Source instance: @{InstanceName}
//     Database user:   @{DbUser}
//     Timestamp:       @{Timestamp}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_COMMENT_ENV, @LO_OUTPUT_MINIMAL_ENV_INFO, 
N'//     Source database: @{Database}
//     Timestamp:       @{Timestamp}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_TOOL, 
N'//     Tool name:       @{ToolName}
//     Tool database:   @{ToolDatabase}
//     Tool version:    @{ToolVersion}
//     Tool URL:        @{ToolUrl}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_COMMENT_TOOL, @LO_OUTPUT_MINIMAL_TOOL_INFO, 
N'//     Tool name:       @{ToolName}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_COMMENT_END, 
N'//
//     Changes to this file may cause incorrect behavior 
//     and will be lost if the code is regenerated.
// </auto-generated>
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_USING,
N'using System.Data;
using System.Data.Common;
using System.Threading;
using Microsoft.Data.SqlClient;
using Microsoft.Data.SqlClient.Server;
using Dapper;
');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_USING, @LO_TARGET_CLASSIC_DOT_NET,
N'using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SqlServer.Server;
using Dapper;
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_USING, @LO_TARGET_CLASSIC_DOT_NET | @LO_USE_SYNC_WRAPPERS,
N'using System;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SqlServer.Server;
using Dapper;
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_CLASS,
N'namespace @{NamespaceName}
{
    @{ClassAccess} partial class @{ClassName}
    {
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_CLASS, @LO_GENERATE_STATIC_CLASS,
N'namespace @{NamespaceName}
{
    @{ClassAccess} static partial class @{ClassName}
    {        
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START_CLASS_BOOTSTRAP,
N'
        public string ConnectionString { get; set; }

        public int DefaultCommandTimeoutSec { get; set; } = 30;
        
        public @{ClassName}(string connectionString = null)
        {
            ConnectionString = connectionString;
        }

        protected virtual DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }

        [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
        public class ColumnAttribute : Attribute
        {
            public string Name { get; set; }
        }

        public class WrapperSettings
        {
            public int? CommandTimeoutSec { get; set; } = null;
        }

        public Dictionary<StoredProcedureWrapper, WrapperSettings> StoredProcedureWrapperSettings { get; private set; } = new Dictionary<StoredProcedureWrapper, WrapperSettings>();

        public void SetCommandTimeout(StoredProcedureWrapper wrapper, int commandTimeoutSec)
        {
            if (!StoredProcedureWrapperSettings.ContainsKey(wrapper))
            {
                StoredProcedureWrapperSettings[wrapper] = new WrapperSettings();
            }
            StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec = commandTimeoutSec;
        }

        public int GetCommandTimeout(StoredProcedureWrapper wrapper)
        {
            if (StoredProcedureWrapperSettings.ContainsKey(wrapper) && StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.HasValue)
            {
                return StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.Value;
            }
            return DefaultCommandTimeoutSec;
        }

        static @{ClassName}()
        {
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_START_CLASS_BOOTSTRAP, @LO_GENERATE_STATIC_CLASS,
N'
        public static string ConnectionString { get; set; }

        public static int DefaultCommandTimeoutSec { get; set; } = 30;
        
        private static DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }

        [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
        public class ColumnAttribute : Attribute
        {
            public string Name { get; set; }
        }

        public class WrapperSettings
        {
            public int? CommandTimeoutSec { get; set; } = null;
        }

        public static Dictionary<StoredProcedureWrapper, WrapperSettings> StoredProcedureWrapperSettings { get; private set; } = new Dictionary<StoredProcedureWrapper, WrapperSettings>();

        public static void SetCommandTimeout(StoredProcedureWrapper wrapper, int commandTimeoutSec)
        {
            if (!StoredProcedureWrapperSettings.ContainsKey(wrapper))
            {
                StoredProcedureWrapperSettings[wrapper] = new WrapperSettings();
            }
            StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec = commandTimeoutSec;
        }

        public static int GetCommandTimeout(StoredProcedureWrapper wrapper)
        {
            if (StoredProcedureWrapperSettings.ContainsKey(wrapper) && StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.HasValue)
            {
                return StoredProcedureWrapperSettings[wrapper].CommandTimeoutSec.Value;
            }
            return DefaultCommandTimeoutSec;
        }
        
        static @{ClassName}()
        {
');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_STATIC_CTOR_END, 
N'        }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RS_MAPPING_SETUP, 
N'            SqlMapper.SetTypeMap(
                typeof(@{RsType}),
                new CustomPropertyTypeMap(
                    typeof(@{RsType}),
                    (type, columnName) =>
                        type.GetProperties().FirstOrDefault(prop =>
                            prop.GetCustomAttributes(false)
                                .OfType<ColumnAttribute>()
                                .Any(attr => attr.Name == columnName))));
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_END, 
N'
    }
}
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_START, 
N'
        @{EnumAccess} enum @{EnumName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_END, 
N'        }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_ENUM_ITEM, N'            @{Name}@{Sep}');



INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_START, 
N'
        // Source table: @{EnumSchema}.@{EnumTable}
        @{EnumAccess} enum @{EnumName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_START_FLAG, 
N'
        // Source table: @{EnumSchema}.@{EnumTable}
        [Flags]
        @{EnumAccess} enum @{EnumName}
        {');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_ENTRY, N'            @{Name} = @{Value}@{Sep}');





INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_START, 
N'
        // Result type for a stored procedure: @{SpSchema}.@{SpName}
        @{ClassAccess} partial class @{ClassName}
        {');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_PROPERTY, 
N'            [Column(Name="@{ColumnName}")]
            @{PropertyAccess} @{Type} @{Name} { get; set; }');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START, 
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} async Task<@{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_GENERATE_STATIC_CLASS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} static async Task<@{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_USE_SYNC_WRAPPERS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} @{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START, @LO_GENERATE_STATIC_CLASS | @LO_USE_SYNC_WRAPPERS,
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} static @{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START2, 
N'        @{TupleEnd}> @{WrapperName}Async(');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_START2, @LO_USE_SYNC_WRAPPERS,
N'        @{TupleEnd} @{WrapperName}(');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PREP, 
N'            CancellationToken cancellationToken = default
        )
        {
            @{ResultType} @{ResultVarName};
            var p = new DynamicParameters();
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PREP, @LO_USE_SYNC_WRAPPERS, 
N'        )
        {
            @{ResultType} @{ResultVarName};
            var p = new DynamicParameters();
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC, N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                await connection.ExecuteAsync(command);
                connection.Close();
            }
            @{ResultVarName} = p.Get<@{ResultType}>("@returnValue");
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS, N'
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                var queryResult = await connection.QueryAsync<@{ResultTypeSingle}>(command);
                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS_RV, N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);

            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
				var command = new CommandDefinition(
				    commandText: "@{SpSchema}.@{SpName}",
				    parameters: p,
				    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), 
				    commandType: CommandType.StoredProcedure,
				    cancellationToken: cancellationToken
				);
                var queryResult = await connection.QueryAsync<@{ResultTypeSingle}>(command);
                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
            var @{RetValVarName} = p.Get<int>("@returnValue");
');



INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC, @LO_USE_SYNC_WRAPPERS, 
N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            
            using (var connection = GetDbConnection())
            {
                connection.Open();
                connection.Execute("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);
                connection.Close();
            }
            @{ResultVarName} = p.Get<@{ResultType}>("@returnValue");
');


INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS, @LO_USE_SYNC_WRAPPERS,
N'
            using (var connection = GetDbConnection())
            {
                connection.Open();

                var queryResult = connection.Query<@{ResultTypeSingle}>("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);

                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS_RV, @LO_USE_SYNC_WRAPPERS,
N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            using (var connection = GetDbConnection())
            {
                connection.Open();

                var queryResult = connection.Query<@{ResultTypeSingle}>("@{SpSchema}.@{SpName}", p, 
                    commandTimeout: GetCommandTimeout(StoredProcedureWrapper.@{WrapperName}), commandType: CommandType.StoredProcedure);

                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
            var @{RetValVarName} = p.Get<int>("@returnValue");
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END, 
N'            return @{TupleStart}
                @{ResultVarName}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END2, 
N'            @{TupleEnd};
        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM, N'            @{Type} @{ParamName}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM, N'                @{ParamName}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM_DEC, N'            @{Type} @{ParamName}@{Sep}');



INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_INPUT, N'            p.Add("@{Name}", @{TypeCast}@{ParamName});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT, N'            p.Add("@{Name}", null, @{DbType}, ParameterDirection.Output, @{Size}, @{Precision}, @{Scale});');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT, @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT, 
N'            p.Add("@{Name}", @{ParamName}, @{DbType}, ParameterDirection.InputOutput, @{Size}, @{Precision}, @{Scale});');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE, N'
            var @{DtName} = @{TableType}.ToSqlDataRecords(@{ParamName});            
            p.Add("@{Name}", @{DtName}.AsTableValuedParameter("@{TvpName}"));
            ');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_POST_EXEC, N'            var @{ParamName} = @{TypeCast}p.Get<@{Type}>("@{Name}");');

INSERT INTO #Template
([LanguageId], [TypeId], [LanguageOptions], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_POST_EXEC, @LO_TREAT_OUTPUT_PARAMS_AS_INPUT_OUTPUT, N'            @{ParamName} = @{TypeCast}p.Get<@{Type}>("@{Name}");');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_START, 
N'
        // Table type: @{TtSchema}.@{TtName}
        @{ClassAccess} partial class @{ClassName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_PROPERTY, N'            @{PropertyAccess} @{Type} @{Name} { get; set; }');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_START, 
N'
            public static IEnumerable<SqlDataRecord> ToSqlDataRecords(IEnumerable<@{ClassName}> records)        
            {
                var table = new List<SqlDataRecord>();
                var columns = new SqlMetaData[@{NumberOfColumns}];                
                SqlMetaData column;
                SqlDataRecord row;
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_END, 
N'                return table;
            }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, @{MaxLength});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_IDENTITY, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, true, false, SortOrder.Unspecified, -1);');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_PRECISION_SCALE, 
N'                column = new SqlMetaData("@{ColumnName}", @{SqlDbType}, @{Precision}, @{Scale});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_ADD, 
N'                columns[@{ColumnNumber}] = column;
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_START, 
N'                foreach (var record in records)
                {
                    row = new SqlDataRecord(columns);');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_END, 
N'                    table.Add(row);  
                }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW, 
N'                row.SetValue(@{ColumnNumber}, @{Cast}record.@{Name});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW_NULL, 
N'                row.SetValue(@{ColumnNumber}, (object)(@{Cast}record.@{Name}) ?? DBNull.Value);');


GO



UPDATE xt
SET xt.[Template]=t.[Template]
FROM #Template t
JOIN [Static].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId] AND t.[LanguageOptions]=xt.[LanguageOptions]

GO

INSERT INTO [Static].[Template]
([LanguageId], [TypeId], [LanguageOptions], [Template])
SELECT 
t.[LanguageId], t.[TypeId], t.[LanguageOptions], t.[Template]
FROM #Template t
LEFT JOIN [Static].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId] AND t.[LanguageOptions]=xt.[LanguageOptions]
WHERE xt.[Id] IS NULL;
GO

DROP TABLE IF EXISTS #Template;
GO


-- table [ParserEnum].[TSqlSequenceType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (1, N'Normal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (2, N'AnyStatement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (3, N'BlockStatement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (4, N'SequenceOfStatements');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (5, N'TwoPartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (6, N'ThreePartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (7, N'MoreTokens');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (8, N'Label');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (9, N'BeginBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (10, N'EndBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (11, N'SequenceInParentheses');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (12, N'FourPartIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (13, N'ScalarExpression');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (14, N'OutputClause');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (15, N'CaseExpression');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (16, N'VarAssign');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (17, N'SpNumber');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSequenceType] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TSqlSequenceType] ([Id], [Name]) 
VALUES (18, N'IdentifierDot');


-- table [ParserEnum].[TSqlBlockType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (1, N'RegularBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (2, N'TryBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (3, N'CatchBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (4, N'AtomicBlock');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlBlockType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlBlockType] ([Id], [Name]) 
VALUES (5, N'CaseBlock');


-- table [ParserEnum].[TSqlStatementPart]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (1, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (2, N'StartOfParameterList');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (3, N'Definition');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlStatementPart] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlStatementPart] ([Id], [Name]) 
VALUES (4, N'ChildStatement');


-- table [ParserEnum].[TokenType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=0) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (0, N'None');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (1, N'Whitespace');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (2, N'Comment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (3, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (4, N'Keyword');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (5, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (6, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (7, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (8, N'Literal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenType] WHERE [Id]=255) 
INSERT INTO [ParserEnum].[TokenType] ([Id], [Name]) 
VALUES (255, N'Unknown');


-- table [ParserEnum].[TSqlKeyword]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (1, N'ADD');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (2, N'ALL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (3, N'ALTER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (4, N'AND');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (5, N'ANY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (6, N'AS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (7, N'ASC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (8, N'AUTHORIZATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (9, N'BACKUP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (10, N'BEGIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (11, N'BETWEEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (12, N'BREAK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (13, N'BROWSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (14, N'BULK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (15, N'BY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (16, N'CASCADE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (17, N'CASE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (18, N'CHECK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=19) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (19, N'CHECKPOINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=20) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (20, N'CLOSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=21) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (21, N'CLUSTERED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=22) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (22, N'COALESCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=23) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (23, N'COLLATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=24) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (24, N'COLUMN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=25) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (25, N'COMMIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=26) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (26, N'COMPUTE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=27) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (27, N'CONSTRAINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=28) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (28, N'CONTAINS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=29) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (29, N'CONTAINSTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=30) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (30, N'CONTINUE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=31) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (31, N'CONVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=32) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (32, N'CREATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=33) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (33, N'CROSS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=34) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (34, N'CURRENT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=35) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (35, N'CURRENT_DATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=36) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (36, N'CURRENT_TIME');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=37) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (37, N'CURRENT_TIMESTAMP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=38) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (38, N'CURRENT_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=39) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (39, N'CURSOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=40) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (40, N'DATABASE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=41) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (41, N'DBCC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=42) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (42, N'DEALLOCATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=43) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (43, N'DECLARE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=44) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (44, N'DEFAULT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=45) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (45, N'DELETE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=46) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (46, N'DENY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=47) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (47, N'DESC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=48) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (48, N'DISK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=49) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (49, N'DISTINCT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=50) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (50, N'DISTRIBUTED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=51) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (51, N'DOUBLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=52) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (52, N'DROP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=53) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (53, N'DUMP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=54) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (54, N'ELSE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=55) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (55, N'END');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=56) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (56, N'ERRLVL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=57) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (57, N'ESCAPE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=58) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (58, N'EXCEPT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=59) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (59, N'EXEC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=60) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (60, N'EXECUTE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=61) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (61, N'EXISTS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=62) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (62, N'EXIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=63) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (63, N'EXTERNAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=64) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (64, N'FETCH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=65) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (65, N'FILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=66) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (66, N'FILLFACTOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=67) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (67, N'FOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=68) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (68, N'FOREIGN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=69) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (69, N'FREETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=70) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (70, N'FREETEXTTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=71) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (71, N'FROM');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=72) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (72, N'FULL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=73) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (73, N'FUNCTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=74) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (74, N'GOTO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=75) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (75, N'GRANT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=76) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (76, N'GROUP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=77) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (77, N'HAVING');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=78) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (78, N'HOLDLOCK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=79) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (79, N'IDENTITY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=80) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (80, N'IDENTITY_INSERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=81) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (81, N'IDENTITYCOL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=82) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (82, N'IF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=83) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (83, N'IN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=84) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (84, N'INDEX');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=85) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (85, N'INNER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=86) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (86, N'INSERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=87) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (87, N'INTERSECT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=88) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (88, N'INTO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=89) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (89, N'IS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=90) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (90, N'JOIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=91) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (91, N'KEY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=92) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (92, N'KILL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=93) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (93, N'LEFT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=94) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (94, N'LIKE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=95) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (95, N'LINENO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=96) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (96, N'LOAD');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=97) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (97, N'MERGE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=98) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (98, N'NATIONAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=99) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (99, N'NOCHECK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=100) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (100, N'NONCLUSTERED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=101) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (101, N'NOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=102) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (102, N'NULL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=103) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (103, N'NULLIF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=104) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (104, N'OF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=105) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (105, N'OFF');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=106) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (106, N'OFFSETS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=107) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (107, N'ON');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=108) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (108, N'OPEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=109) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (109, N'OPENDATASOURCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=110) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (110, N'OPENQUERY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=111) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (111, N'OPENROWSET');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=112) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (112, N'OPENXML');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=113) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (113, N'OPTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=114) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (114, N'OR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=115) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (115, N'ORDER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=116) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (116, N'OUTER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=117) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (117, N'OVER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=118) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (118, N'PERCENT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=119) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (119, N'PIVOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=120) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (120, N'PLAN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=121) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (121, N'PRECISION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=122) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (122, N'PRIMARY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=123) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (123, N'PRINT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=124) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (124, N'PROC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=125) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (125, N'PROCEDURE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=126) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (126, N'PUBLIC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=127) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (127, N'RAISERROR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=128) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (128, N'READ');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=129) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (129, N'READTEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=130) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (130, N'RECONFIGURE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=131) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (131, N'REFERENCES');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=132) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (132, N'REPLICATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=133) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (133, N'RESTORE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=134) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (134, N'RESTRICT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=135) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (135, N'RETURN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=136) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (136, N'REVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=137) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (137, N'REVOKE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=138) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (138, N'RIGHT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=139) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (139, N'ROLLBACK');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=140) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (140, N'ROWCOUNT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=141) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (141, N'ROWGUIDCOL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=142) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (142, N'RULE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=143) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (143, N'SAVE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=144) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (144, N'SCHEMA');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=145) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (145, N'SECURITYAUDIT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=146) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (146, N'SELECT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=147) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (147, N'SEMANTICKEYPHRASETABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=148) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (148, N'SEMANTICSIMILARITYDETAILSTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=149) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (149, N'SEMANTICSIMILARITYTABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=150) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (150, N'SESSION_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=151) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (151, N'SET');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=152) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (152, N'SETUSER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=153) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (153, N'SHUTDOWN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=154) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (154, N'SOME');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=155) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (155, N'STATISTICS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=156) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (156, N'SYSTEM_USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=157) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (157, N'TABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=158) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (158, N'TABLESAMPLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=159) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (159, N'TEXTSIZE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=160) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (160, N'THEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=161) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (161, N'TO');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=162) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (162, N'TOP');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=163) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (163, N'TRAN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=164) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (164, N'TRANSACTION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=165) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (165, N'TRIGGER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=166) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (166, N'TRUNCATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=167) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (167, N'TRY_CONVERT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=168) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (168, N'TSEQUAL');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=169) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (169, N'UNION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=170) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (170, N'UNIQUE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=171) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (171, N'UNPIVOT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=172) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (172, N'UPDATE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=173) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (173, N'UPDATETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=174) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (174, N'USE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=175) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (175, N'USER');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=176) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (176, N'VALUES');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=177) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (177, N'VARYING');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=178) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (178, N'VIEW');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=179) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (179, N'WAITFOR');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=180) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (180, N'WHEN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=181) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (181, N'WHERE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=182) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (182, N'WHILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=183) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (183, N'WITH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=184) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (184, N'WITHIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=185) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (185, N'WRITETEXT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=186) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (186, N'ATOMIC');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=187) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (187, N'CONVERSATION');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=188) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (188, N'DIALOG');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=189) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (189, N'CATCH');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=190) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (190, N'TRY');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=191) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (191, N'THROW');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=192) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (192, N'FILETABLE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=193) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (193, N'OUTPUT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=194) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (194, N'LOGIN');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=195) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (195, N'AT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=196) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (196, N'DATA_SOURCE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=197) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (197, N'RECOMPILE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=198) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (198, N'RESULT');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=199) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (199, N'SETS');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=200) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (200, N'UNDEFINED');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=201) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (201, N'NONE');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlKeyword] WHERE [Id]=32767) 
INSERT INTO [ParserEnum].[TSqlKeyword] ([Id], [Name]) 
VALUES (32767, N'<MORE_THAN_ONE>');


-- table [ParserEnum].[CharType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=0) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (0, N'Unknown');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (1, N'Letter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (2, N'UnicodeLetter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (3, N'Digit');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (4, N'UnicodeDigit');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (5, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (6, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (7, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (8, N'Special');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[CharType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[CharType] ([Id], [Name]) 
VALUES (9, N'Whitespace');


-- table [ParserEnum].[TSqlSeqElementType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (1, N'Keyword');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (2, N'Identifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (3, N'Operator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (4, N'Separator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (5, N'Delimiter');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (6, N'Statement');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (7, N'SequenceOfStatements');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (8, N'Block');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (9, N'LiteralString');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (10, N'Sequence');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (11, N'End');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (12, N'LiteralInt');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (13, N'VariableName');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (14, N'SpecialSequence');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TSqlSeqElementType] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TSqlSeqElementType] ([Id], [Name]) 
VALUES (15, N'Literal');


-- table [ParserEnum].[TokenSubtype]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=1) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (1, 2, N'SingleLineComment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=2) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (2, 2, N'MultiLineComment');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=3) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (3, 3, N'RegularIdentifier');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=4) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (4, 3, N'IdentifierInBrackets');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=5) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (5, 3, N'IdentifierInDoubleQuotes');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=6) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (6, 8, N'String');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=7) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (7, 8, N'UnicodeString');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=8) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (8, 8, N'Integer');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=9) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (9, 8, N'Decimal');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=10) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (10, 8, N'Money');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=11) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (11, 8, N'Real');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=12) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (12, 8, N'Binary');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=13) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (13, 6, N'Comma');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=14) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (14, 6, N'Semicolon');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=15) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (15, 6, N'Period');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=16) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (16, 4, N'VariableName');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=17) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (17, 7, N'UnaryOperator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=18) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (18, 7, N'BinaryOperator');

IF NOT EXISTS (SELECT 1 FROM [ParserEnum].[TokenSubtype] WHERE [Id]=19) 
INSERT INTO [ParserEnum].[TokenSubtype] ([Id], [TypeId], [Name]) 
VALUES (19, 7, N'UnaryOrBinaryOperator');


-- table [Parser].[Operator]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=1) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (1, 'BT_NOT', '~', 1, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=2) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (2, 'MUL', '*', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=3) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (3, 'DIV', '/', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=4) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (4, 'MOD', '%', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=5) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (5, 'ADD', '+', 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=6) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (6, 'SUB', '-', 1, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=7) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (7, 'BT_AND', '&', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=8) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (8, 'BT_XOR', '^', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=9) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (9, 'BT_OR', '|', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=10) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (10, 'EQ', '=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=11) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (11, 'GT', '>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=12) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (12, 'LT', '<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=13) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (13, 'GE', '>=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=14) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (14, 'LE', '<=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=15) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (15, 'NE', '<>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=16) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (16, 'NE2', '!=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=17) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (17, 'NGT', '!>', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=18) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (18, 'NLT', '!<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=19) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (19, 'ADD_ASSIGN', '+=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=20) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (20, 'SUB_ASSIGN', '-=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=21) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (21, 'MUL_ASSIGN', '*=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=22) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (22, 'DIV_ASSIGN', '/=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=23) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (23, 'MOD_ASSIGN', '%=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=24) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (24, 'BT_AND_ASSIGN', '&=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=25) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (25, 'BT_XOR_ASSIGN', '^=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=26) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (26, 'BT_OR_ASSIGN', '|=', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=27) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (27, 'SCOPE', '::', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=28) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (28, 'NOT', 'NOT', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=29) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (29, 'AND', 'AND', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=30) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (30, 'ALL', 'ALL', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=31) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (31, 'ANY', 'ANY', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=32) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (32, 'BETWEEN', 'BETWEEN', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=33) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (33, 'IN', 'IN', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=34) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (34, 'LIKE', 'LIKE', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=35) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (35, 'OR', 'OR', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=36) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (36, 'SOME', 'SOME', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=37) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (37, 'EXISTS', 'EXISTS', 0, 0);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=38) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (38, 'BT_SHL', '<<', 0, 1);

IF NOT EXISTS (SELECT 1 FROM [Parser].[Operator] WHERE [Id]=39) 
INSERT INTO [Parser].[Operator] ([Id], [Name], [Operator], [Unary], [Binary]) 
VALUES (39, 'BT_SHR', '>>', 0, 1);



-- Completion time: 2025-07-05T16:03:47.0047302+01:00

GO
IF NOT EXISTS (SELECT 1 FROM [Static].[Number])
BEGIN
	PRINT(N'Populating table [Static].[Number]. This may take a while...');
	-- https://www.sommarskog.se/Short%20Stories/table-of-numbers.html#creatingnumbers
	WITH L0 AS (SELECT 1 AS c UNION ALL SELECT 1),
     L1   AS (SELECT 1 AS c FROM L0 AS A, L0 AS B),
     L2   AS (SELECT 1 AS c FROM L1 AS A, L1 AS B),
     L3   AS (SELECT 1 AS c FROM L2 AS A, L2 AS B),
     L4   AS (SELECT 1 AS c FROM L3 AS A, L3 AS B),
     L5   AS (SELECT 1 AS c FROM L4 AS A, L4 AS B),
     Nums AS (SELECT row_number() OVER(ORDER BY c) AS n FROM L5)
	INSERT INTO [Static].[Number] ([N])
	SELECT n-1 
	FROM  Nums 
	WHERE n <= 1000001;
END
GO
IF NOT EXISTS (SELECT 1 FROM [Parser].[CharTypeMap])
BEGIN
	PRINT(N'Populating table [Parser].[CharTypeMap]...');
	INSERT INTO [Parser].[CharTypeMap]([Char], [TypeId])
	SELECT CHAR(n.[N]), [Parser].[GetCharType](CHAR(n.[N]))
	FROM [Static].[Number] n
	WHERE n.[N] BETWEEN 1 AND 127 AND [Parser].[GetCharType](CHAR(n.[N]))<>0;
END
GO

GO

DECLARE @KW_ADD SMALLINT = 1;
DECLARE @KW_ALL SMALLINT = 2;
DECLARE @KW_ALTER SMALLINT = 3;
DECLARE @KW_AND SMALLINT = 4;
DECLARE @KW_ANY SMALLINT = 5;
DECLARE @KW_AS SMALLINT = 6;
DECLARE @KW_ASC SMALLINT = 7;
DECLARE @KW_AUTHORIZATION SMALLINT = 8;
DECLARE @KW_BACKUP SMALLINT = 9;
DECLARE @KW_BEGIN SMALLINT = 10;
DECLARE @KW_BETWEEN SMALLINT = 11;
DECLARE @KW_BREAK SMALLINT = 12;
DECLARE @KW_BROWSE SMALLINT = 13;
DECLARE @KW_BULK SMALLINT = 14;
DECLARE @KW_BY SMALLINT = 15;
DECLARE @KW_CASCADE SMALLINT = 16;
DECLARE @KW_CASE SMALLINT = 17;
DECLARE @KW_CHECK SMALLINT = 18;
DECLARE @KW_CHECKPOINT SMALLINT = 19;
DECLARE @KW_CLOSE SMALLINT = 20;
DECLARE @KW_CLUSTERED SMALLINT = 21;
DECLARE @KW_COALESCE SMALLINT = 22;
DECLARE @KW_COLLATE SMALLINT = 23;
DECLARE @KW_COLUMN SMALLINT = 24;
DECLARE @KW_COMMIT SMALLINT = 25;
DECLARE @KW_COMPUTE SMALLINT = 26;
DECLARE @KW_CONSTRAINT SMALLINT = 27;
DECLARE @KW_CONTAINS SMALLINT = 28;
DECLARE @KW_CONTAINSTABLE SMALLINT = 29;
DECLARE @KW_CONTINUE SMALLINT = 30;
DECLARE @KW_CONVERT SMALLINT = 31;
DECLARE @KW_CREATE SMALLINT = 32;
DECLARE @KW_CROSS SMALLINT = 33;
DECLARE @KW_CURRENT SMALLINT = 34;
DECLARE @KW_CURRENT_DATE SMALLINT = 35;
DECLARE @KW_CURRENT_TIME SMALLINT = 36;
DECLARE @KW_CURRENT_TIMESTAMP SMALLINT = 37;
DECLARE @KW_CURRENT_USER SMALLINT = 38;
DECLARE @KW_CURSOR SMALLINT = 39;
DECLARE @KW_DATABASE SMALLINT = 40;
DECLARE @KW_DBCC SMALLINT = 41;
DECLARE @KW_DEALLOCATE SMALLINT = 42;
DECLARE @KW_DECLARE SMALLINT = 43;
DECLARE @KW_DEFAULT SMALLINT = 44;
DECLARE @KW_DELETE SMALLINT = 45;
DECLARE @KW_DENY SMALLINT = 46;
DECLARE @KW_DESC SMALLINT = 47;
DECLARE @KW_DISK SMALLINT = 48;
DECLARE @KW_DISTINCT SMALLINT = 49;
DECLARE @KW_DISTRIBUTED SMALLINT = 50;
DECLARE @KW_DOUBLE SMALLINT = 51;
DECLARE @KW_DROP SMALLINT = 52;
DECLARE @KW_DUMP SMALLINT = 53;
DECLARE @KW_ELSE SMALLINT = 54;
DECLARE @KW_END SMALLINT = 55;
DECLARE @KW_ERRLVL SMALLINT = 56;
DECLARE @KW_ESCAPE SMALLINT = 57;
DECLARE @KW_EXCEPT SMALLINT = 58;
DECLARE @KW_EXEC SMALLINT = 59;
DECLARE @KW_EXECUTE SMALLINT = 60;
DECLARE @KW_EXISTS SMALLINT = 61;
DECLARE @KW_EXIT SMALLINT = 62;
DECLARE @KW_EXTERNAL SMALLINT = 63;
DECLARE @KW_FETCH SMALLINT = 64;
DECLARE @KW_FILE SMALLINT = 65;
DECLARE @KW_FILLFACTOR SMALLINT = 66;
DECLARE @KW_FOR SMALLINT = 67;
DECLARE @KW_FOREIGN SMALLINT = 68;
DECLARE @KW_FREETEXT SMALLINT = 69;
DECLARE @KW_FREETEXTTABLE SMALLINT = 70;
DECLARE @KW_FROM SMALLINT = 71;
DECLARE @KW_FULL SMALLINT = 72;
DECLARE @KW_FUNCTION SMALLINT = 73;
DECLARE @KW_GOTO SMALLINT = 74;
DECLARE @KW_GRANT SMALLINT = 75;
DECLARE @KW_GROUP SMALLINT = 76;
DECLARE @KW_HAVING SMALLINT = 77;
DECLARE @KW_HOLDLOCK SMALLINT = 78;
DECLARE @KW_IDENTITY SMALLINT = 79;
DECLARE @KW_IDENTITY_INSERT SMALLINT = 80;
DECLARE @KW_IDENTITYCOL SMALLINT = 81;
DECLARE @KW_IF SMALLINT = 82;
DECLARE @KW_IN SMALLINT = 83;
DECLARE @KW_INDEX SMALLINT = 84;
DECLARE @KW_INNER SMALLINT = 85;
DECLARE @KW_INSERT SMALLINT = 86;
DECLARE @KW_INTERSECT SMALLINT = 87;
DECLARE @KW_INTO SMALLINT = 88;
DECLARE @KW_IS SMALLINT = 89;
DECLARE @KW_JOIN SMALLINT = 90;
DECLARE @KW_KEY SMALLINT = 91;
DECLARE @KW_KILL SMALLINT = 92;
DECLARE @KW_LEFT SMALLINT = 93;
DECLARE @KW_LIKE SMALLINT = 94;
DECLARE @KW_LINENO SMALLINT = 95;
DECLARE @KW_LOAD SMALLINT = 96;
DECLARE @KW_MERGE SMALLINT = 97;
DECLARE @KW_NATIONAL SMALLINT = 98;
DECLARE @KW_NOCHECK SMALLINT = 99;
DECLARE @KW_NONCLUSTERED SMALLINT = 100;
DECLARE @KW_NOT SMALLINT = 101;
DECLARE @KW_NULL SMALLINT = 102;
DECLARE @KW_NULLIF SMALLINT = 103;
DECLARE @KW_OF SMALLINT = 104;
DECLARE @KW_OFF SMALLINT = 105;
DECLARE @KW_OFFSETS SMALLINT = 106;
DECLARE @KW_ON SMALLINT = 107;
DECLARE @KW_OPEN SMALLINT = 108;
DECLARE @KW_OPENDATASOURCE SMALLINT = 109;
DECLARE @KW_OPENQUERY SMALLINT = 110;
DECLARE @KW_OPENROWSET SMALLINT = 111;
DECLARE @KW_OPENXML SMALLINT = 112;
DECLARE @KW_OPTION SMALLINT = 113;
DECLARE @KW_OR SMALLINT = 114;
DECLARE @KW_ORDER SMALLINT = 115;
DECLARE @KW_OUTER SMALLINT = 116;
DECLARE @KW_OVER SMALLINT = 117;
DECLARE @KW_PERCENT SMALLINT = 118;
DECLARE @KW_PIVOT SMALLINT = 119;
DECLARE @KW_PLAN SMALLINT = 120;
DECLARE @KW_PRECISION SMALLINT = 121;
DECLARE @KW_PRIMARY SMALLINT = 122;
DECLARE @KW_PRINT SMALLINT = 123;
DECLARE @KW_PROC SMALLINT = 124;
DECLARE @KW_PROCEDURE SMALLINT = 125;
DECLARE @KW_PUBLIC SMALLINT = 126;
DECLARE @KW_RAISERROR SMALLINT = 127;
DECLARE @KW_READ SMALLINT = 128;
DECLARE @KW_READTEXT SMALLINT = 129;
DECLARE @KW_RECONFIGURE SMALLINT = 130;
DECLARE @KW_REFERENCES SMALLINT = 131;
DECLARE @KW_REPLICATION SMALLINT = 132;
DECLARE @KW_RESTORE SMALLINT = 133;
DECLARE @KW_RESTRICT SMALLINT = 134;
DECLARE @KW_RETURN SMALLINT = 135;
DECLARE @KW_REVERT SMALLINT = 136;
DECLARE @KW_REVOKE SMALLINT = 137;
DECLARE @KW_RIGHT SMALLINT = 138;
DECLARE @KW_ROLLBACK SMALLINT = 139;
DECLARE @KW_ROWCOUNT SMALLINT = 140;
DECLARE @KW_ROWGUIDCOL SMALLINT = 141;
DECLARE @KW_RULE SMALLINT = 142;
DECLARE @KW_SAVE SMALLINT = 143;
DECLARE @KW_SCHEMA SMALLINT = 144;
DECLARE @KW_SECURITYAUDIT SMALLINT = 145;
DECLARE @KW_SELECT SMALLINT = 146;
DECLARE @KW_SEMANTICKEYPHRASETABLE SMALLINT = 147;
DECLARE @KW_SEMANTICSIMILARITYDETAILSTABLE SMALLINT = 148;
DECLARE @KW_SEMANTICSIMILARITYTABLE SMALLINT = 149;
DECLARE @KW_SESSION_USER SMALLINT = 150;
DECLARE @KW_SET SMALLINT = 151;
DECLARE @KW_SETUSER SMALLINT = 152;
DECLARE @KW_SHUTDOWN SMALLINT = 153;
DECLARE @KW_SOME SMALLINT = 154;
DECLARE @KW_STATISTICS SMALLINT = 155;
DECLARE @KW_SYSTEM_USER SMALLINT = 156;
DECLARE @KW_TABLE SMALLINT = 157;
DECLARE @KW_TABLESAMPLE SMALLINT = 158;
DECLARE @KW_TEXTSIZE SMALLINT = 159;
DECLARE @KW_THEN SMALLINT = 160;
DECLARE @KW_TO SMALLINT = 161;
DECLARE @KW_TOP SMALLINT = 162;
DECLARE @KW_TRAN SMALLINT = 163;
DECLARE @KW_TRANSACTION SMALLINT = 164;
DECLARE @KW_TRIGGER SMALLINT = 165;
DECLARE @KW_TRUNCATE SMALLINT = 166;
DECLARE @KW_TRY_CONVERT SMALLINT = 167;
DECLARE @KW_TSEQUAL SMALLINT = 168;
DECLARE @KW_UNION SMALLINT = 169;
DECLARE @KW_UNIQUE SMALLINT = 170;
DECLARE @KW_UNPIVOT SMALLINT = 171;
DECLARE @KW_UPDATE SMALLINT = 172;
DECLARE @KW_UPDATETEXT SMALLINT = 173;
DECLARE @KW_USE SMALLINT = 174;
DECLARE @KW_USER SMALLINT = 175;
DECLARE @KW_VALUES SMALLINT = 176;
DECLARE @KW_VARYING SMALLINT = 177;
DECLARE @KW_VIEW SMALLINT = 178;
DECLARE @KW_WAITFOR SMALLINT = 179;
DECLARE @KW_WHEN SMALLINT = 180;
DECLARE @KW_WHERE SMALLINT = 181;
DECLARE @KW_WHILE SMALLINT = 182;
DECLARE @KW_WITH SMALLINT = 183;
DECLARE @KW_WITHIN SMALLINT = 184;
DECLARE @KW_WRITETEXT SMALLINT = 185;
DECLARE @KW_ATOMIC SMALLINT = 186;
DECLARE @KW_CONVERSATION SMALLINT = 187;
DECLARE @KW_DIALOG SMALLINT = 188;
DECLARE @KW_CATCH SMALLINT = 189;
DECLARE @KW_TRY SMALLINT = 190;
DECLARE @KW_THROW SMALLINT = 191;
DECLARE @KW_FILETABLE SMALLINT = 192;
DECLARE @KW_OUTPUT SMALLINT = 193;
DECLARE @KW_LOGIN SMALLINT = 194;
DECLARE @KW_AT SMALLINT = 195;
DECLARE @KW_DATA_SOURCE SMALLINT = 196;
DECLARE @KW_RECOMPILE SMALLINT = 197;
DECLARE @KW_RESULT SMALLINT = 198;
DECLARE @KW_SETS SMALLINT = 199;
DECLARE @KW_UNDEFINED SMALLINT = 200;
DECLARE @KW_NONE SMALLINT = 201;
DECLARE @KW_MORE_THAN_ONE SMALLINT = 32767;


DECLARE @ST_CREATE_PROCEDURE SMALLINT = 1;
DECLARE @ST_CREATE_TABLE SMALLINT = 2;
DECLARE @ST_EXEC SMALLINT = 3;
DECLARE @ST_SELECT SMALLINT = 4;
DECLARE @ST_INSERT SMALLINT = 5;
DECLARE @ST_UPDATE SMALLINT = 6;
DECLARE @ST_DELETE SMALLINT = 7;
DECLARE @ST_DECLARE SMALLINT = 8;
DECLARE @ST_SET SMALLINT = 9;

DECLARE @ST_TRUNCATE_TABLE SMALLINT = 10;
DECLARE @ST_DROP_TABLE SMALLINT = 11;

DECLARE @ST_BEGIN_TRANSACTION SMALLINT = 20;
DECLARE @ST_BEGIN_DISTRIBUTED_TRANSACTION SMALLINT = 21;
DECLARE @ST_COMMIT SMALLINT = 23;
DECLARE @ST_ROLLBACK SMALLINT = 24;

DECLARE @ST_IF SMALLINT = 31;
DECLARE @ST_WHILE SMALLINT = 32;
DECLARE @ST_CONTINUE SMALLINT = 33;
DECLARE @ST_BREAK SMALLINT = 34;
DECLARE @ST_THROW SMALLINT = 35;
DECLARE @ST_RAISERROR SMALLINT = 36;
DECLARE @ST_PRINT SMALLINT = 37;
DECLARE @ST_RETURN SMALLINT = 38;

-- DECLARE @ST_BEGIN_DIALOG SMALLINT = 101;
-- DECLARE @ST_BEGIN_CONVERSATION_TIMER SMALLINT = 102;


--DECLARE @ST_BEGIN_ATOMIC SMALLINT = 11;
--DECLARE @ST_BEGIN_TRY SMALLINT = 12;
--DECLARE @ST_BEGIN_CATCH SMALLINT = 13;


DECLARE @ET_KEYWORD TINYINT = 1;
DECLARE @ET_IDENTIFIER TINYINT = 2;
DECLARE @ET_OPERATOR TINYINT = 3;
DECLARE @ET_SEPARATOR TINYINT = 4;
DECLARE @ET_DELIMITER TINYINT = 5;
DECLARE @ET_STATEMENT TINYINT = 6;
DECLARE @ET_SEQUENCE_OF_STATEMENTS TINYINT = 7;
DECLARE @ET_BLOCK TINYINT = 8;
DECLARE @ET_LITERAL_STRING TINYINT = 9;
DECLARE @ET_SEQUENCE TINYINT = 10;
DECLARE @ET_END TINYINT = 11;
DECLARE @ET_LITERAL_INT TINYINT = 12;
DECLARE @ET_VARIABLE_NAME TINYINT = 13;
DECLARE @ET_SPECIAL_SEQUENCE TINYINT = 14;
DECLARE @ET_LITERAL TINYINT = 15;

DECLARE @SQT_NORMAL TINYINT = 1;
DECLARE @SQT_ANY_STATEMENT TINYINT = 2;
DECLARE @SQT_BLOCK_STATEMENT TINYINT = 3;
DECLARE @SQT_SEQUENCE_OF_STATEMENTS TINYINT = 4;
DECLARE @SQT_TWO_PART_IDENTIFIER TINYINT = 5;
DECLARE @SQT_THREE_PART_IDENTIFIER TINYINT = 6;
DECLARE @SQT_MORE_TOKENS TINYINT = 7;
DECLARE @SQT_LABEL TINYINT = 8;
DECLARE @SQT_BEGIN_BLOCK TINYINT = 9;
DECLARE @SQT_END_BLOCK TINYINT = 10;
DECLARE @SQT_SEQUENCE_IN_PARENTHESES TINYINT = 11;
DECLARE @SQT_FOUR_PART_IDENTIFIER TINYINT = 12;
DECLARE @SQT_SCALAR_EXPRESSION TINYINT = 13;
DECLARE @SQT_OUTPUT_CLAUSE TINYINT = 14;
DECLARE @SQT_CASE_EXPRESSION TINYINT = 15;
DECLARE @SQT_VAR_ASSIGN TINYINT = 16;
DECLARE @SQT_SP_NUMBER TINYINT = 17;
DECLARE @SQT_IDENTIFIER_DOT TINYINT = 18;


DECLARE @SP_IDENTIFIER TINYINT = 1;
DECLARE @SP_START_OF_PARAMETER_LIST TINYINT = 2;
DECLARE @SP_DEFINITION TINYINT = 3;
DECLARE @SP_CHILD_STATEMENT TINYINT = 4;


DECLARE @TT_NONE TINYINT = 0;
DECLARE @TT_WHITESPACE TINYINT = 1;
DECLARE @TT_COMMENT TINYINT = 2;
DECLARE @TT_IDENTIFIER TINYINT = 3;
DECLARE @TT_KEYWORD TINYINT = 4;
DECLARE @TT_DELIMITER TINYINT = 5;
DECLARE @TT_SEPARATOR TINYINT = 6;
DECLARE @TT_OPERATOR TINYINT = 7;
DECLARE @TT_LITERAL TINYINT = 8;
DECLARE @TT_UNKNOWN TINYINT = 255;

DECLARE @TST_SINGLE_LINE_COMMENT TINYINT = 1;
DECLARE @TST_MULTI_LINE_COMMENT TINYINT = 2;
DECLARE @TST_REGULAR_IDENTIFIER TINYINT = 3;
DECLARE @TST_IDENTIFIER_IN_BRACKETS TINYINT = 4;
DECLARE @TST_IDENTIFIER_IN_DOUBLE_QUOTES TINYINT = 5;
DECLARE @TST_STRING TINYINT = 6;
DECLARE @TST_UNICODE_STRING TINYINT = 7;
DECLARE @TST_INTEGER TINYINT = 8;
DECLARE @TST_DECIMAL TINYINT = 9;
DECLARE @TST_MONEY TINYINT = 10;
DECLARE @TST_REAL TINYINT = 11;
DECLARE @TST_BINARY TINYINT = 12;
DECLARE @TST_COMMA TINYINT = 13;
DECLARE @TST_SEMICOLON TINYINT = 14;
DECLARE @TST_PERIOD TINYINT = 15;
DECLARE @TST_VARIABLE_NAME TINYINT = 16;
DECLARE @TST_UNARY_OPERATOR TINYINT = 17;
DECLARE @TST_BINARY_OPERATOR TINYINT = 18;
DECLARE @TST_UNARY_OR_BINARY_OPERATOR TINYINT = 19;

DECLARE @OP_BT_NOT TINYINT = 1;
DECLARE @OP_MUL TINYINT = 2;
DECLARE @OP_DIV TINYINT = 3;
DECLARE @OP_MOD TINYINT = 4;
DECLARE @OP_ADD TINYINT = 5;
DECLARE @OP_SUB TINYINT = 6;
DECLARE @OP_BT_AND TINYINT = 7;
DECLARE @OP_BT_XOR TINYINT = 8;
DECLARE @OP_BT_OR TINYINT = 9;
DECLARE @OP_EQ TINYINT = 10;
DECLARE @OP_GT TINYINT = 11;
DECLARE @OP_LT TINYINT = 12;
DECLARE @OP_GE TINYINT = 13;
DECLARE @OP_LE TINYINT = 14;
DECLARE @OP_NE TINYINT = 15;
DECLARE @OP_NE2 TINYINT = 16;
DECLARE @OP_NGT TINYINT = 17;
DECLARE @OP_NLT TINYINT = 18;
DECLARE @OP_ADD_ASSIGN TINYINT = 19;
DECLARE @OP_SUB_ASSIGN TINYINT = 20;
DECLARE @OP_MUL_ASSIGN TINYINT = 21;
DECLARE @OP_DIV_ASSIGN TINYINT = 22;
DECLARE @OP_MOD_ASSIGN TINYINT = 23;
DECLARE @OP_BT_AND_ASSIGN TINYINT = 24;
DECLARE @OP_BT_XOR_ASSIGN TINYINT = 25;
DECLARE @OP_BT_OR_ASSIGN TINYINT = 26;
DECLARE @OP_SCOPE TINYINT = 27;
DECLARE @OP_NOT TINYINT = 28;
DECLARE @OP_AND TINYINT = 29;
DECLARE @OP_ALL TINYINT = 30;
DECLARE @OP_ANY TINYINT = 31;
DECLARE @OP_BETWEEN TINYINT = 32;
DECLARE @OP_IN TINYINT = 33;
DECLARE @OP_LIKE TINYINT = 34;
DECLARE @OP_OR TINYINT = 35;
DECLARE @OP_SOME TINYINT = 36;
DECLARE @OP_EXISTS TINYINT = 37;
DECLARE @OP_BT_SHL TINYINT = 38;
DECLARE @OP_BT_SHR TINYINT = 39;

DELETE FROM [Parser].[TSqlSeqElement];
DELETE FROM [Parser].[TSqlSequence];
DBCC CHECKIDENT ('[Parser].[TSqlSequence]', RESEED, 0);
DELETE FROM [ParserEnum].[TSqlStatementType];

ALTER SEQUENCE [Parser].[TSqlSeqEl]  
RESTART WITH 1;  


INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CREATE_PROCEDURE, 'CreateProcedure', @KW_CREATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CREATE_TABLE, 'CreateTable', @KW_CREATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_EXEC, 'Exec', @KW_MORE_THAN_ONE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DECLARE, 'Declare', @KW_DECLARE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_SET, 'Set', @KW_SET, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_SELECT, 'Select', @KW_SELECT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_INSERT, 'Insert', @KW_INSERT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_UPDATE, 'Update', @KW_UPDATE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DELETE, 'Delete', @KW_DELETE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_TRANSACTION, 'BeginTran', @KW_BEGIN, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_DISTRIBUTED_TRANSACTION, 'BeginDistTran', @KW_BEGIN, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_COMMIT, 'Commit', @KW_COMMIT, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_ROLLBACK, 'Rollback', @KW_ROLLBACK, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_TRUNCATE_TABLE, 'TruncateTable', @KW_TRUNCATE, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_DROP_TABLE, 'DropTable', @KW_DROP, 0, 0, 0);


INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_IF, 'If', @KW_IF, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_WHILE, 'While', @KW_WHILE, 1, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_CONTINUE, 'Continue', @KW_CONTINUE, 1, 1, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BREAK, 'Break', @KW_BREAK, 1, 1, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_THROW, 'Throw', @KW_THROW, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_RAISERROR, 'RaisError', @KW_RAISERROR, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_PRINT, 'Print', @KW_PRINT, 0, 0, 0);

INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_RETURN, 'Return', @KW_RETURN, 0, 0, 0);

/*
INSERT INTO [ParserEnum].[TSqlStatementType]
([Id], [Name], [StartKeywordId], [AlwaysStartWithStartKeyword], [IsSingleKeywordStatement], [CannotStopPreviousStatement])
VALUES (@ST_BEGIN_DIALOG, 'BeginDialog', @KW_BEGIN, 0, 0, 0);
*/


DECLARE @seqId SMALLINT;

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_statement>', @SQT_ANY_STATEMENT);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_statements>', @SQT_SEQUENCE_OF_STATEMENTS);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sql_block>', @SQT_BLOCK_STATEMENT);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<more_tokens>', @SQT_MORE_TOKENS);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<seq_in_parentheses>', @SQT_SEQUENCE_IN_PARENTHESES);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<case_expression>', @SQT_CASE_EXPRESSION);

SET @seqId=SCOPE_IDENTITY();

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<identifier_dot>', @SQT_IDENTIFIER_DOT);

SET @seqId=SCOPE_IDENTITY();

DECLARE @id INT;  

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_IDENTIFIER, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, NULL, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);



INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<two_part_identifier>', @SQT_TWO_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, @id + 1, NULL, NULL, @SQT_IDENTIFIER_DOT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_IDENTIFIER, @seqId, 0, @id + 2, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<three_part_identifier>', @SQT_THREE_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, NULL, NULL, NULL, @SQT_TWO_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_IDENTIFIER, @seqId, 0, @id + 3, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<four_part_identifier>', @SQT_FOUR_PART_IDENTIFIER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id, @ET_SEQUENCE, @seqId, 1, @id + 1, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_SEPARATOR, @seqId, 0, @id + 2, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_IDENTIFIER, @seqId, 0, @id + 3, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<scalar_expression>', @SQT_SCALAR_EXPRESSION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 20;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_LITERAL, @seqId, 1, @id + 15, @id + 1, NULL, NULL, @TT_LITERAL, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 1, @ET_IDENTIFIER, @seqId, 0, @id + 2, @id + 4, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 2, @ET_SEPARATOR, @seqId, 0, @id + 1, @id + 3, NULL, NULL, @TT_SEPARATOR, @TST_PERIOD);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 4, @id + 15, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 6, @KW_OVER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, @id + 15, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, @id + 7, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 7, @ET_OPERATOR, @seqId, 0, @id, @id + 8, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 8, @ET_OPERATOR, @seqId, 0, @id, @id + 9, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OR_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 9, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_CASE_EXPRESSION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 15, @ET_OPERATOR, @seqId, 0, @id, @id + 16, NULL, NULL, @TT_OPERATOR, @TST_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 16, @ET_OPERATOR, @seqId, 0, @id, @id + 17, NULL, NULL, @TT_OPERATOR, @TST_UNARY_OR_BINARY_OPERATOR);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_KEYWORD, @seqId, 0, @id, @id + 18, @KW_AND, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 18, @ET_KEYWORD, @seqId, 0, @id, @id + 19, @KW_OR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 19, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<output_clause>', @SQT_OUTPUT_CLAUSE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_OUTPUT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SEQUENCE, @seqId, 0, @id + 2, NULL, NULL, NULL, @SQT_SCALAR_EXPRESSION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 3, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 3, @ET_IDENTIFIER, @seqId, 0, @id + 4, @id + 4, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 4, @ET_SEPARATOR, @seqId, 0, @id + 1, @id + 5, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 5, @ET_KEYWORD, @seqId, 0, @id + 6, @id + 8, @KW_INTO, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 6, @ET_IDENTIFIER, @seqId, 0, @id + 7, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 7, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 8, @id + 8, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<var_assign>', @SQT_VAR_ASSIGN);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_VARIABLE_NAME, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_OPERATOR, @seqId, 0, @id + 2, NULL, NULL, @OP_EQ);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [SequenceTypeId])
VALUES ('<sp_number>', @SQT_SP_NUMBER);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;
-- 
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id, @ET_SEPARATOR, @seqId, 1, @id + 1, NULL, NULL, NULL, @TT_SEPARATOR, @TST_SEMICOLON);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_LITERAL_INT, @seqId, 0, @id + 2, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);




-- https://learn.microsoft.com/en-us/sql/t-sql/statements/create-procedure-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('CreateProcedure', @ST_CREATE_PROCEDURE);

SET @seqId=SCOPE_IDENTITY();


EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

-- SELECT @id;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CREATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, @id + 3, @KW_OR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, NULL, @KW_ALTER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 4, @KW_PROC, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, NULL, @KW_PROCEDURE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SEQUENCE, @seqId, 0, @id + 6, NULL, NULL, NULL, @SQT_TWO_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Select', @ST_SELECT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_SELECT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

-- https://learn.microsoft.com/en-us/sql/t-sql/statements/insert-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Insert', @ST_INSERT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 25;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_INSERT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, @id + 4, @KW_TOP, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 4, @KW_PERCENT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, @id + 5, @KW_INTO, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SEQUENCE, @seqId, 0, @id + 9, @id + 6, NULL, NULL, @SQT_FOUR_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_KEYWORD, @seqId, 0, @id + 8, @id + 7, @KW_OPENQUERY, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 7, @ET_KEYWORD, @seqId, 0, @id + 8, @id + 9, @KW_OPENROWSET, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 9, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 9, @ET_KEYWORD, @seqId, 0, @id + 10, @id + 11, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 10, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 11, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

-- ( column_list ) 
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 11, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 12, @id + 12, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

-- OUTPUT clause
INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 12, @ET_SEQUENCE, @seqId, 0, @id + 13, @id + 13, NULL, NULL, @SQT_OUTPUT_CLAUSE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 13, @ET_KEYWORD, @seqId, 0, @id + 14, @id + 16, @KW_VALUES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 14, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 15, @ET_SEPARATOR, @seqId, 0, @id + 14, @id + 24, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 16, @ET_KEYWORD, @seqId, 0, @id + 17, @id + 18, @KW_DEFAULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_KEYWORD, @seqId, 0, @id + 24, NULL, @KW_VALUES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId], [TokenTypeId], [TokenSubtypeId], [StatementTypeId])
VALUES
(@id + 18, @ET_STATEMENT, @seqId, 0, @id + 24, @id + 19, NULL, NULL, NULL, @SP_CHILD_STATEMENT, NULL, NULL, @ST_SELECT);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId], [TokenTypeId], [TokenSubtypeId], [StatementTypeId])
VALUES
(@id + 19, @ET_STATEMENT, @seqId, 0, @id + 24, NULL, NULL, NULL, NULL, @SP_CHILD_STATEMENT, NULL, NULL, @ST_EXEC);




-- *****
-- SELECT
-- EXEC


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 24, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Update', @ST_UPDATE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_UPDATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Delete', @ST_DELETE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DELETE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


-- https://learn.microsoft.com/en-us/sql/t-sql/statements/truncate-table-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('TruncateTable', @ST_TRUNCATE_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_TRUNCATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 5, @KW_WITH, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 5, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);






INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('DropTable', @ST_DROP_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10;

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DROP, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 4, @KW_IF, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, NULL, @KW_EXISTS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SEQUENCE, @seqId, 0, @id + 5, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 5, @ET_SEPARATOR, @seqId, 0, @id + 4, @id + 6, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 6, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);



-- *****


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('CreateTable', @ST_CREATE_TABLE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 10

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CREATE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_TABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SEQUENCE, @seqId, 0, @id + 3, NULL, NULL, NULL, @SQT_THREE_PART_IDENTIFIER, @SP_IDENTIFIER);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 5, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 5, NULL, @KW_FILETABLE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 5, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 6, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

/*
[ ON { partition_scheme_name ( partition_column_name )
           | filegroup
           | "default" } ]
    [ TEXTIMAGE_ON { filegroup | "default" } ]
    [ FILESTREAM_ON { partition_scheme_name
           | filegroup
           | "default" } ]
*/

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_KEYWORD, @seqId, 0, @id + 7, @id + 8, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 7, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 8, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 8, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


-- https://learn.microsoft.com/en-us/sql/t-sql/language-elements/execute-transact-sql?view=sql-server-ver16
INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Exec', @ST_EXEC);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 35

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 2, @id + 1, @KW_EXEC, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 1, @id + 2, NULL, @KW_EXECUTE, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 2, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 3, @id + 12, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 8, @KW_AS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 4, @ET_KEYWORD, @seqId, 0, @id + 6, @id + 5, @KW_LOGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 5, @ET_KEYWORD, @seqId, 0, @id + 6, NULL, @KW_USER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 6, @ET_OPERATOR, @seqId, 0, @id + 7, NULL, NULL, @OP_EQ);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 7, @ET_LITERAL_STRING, @seqId, 0, @id + 8, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 8, @ET_KEYWORD, @seqId, 0, @id + 9, @id + 34, @KW_AT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 9, @ET_KEYWORD, @seqId, 0, @id + 10, @id + 10, @KW_DATA_SOURCE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 10, @ET_IDENTIFIER, @seqId, 0, @id + 34, NULL, NULL, NULL, @TT_IDENTIFIER, NULL);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 12, @ET_SEQUENCE, @seqId, 0, @id + 13, @id + 13, NULL, NULL, @SQT_VAR_ASSIGN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 13, @ET_VARIABLE_NAME, @seqId, 0, @id + 16, @id + 14, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 14, @ET_SEQUENCE, @seqId, 0, @id + 15, NULL, NULL, NULL, @SQT_FOUR_PART_IDENTIFIER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 15, @ET_SEQUENCE, @seqId, 0, @id + 16, @id + 16, NULL, NULL, @SQT_SP_NUMBER, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 16, @ET_SEQUENCE, @seqId, 0, @id + 17, @id + 17, NULL, NULL, @SQT_VAR_ASSIGN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 17, @ET_LITERAL, @seqId, 0, @id + 21, @id + 18, NULL, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 18, @ET_VARIABLE_NAME, @seqId, 0, @id + 19, @id + 20, NULL, NULL, @TT_IDENTIFIER, @TST_VARIABLE_NAME);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 19, @ET_KEYWORD, @seqId, 0, @id + 21, @id + 21, @KW_OUTPUT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 20, @ET_KEYWORD, @seqId, 0, @id + 21, @id + 22, @KW_DEFAULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 21, @ET_SEPARATOR, @seqId, 0, @id + 16, @id + 22, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 22, @ET_KEYWORD, @seqId, 0, @id + 23, @id + 34, @KW_WITH, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 23, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 24, @KW_RECOMPILE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 24, @ET_KEYWORD, @seqId, 0, @id + 25, NULL, @KW_RESULT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 25, @ET_KEYWORD, @seqId, 0, @id + 26, NULL, @KW_SETS, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 26, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 27, @KW_UNDEFINED, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 27, @ET_KEYWORD, @seqId, 0, @id + 29, @id + 28, @KW_NONE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 28, @ET_SPECIAL_SEQUENCE, @seqId, 0, @id + 29, NULL, NULL, NULL, @SQT_SEQUENCE_IN_PARENTHESES, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [TokenTypeId], [TokenSubtypeId])
VALUES
(@id + 29, @ET_SEPARATOR, @seqId, 0, @id + 23, @id + 34, NULL, NULL, @TT_SEPARATOR, @TST_COMMA);


INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 34, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Declare', @ST_DECLARE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_DECLARE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Set', @ST_SET);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_SET, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('BeginTran', @ST_BEGIN_TRANSACTION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BEGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 3, @id + 2, @KW_TRAN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 3, NULL, @KW_TRANSACTION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 3, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('BeginDistTran', @ST_BEGIN_DISTRIBUTED_TRANSACTION);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BEGIN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 1, @ET_KEYWORD, @seqId, 0, @id + 2, NULL, @KW_DISTRIBUTED, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 2, @ET_KEYWORD, @seqId, 0, @id + 4, @id + 3, @KW_TRAN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id + 3, @ET_KEYWORD, @seqId, 0, @id + 4, NULL, @KW_TRANSACTION, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 4, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Commit', @ST_COMMIT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_COMMIT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);


INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Rollback', @ST_ROLLBACK);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_ROLLBACK, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('If', @ST_IF);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_IF, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('While', @ST_WHILE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_WHILE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Continue', @ST_CONTINUE);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 2

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_CONTINUE, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Break', @ST_BREAK);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 2

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_BREAK, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_END, @seqId, 0, NULL, NULL, NULL, NULL, NULL, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Throw', @ST_THROW);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_THROW, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('RaisError', @ST_RAISERROR);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_RAISERROR, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Print', @ST_PRINT);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_PRINT, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

INSERT INTO [Parser].[TSqlSequence] ([Name], [StatementTypeId])
VALUES ('Return', @ST_RETURN);

SET @seqId=SCOPE_IDENTITY();

EXEC  @id = [Parser].[GetSeqElemIdRange] 5

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId])
VALUES
(@id, @ET_KEYWORD, @seqId, 1, @id + 1, NULL, @KW_RETURN, NULL);

INSERT INTO [Parser].[TSqlSeqElement]
([Id], [TypeId], [SequenceId], [IsStartElement], [NextElementId], [AltElementId], [KeywordId], [OperatorId], [SequenceTypeId], [StatementPartId])
VALUES
(@id + 1, @ET_SPECIAL_SEQUENCE, @seqId, 0, NULL, NULL, NULL, NULL, @SQT_MORE_TOKENS, NULL);

UPDATE [Parser].[TSqlSeqElement]
SET [TokenTypeId]=@TT_KEYWORD WHERE [TypeId]=@ET_KEYWORD AND ISNULL([TokenTypeId],@TT_NONE)<>@TT_KEYWORD;

GO


DECLARE @version VARCHAR(50) = '0.9.0';
DECLARE @apiLevel SMALLINT = 1;
DECLARE @minApiLevel SMALLINT = 1;
DECLARE @description NVARCHAR(500) = N'TigerWrap - new project name'

IF NOT EXISTS (SELECT 1 FROM [dbo].[SchemaVersion] WHERE [Version]=@version)
BEGIN
	INSERT INTO [dbo].[SchemaVersion] ([Version], [Description], [ApiLevel], [MinApiLevel])
	VALUES (@version, @description, @apiLevel, @minApiLevel);
END

GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_Casing];

ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_Language];

ALTER TABLE [Static].[LanguageNameCasing] WITH CHECK CHECK CONSTRAINT [FK_LanguageNameCasing_NameType];

ALTER TABLE [Static].[DataTypeMap] WITH CHECK CHECK CONSTRAINT [FK_DataTypeMap_Language];

ALTER TABLE [Static].[LanguageOption] WITH CHECK CHECK CONSTRAINT [FK_LanguageOption_Language];

ALTER TABLE [Static].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_Language];

ALTER TABLE [Static].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_TemplateType];


GO
PRINT N'Update complete.';


GO
